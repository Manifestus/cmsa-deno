
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model bootstrap
 * 
 */
export type bootstrap = $Result.DefaultSelection<Prisma.$bootstrapPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model CashRegister
 * 
 */
export type CashRegister = $Result.DefaultSelection<Prisma.$CashRegisterPayload>
/**
 * Model PosTerminal
 * 
 */
export type PosTerminal = $Result.DefaultSelection<Prisma.$PosTerminalPayload>
/**
 * Model Workstation
 * 
 */
export type Workstation = $Result.DefaultSelection<Prisma.$WorkstationPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model AuthSession
 * 
 */
export type AuthSession = $Result.DefaultSelection<Prisma.$AuthSessionPayload>
/**
 * Model RequestContext
 * 
 */
export type RequestContext = $Result.DefaultSelection<Prisma.$RequestContextPayload>
/**
 * Model Preclinic
 * 
 */
export type Preclinic = $Result.DefaultSelection<Prisma.$PreclinicPayload>
/**
 * Model Allergy
 * 
 */
export type Allergy = $Result.DefaultSelection<Prisma.$AllergyPayload>
/**
 * Model Problem
 * 
 */
export type Problem = $Result.DefaultSelection<Prisma.$ProblemPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLine
 * 
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model ProviderCommission
 * 
 */
export type ProviderCommission = $Result.DefaultSelection<Prisma.$ProviderCommissionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model CashSession
 * 
 */
export type CashSession = $Result.DefaultSelection<Prisma.$CashSessionPayload>
/**
 * Model CashMovement
 * 
 */
export type CashMovement = $Result.DefaultSelection<Prisma.$CashMovementPayload>
/**
 * Model InventoryProduct
 * 
 */
export type InventoryProduct = $Result.DefaultSelection<Prisma.$InventoryProductPayload>
/**
 * Model ProductStock
 * 
 */
export type ProductStock = $Result.DefaultSelection<Prisma.$ProductStockPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model LabInstrument
 * 
 */
export type LabInstrument = $Result.DefaultSelection<Prisma.$LabInstrumentPayload>
/**
 * Model SpecimenType
 * 
 */
export type SpecimenType = $Result.DefaultSelection<Prisma.$SpecimenTypePayload>
/**
 * Model TestCatalog
 * 
 */
export type TestCatalog = $Result.DefaultSelection<Prisma.$TestCatalogPayload>
/**
 * Model ReferenceRange
 * 
 */
export type ReferenceRange = $Result.DefaultSelection<Prisma.$ReferenceRangePayload>
/**
 * Model LabOrder
 * 
 */
export type LabOrder = $Result.DefaultSelection<Prisma.$LabOrderPayload>
/**
 * Model LabOrderTest
 * 
 */
export type LabOrderTest = $Result.DefaultSelection<Prisma.$LabOrderTestPayload>
/**
 * Model LabDeviceMessage
 * 
 */
export type LabDeviceMessage = $Result.DefaultSelection<Prisma.$LabDeviceMessagePayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Sex: {
  M: 'M',
  F: 'F',
  Other: 'Other',
  Unknown: 'Unknown'
};

export type Sex = (typeof Sex)[keyof typeof Sex]


export const MaritalStatus: {
  single: 'single',
  married: 'married',
  divorced: 'divorced',
  widowed: 'widowed',
  other: 'other'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const WorkstationType: {
  frontdesk: 'frontdesk',
  cashier: 'cashier',
  admin: 'admin',
  lab: 'lab',
  ultrasound: 'ultrasound',
  doctor_office: 'doctor_office'
};

export type WorkstationType = (typeof WorkstationType)[keyof typeof WorkstationType]


export const InvoiceStatus: {
  draft: 'draft',
  posted: 'posted',
  void: 'void'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const ItemType: {
  service: 'service',
  product: 'product'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const PaymentMethod: {
  cash: 'cash',
  card: 'card',
  transfer: 'transfer',
  other: 'other'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const TransferStatus: {
  not_completed: 'not_completed',
  completed: 'completed'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const CashMovementType: {
  sale: 'sale',
  withdrawal: 'withdrawal',
  deposit: 'deposit',
  adjustment: 'adjustment'
};

export type CashMovementType = (typeof CashMovementType)[keyof typeof CashMovementType]


export const StockReason: {
  purchase: 'purchase',
  sale: 'sale',
  adjustment: 'adjustment',
  loss: 'loss',
  return: 'return'
};

export type StockReason = (typeof StockReason)[keyof typeof StockReason]


export const AllergySeverity: {
  mild: 'mild',
  moderate: 'moderate',
  severe: 'severe',
  unknown: 'unknown'
};

export type AllergySeverity = (typeof AllergySeverity)[keyof typeof AllergySeverity]


export const ProblemStatus: {
  active: 'active',
  resolved: 'resolved',
  remission: 'remission',
  unknown: 'unknown'
};

export type ProblemStatus = (typeof ProblemStatus)[keyof typeof ProblemStatus]


export const Route: {
  oral: 'oral',
  iv: 'iv',
  im: 'im',
  sc: 'sc',
  topical: 'topical',
  other: 'other'
};

export type Route = (typeof Route)[keyof typeof Route]


export const Priority: {
  routine: 'routine',
  urgent: 'urgent',
  stat: 'stat'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const LabOrderStatus: {
  pending: 'pending',
  in_progress: 'in_progress',
  completed: 'completed',
  canceled: 'canceled',
  partial: 'partial'
};

export type LabOrderStatus = (typeof LabOrderStatus)[keyof typeof LabOrderStatus]


export const LabOrderTestStatus: {
  pending: 'pending',
  in_progress: 'in_progress',
  completed: 'completed',
  canceled: 'canceled'
};

export type LabOrderTestStatus = (typeof LabOrderTestStatus)[keyof typeof LabOrderTestStatus]


export const AbnormalFlag: {
  H: 'H',
  L: 'L',
  N: 'N',
  A: 'A'
};

export type AbnormalFlag = (typeof AbnormalFlag)[keyof typeof AbnormalFlag]


export const OutOfRangeFlag: {
  low: 'low',
  high: 'high'
};

export type OutOfRangeFlag = (typeof OutOfRangeFlag)[keyof typeof OutOfRangeFlag]


export const ConnectionType: {
  serial: 'serial',
  tcp: 'tcp',
  file: 'file',
  other: 'other'
};

export type ConnectionType = (typeof ConnectionType)[keyof typeof ConnectionType]


export const ProtocolKind: {
  HL7: 'HL7',
  ASTM: 'ASTM',
  CSV: 'CSV',
  TXT: 'TXT',
  JSON: 'JSON',
  Other: 'Other'
};

export type ProtocolKind = (typeof ProtocolKind)[keyof typeof ProtocolKind]

}

export type Sex = $Enums.Sex

export const Sex: typeof $Enums.Sex

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type WorkstationType = $Enums.WorkstationType

export const WorkstationType: typeof $Enums.WorkstationType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type CashMovementType = $Enums.CashMovementType

export const CashMovementType: typeof $Enums.CashMovementType

export type StockReason = $Enums.StockReason

export const StockReason: typeof $Enums.StockReason

export type AllergySeverity = $Enums.AllergySeverity

export const AllergySeverity: typeof $Enums.AllergySeverity

export type ProblemStatus = $Enums.ProblemStatus

export const ProblemStatus: typeof $Enums.ProblemStatus

export type Route = $Enums.Route

export const Route: typeof $Enums.Route

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type LabOrderStatus = $Enums.LabOrderStatus

export const LabOrderStatus: typeof $Enums.LabOrderStatus

export type LabOrderTestStatus = $Enums.LabOrderTestStatus

export const LabOrderTestStatus: typeof $Enums.LabOrderTestStatus

export type AbnormalFlag = $Enums.AbnormalFlag

export const AbnormalFlag: typeof $Enums.AbnormalFlag

export type OutOfRangeFlag = $Enums.OutOfRangeFlag

export const OutOfRangeFlag: typeof $Enums.OutOfRangeFlag

export type ConnectionType = $Enums.ConnectionType

export const ConnectionType: typeof $Enums.ConnectionType

export type ProtocolKind = $Enums.ProtocolKind

export const ProtocolKind: typeof $Enums.ProtocolKind

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bootstraps
 * const bootstraps = await prisma.bootstrap.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bootstraps
   * const bootstraps = await prisma.bootstrap.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.bootstrap`: Exposes CRUD operations for the **bootstrap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bootstraps
    * const bootstraps = await prisma.bootstrap.findMany()
    * ```
    */
  get bootstrap(): Prisma.bootstrapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashRegister`: Exposes CRUD operations for the **CashRegister** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashRegisters
    * const cashRegisters = await prisma.cashRegister.findMany()
    * ```
    */
  get cashRegister(): Prisma.CashRegisterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posTerminal`: Exposes CRUD operations for the **PosTerminal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosTerminals
    * const posTerminals = await prisma.posTerminal.findMany()
    * ```
    */
  get posTerminal(): Prisma.PosTerminalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workstation`: Exposes CRUD operations for the **Workstation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workstations
    * const workstations = await prisma.workstation.findMany()
    * ```
    */
  get workstation(): Prisma.WorkstationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authSession`: Exposes CRUD operations for the **AuthSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthSessions
    * const authSessions = await prisma.authSession.findMany()
    * ```
    */
  get authSession(): Prisma.AuthSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestContext`: Exposes CRUD operations for the **RequestContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestContexts
    * const requestContexts = await prisma.requestContext.findMany()
    * ```
    */
  get requestContext(): Prisma.RequestContextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preclinic`: Exposes CRUD operations for the **Preclinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preclinics
    * const preclinics = await prisma.preclinic.findMany()
    * ```
    */
  get preclinic(): Prisma.PreclinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allergy`: Exposes CRUD operations for the **Allergy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allergies
    * const allergies = await prisma.allergy.findMany()
    * ```
    */
  get allergy(): Prisma.AllergyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.problem`: Exposes CRUD operations for the **Problem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problems
    * const problems = await prisma.problem.findMany()
    * ```
    */
  get problem(): Prisma.ProblemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerCommission`: Exposes CRUD operations for the **ProviderCommission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderCommissions
    * const providerCommissions = await prisma.providerCommission.findMany()
    * ```
    */
  get providerCommission(): Prisma.ProviderCommissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashSession`: Exposes CRUD operations for the **CashSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashSessions
    * const cashSessions = await prisma.cashSession.findMany()
    * ```
    */
  get cashSession(): Prisma.CashSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashMovement`: Exposes CRUD operations for the **CashMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashMovements
    * const cashMovements = await prisma.cashMovement.findMany()
    * ```
    */
  get cashMovement(): Prisma.CashMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryProduct`: Exposes CRUD operations for the **InventoryProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryProducts
    * const inventoryProducts = await prisma.inventoryProduct.findMany()
    * ```
    */
  get inventoryProduct(): Prisma.InventoryProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productStock`: Exposes CRUD operations for the **ProductStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStocks
    * const productStocks = await prisma.productStock.findMany()
    * ```
    */
  get productStock(): Prisma.ProductStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labInstrument`: Exposes CRUD operations for the **LabInstrument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabInstruments
    * const labInstruments = await prisma.labInstrument.findMany()
    * ```
    */
  get labInstrument(): Prisma.LabInstrumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specimenType`: Exposes CRUD operations for the **SpecimenType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecimenTypes
    * const specimenTypes = await prisma.specimenType.findMany()
    * ```
    */
  get specimenType(): Prisma.SpecimenTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testCatalog`: Exposes CRUD operations for the **TestCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestCatalogs
    * const testCatalogs = await prisma.testCatalog.findMany()
    * ```
    */
  get testCatalog(): Prisma.TestCatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referenceRange`: Exposes CRUD operations for the **ReferenceRange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceRanges
    * const referenceRanges = await prisma.referenceRange.findMany()
    * ```
    */
  get referenceRange(): Prisma.ReferenceRangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labOrder`: Exposes CRUD operations for the **LabOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabOrders
    * const labOrders = await prisma.labOrder.findMany()
    * ```
    */
  get labOrder(): Prisma.LabOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labOrderTest`: Exposes CRUD operations for the **LabOrderTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabOrderTests
    * const labOrderTests = await prisma.labOrderTest.findMany()
    * ```
    */
  get labOrderTest(): Prisma.LabOrderTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labDeviceMessage`: Exposes CRUD operations for the **LabDeviceMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabDeviceMessages
    * const labDeviceMessages = await prisma.labDeviceMessage.findMany()
    * ```
    */
  get labDeviceMessage(): Prisma.LabDeviceMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    bootstrap: 'bootstrap',
    Role: 'Role',
    User: 'User',
    UserRole: 'UserRole',
    Location: 'Location',
    CashRegister: 'CashRegister',
    PosTerminal: 'PosTerminal',
    Workstation: 'Workstation',
    Patient: 'Patient',
    AuthSession: 'AuthSession',
    RequestContext: 'RequestContext',
    Preclinic: 'Preclinic',
    Allergy: 'Allergy',
    Problem: 'Problem',
    Medication: 'Medication',
    ServiceCategory: 'ServiceCategory',
    Service: 'Service',
    Provider: 'Provider',
    Invoice: 'Invoice',
    InvoiceLine: 'InvoiceLine',
    ProviderCommission: 'ProviderCommission',
    Payment: 'Payment',
    CashSession: 'CashSession',
    CashMovement: 'CashMovement',
    InventoryProduct: 'InventoryProduct',
    ProductStock: 'ProductStock',
    StockMovement: 'StockMovement',
    LabInstrument: 'LabInstrument',
    SpecimenType: 'SpecimenType',
    TestCatalog: 'TestCatalog',
    ReferenceRange: 'ReferenceRange',
    LabOrder: 'LabOrder',
    LabOrderTest: 'LabOrderTest',
    LabDeviceMessage: 'LabDeviceMessage',
    ActivityLog: 'ActivityLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "bootstrap" | "role" | "user" | "userRole" | "location" | "cashRegister" | "posTerminal" | "workstation" | "patient" | "authSession" | "requestContext" | "preclinic" | "allergy" | "problem" | "medication" | "serviceCategory" | "service" | "provider" | "invoice" | "invoiceLine" | "providerCommission" | "payment" | "cashSession" | "cashMovement" | "inventoryProduct" | "productStock" | "stockMovement" | "labInstrument" | "specimenType" | "testCatalog" | "referenceRange" | "labOrder" | "labOrderTest" | "labDeviceMessage" | "activityLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      bootstrap: {
        payload: Prisma.$bootstrapPayload<ExtArgs>
        fields: Prisma.bootstrapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bootstrapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bootstrapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>
          }
          findFirst: {
            args: Prisma.bootstrapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bootstrapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>
          }
          findMany: {
            args: Prisma.bootstrapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>[]
          }
          create: {
            args: Prisma.bootstrapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>
          }
          createMany: {
            args: Prisma.bootstrapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bootstrapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>[]
          }
          delete: {
            args: Prisma.bootstrapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>
          }
          update: {
            args: Prisma.bootstrapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>
          }
          deleteMany: {
            args: Prisma.bootstrapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bootstrapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bootstrapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>[]
          }
          upsert: {
            args: Prisma.bootstrapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootstrapPayload>
          }
          aggregate: {
            args: Prisma.BootstrapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBootstrap>
          }
          groupBy: {
            args: Prisma.bootstrapGroupByArgs<ExtArgs>
            result: $Utils.Optional<BootstrapGroupByOutputType>[]
          }
          count: {
            args: Prisma.bootstrapCountArgs<ExtArgs>
            result: $Utils.Optional<BootstrapCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      CashRegister: {
        payload: Prisma.$CashRegisterPayload<ExtArgs>
        fields: Prisma.CashRegisterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashRegisterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashRegisterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          findFirst: {
            args: Prisma.CashRegisterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashRegisterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          findMany: {
            args: Prisma.CashRegisterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          create: {
            args: Prisma.CashRegisterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          createMany: {
            args: Prisma.CashRegisterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashRegisterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          delete: {
            args: Prisma.CashRegisterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          update: {
            args: Prisma.CashRegisterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          deleteMany: {
            args: Prisma.CashRegisterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashRegisterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashRegisterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          upsert: {
            args: Prisma.CashRegisterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          aggregate: {
            args: Prisma.CashRegisterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashRegister>
          }
          groupBy: {
            args: Prisma.CashRegisterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashRegisterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashRegisterCountArgs<ExtArgs>
            result: $Utils.Optional<CashRegisterCountAggregateOutputType> | number
          }
        }
      }
      PosTerminal: {
        payload: Prisma.$PosTerminalPayload<ExtArgs>
        fields: Prisma.PosTerminalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosTerminalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosTerminalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>
          }
          findFirst: {
            args: Prisma.PosTerminalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosTerminalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>
          }
          findMany: {
            args: Prisma.PosTerminalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>[]
          }
          create: {
            args: Prisma.PosTerminalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>
          }
          createMany: {
            args: Prisma.PosTerminalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosTerminalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>[]
          }
          delete: {
            args: Prisma.PosTerminalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>
          }
          update: {
            args: Prisma.PosTerminalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>
          }
          deleteMany: {
            args: Prisma.PosTerminalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosTerminalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosTerminalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>[]
          }
          upsert: {
            args: Prisma.PosTerminalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosTerminalPayload>
          }
          aggregate: {
            args: Prisma.PosTerminalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosTerminal>
          }
          groupBy: {
            args: Prisma.PosTerminalGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosTerminalGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosTerminalCountArgs<ExtArgs>
            result: $Utils.Optional<PosTerminalCountAggregateOutputType> | number
          }
        }
      }
      Workstation: {
        payload: Prisma.$WorkstationPayload<ExtArgs>
        fields: Prisma.WorkstationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkstationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkstationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>
          }
          findFirst: {
            args: Prisma.WorkstationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkstationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>
          }
          findMany: {
            args: Prisma.WorkstationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>[]
          }
          create: {
            args: Prisma.WorkstationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>
          }
          createMany: {
            args: Prisma.WorkstationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkstationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>[]
          }
          delete: {
            args: Prisma.WorkstationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>
          }
          update: {
            args: Prisma.WorkstationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>
          }
          deleteMany: {
            args: Prisma.WorkstationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkstationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkstationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>[]
          }
          upsert: {
            args: Prisma.WorkstationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkstationPayload>
          }
          aggregate: {
            args: Prisma.WorkstationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkstation>
          }
          groupBy: {
            args: Prisma.WorkstationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkstationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkstationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkstationCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      AuthSession: {
        payload: Prisma.$AuthSessionPayload<ExtArgs>
        fields: Prisma.AuthSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findFirst: {
            args: Prisma.AuthSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findMany: {
            args: Prisma.AuthSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          create: {
            args: Prisma.AuthSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          createMany: {
            args: Prisma.AuthSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          delete: {
            args: Prisma.AuthSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          update: {
            args: Prisma.AuthSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          deleteMany: {
            args: Prisma.AuthSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          upsert: {
            args: Prisma.AuthSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          aggregate: {
            args: Prisma.AuthSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthSession>
          }
          groupBy: {
            args: Prisma.AuthSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionCountAggregateOutputType> | number
          }
        }
      }
      RequestContext: {
        payload: Prisma.$RequestContextPayload<ExtArgs>
        fields: Prisma.RequestContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>
          }
          findFirst: {
            args: Prisma.RequestContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>
          }
          findMany: {
            args: Prisma.RequestContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>[]
          }
          create: {
            args: Prisma.RequestContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>
          }
          createMany: {
            args: Prisma.RequestContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>[]
          }
          delete: {
            args: Prisma.RequestContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>
          }
          update: {
            args: Prisma.RequestContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>
          }
          deleteMany: {
            args: Prisma.RequestContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestContextUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>[]
          }
          upsert: {
            args: Prisma.RequestContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestContextPayload>
          }
          aggregate: {
            args: Prisma.RequestContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestContext>
          }
          groupBy: {
            args: Prisma.RequestContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestContextCountArgs<ExtArgs>
            result: $Utils.Optional<RequestContextCountAggregateOutputType> | number
          }
        }
      }
      Preclinic: {
        payload: Prisma.$PreclinicPayload<ExtArgs>
        fields: Prisma.PreclinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreclinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreclinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>
          }
          findFirst: {
            args: Prisma.PreclinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreclinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>
          }
          findMany: {
            args: Prisma.PreclinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>[]
          }
          create: {
            args: Prisma.PreclinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>
          }
          createMany: {
            args: Prisma.PreclinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreclinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>[]
          }
          delete: {
            args: Prisma.PreclinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>
          }
          update: {
            args: Prisma.PreclinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>
          }
          deleteMany: {
            args: Prisma.PreclinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreclinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreclinicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>[]
          }
          upsert: {
            args: Prisma.PreclinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreclinicPayload>
          }
          aggregate: {
            args: Prisma.PreclinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreclinic>
          }
          groupBy: {
            args: Prisma.PreclinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreclinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreclinicCountArgs<ExtArgs>
            result: $Utils.Optional<PreclinicCountAggregateOutputType> | number
          }
        }
      }
      Allergy: {
        payload: Prisma.$AllergyPayload<ExtArgs>
        fields: Prisma.AllergyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllergyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllergyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          findFirst: {
            args: Prisma.AllergyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllergyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          findMany: {
            args: Prisma.AllergyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          create: {
            args: Prisma.AllergyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          createMany: {
            args: Prisma.AllergyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllergyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          delete: {
            args: Prisma.AllergyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          update: {
            args: Prisma.AllergyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          deleteMany: {
            args: Prisma.AllergyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllergyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllergyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          upsert: {
            args: Prisma.AllergyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          aggregate: {
            args: Prisma.AllergyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllergy>
          }
          groupBy: {
            args: Prisma.AllergyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllergyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllergyCountArgs<ExtArgs>
            result: $Utils.Optional<AllergyCountAggregateOutputType> | number
          }
        }
      }
      Problem: {
        payload: Prisma.$ProblemPayload<ExtArgs>
        fields: Prisma.ProblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProblemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProblemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          findFirst: {
            args: Prisma.ProblemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProblemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          findMany: {
            args: Prisma.ProblemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>[]
          }
          create: {
            args: Prisma.ProblemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          createMany: {
            args: Prisma.ProblemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProblemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>[]
          }
          delete: {
            args: Prisma.ProblemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          update: {
            args: Prisma.ProblemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          deleteMany: {
            args: Prisma.ProblemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProblemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProblemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>[]
          }
          upsert: {
            args: Prisma.ProblemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          aggregate: {
            args: Prisma.ProblemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblem>
          }
          groupBy: {
            args: Prisma.ProblemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProblemCountArgs<ExtArgs>
            result: $Utils.Optional<ProblemCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      ProviderCommission: {
        payload: Prisma.$ProviderCommissionPayload<ExtArgs>
        fields: Prisma.ProviderCommissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderCommissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderCommissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>
          }
          findFirst: {
            args: Prisma.ProviderCommissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderCommissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>
          }
          findMany: {
            args: Prisma.ProviderCommissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>[]
          }
          create: {
            args: Prisma.ProviderCommissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>
          }
          createMany: {
            args: Prisma.ProviderCommissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCommissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>[]
          }
          delete: {
            args: Prisma.ProviderCommissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>
          }
          update: {
            args: Prisma.ProviderCommissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>
          }
          deleteMany: {
            args: Prisma.ProviderCommissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderCommissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderCommissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>[]
          }
          upsert: {
            args: Prisma.ProviderCommissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderCommissionPayload>
          }
          aggregate: {
            args: Prisma.ProviderCommissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderCommission>
          }
          groupBy: {
            args: Prisma.ProviderCommissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderCommissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCommissionCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCommissionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      CashSession: {
        payload: Prisma.$CashSessionPayload<ExtArgs>
        fields: Prisma.CashSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>
          }
          findFirst: {
            args: Prisma.CashSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>
          }
          findMany: {
            args: Prisma.CashSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>[]
          }
          create: {
            args: Prisma.CashSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>
          }
          createMany: {
            args: Prisma.CashSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>[]
          }
          delete: {
            args: Prisma.CashSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>
          }
          update: {
            args: Prisma.CashSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>
          }
          deleteMany: {
            args: Prisma.CashSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>[]
          }
          upsert: {
            args: Prisma.CashSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashSessionPayload>
          }
          aggregate: {
            args: Prisma.CashSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashSession>
          }
          groupBy: {
            args: Prisma.CashSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CashSessionCountAggregateOutputType> | number
          }
        }
      }
      CashMovement: {
        payload: Prisma.$CashMovementPayload<ExtArgs>
        fields: Prisma.CashMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          findFirst: {
            args: Prisma.CashMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          findMany: {
            args: Prisma.CashMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>[]
          }
          create: {
            args: Prisma.CashMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          createMany: {
            args: Prisma.CashMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>[]
          }
          delete: {
            args: Prisma.CashMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          update: {
            args: Prisma.CashMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          deleteMany: {
            args: Prisma.CashMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>[]
          }
          upsert: {
            args: Prisma.CashMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashMovementPayload>
          }
          aggregate: {
            args: Prisma.CashMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashMovement>
          }
          groupBy: {
            args: Prisma.CashMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashMovementCountArgs<ExtArgs>
            result: $Utils.Optional<CashMovementCountAggregateOutputType> | number
          }
        }
      }
      InventoryProduct: {
        payload: Prisma.$InventoryProductPayload<ExtArgs>
        fields: Prisma.InventoryProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>
          }
          findFirst: {
            args: Prisma.InventoryProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>
          }
          findMany: {
            args: Prisma.InventoryProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>[]
          }
          create: {
            args: Prisma.InventoryProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>
          }
          createMany: {
            args: Prisma.InventoryProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>[]
          }
          delete: {
            args: Prisma.InventoryProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>
          }
          update: {
            args: Prisma.InventoryProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>
          }
          deleteMany: {
            args: Prisma.InventoryProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>[]
          }
          upsert: {
            args: Prisma.InventoryProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryProductPayload>
          }
          aggregate: {
            args: Prisma.InventoryProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryProduct>
          }
          groupBy: {
            args: Prisma.InventoryProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryProductCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryProductCountAggregateOutputType> | number
          }
        }
      }
      ProductStock: {
        payload: Prisma.$ProductStockPayload<ExtArgs>
        fields: Prisma.ProductStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findFirst: {
            args: Prisma.ProductStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findMany: {
            args: Prisma.ProductStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          create: {
            args: Prisma.ProductStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          createMany: {
            args: Prisma.ProductStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          delete: {
            args: Prisma.ProductStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          update: {
            args: Prisma.ProductStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          deleteMany: {
            args: Prisma.ProductStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          upsert: {
            args: Prisma.ProductStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          aggregate: {
            args: Prisma.ProductStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStock>
          }
          groupBy: {
            args: Prisma.ProductStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStockCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStockCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      LabInstrument: {
        payload: Prisma.$LabInstrumentPayload<ExtArgs>
        fields: Prisma.LabInstrumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabInstrumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabInstrumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>
          }
          findFirst: {
            args: Prisma.LabInstrumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabInstrumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>
          }
          findMany: {
            args: Prisma.LabInstrumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>[]
          }
          create: {
            args: Prisma.LabInstrumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>
          }
          createMany: {
            args: Prisma.LabInstrumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabInstrumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>[]
          }
          delete: {
            args: Prisma.LabInstrumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>
          }
          update: {
            args: Prisma.LabInstrumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>
          }
          deleteMany: {
            args: Prisma.LabInstrumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabInstrumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabInstrumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>[]
          }
          upsert: {
            args: Prisma.LabInstrumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabInstrumentPayload>
          }
          aggregate: {
            args: Prisma.LabInstrumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabInstrument>
          }
          groupBy: {
            args: Prisma.LabInstrumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabInstrumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabInstrumentCountArgs<ExtArgs>
            result: $Utils.Optional<LabInstrumentCountAggregateOutputType> | number
          }
        }
      }
      SpecimenType: {
        payload: Prisma.$SpecimenTypePayload<ExtArgs>
        fields: Prisma.SpecimenTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecimenTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecimenTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>
          }
          findFirst: {
            args: Prisma.SpecimenTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecimenTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>
          }
          findMany: {
            args: Prisma.SpecimenTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>[]
          }
          create: {
            args: Prisma.SpecimenTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>
          }
          createMany: {
            args: Prisma.SpecimenTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecimenTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>[]
          }
          delete: {
            args: Prisma.SpecimenTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>
          }
          update: {
            args: Prisma.SpecimenTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>
          }
          deleteMany: {
            args: Prisma.SpecimenTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecimenTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecimenTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>[]
          }
          upsert: {
            args: Prisma.SpecimenTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecimenTypePayload>
          }
          aggregate: {
            args: Prisma.SpecimenTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecimenType>
          }
          groupBy: {
            args: Prisma.SpecimenTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecimenTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecimenTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SpecimenTypeCountAggregateOutputType> | number
          }
        }
      }
      TestCatalog: {
        payload: Prisma.$TestCatalogPayload<ExtArgs>
        fields: Prisma.TestCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>
          }
          findFirst: {
            args: Prisma.TestCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>
          }
          findMany: {
            args: Prisma.TestCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>[]
          }
          create: {
            args: Prisma.TestCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>
          }
          createMany: {
            args: Prisma.TestCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>[]
          }
          delete: {
            args: Prisma.TestCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>
          }
          update: {
            args: Prisma.TestCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>
          }
          deleteMany: {
            args: Prisma.TestCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestCatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>[]
          }
          upsert: {
            args: Prisma.TestCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCatalogPayload>
          }
          aggregate: {
            args: Prisma.TestCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestCatalog>
          }
          groupBy: {
            args: Prisma.TestCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<TestCatalogCountAggregateOutputType> | number
          }
        }
      }
      ReferenceRange: {
        payload: Prisma.$ReferenceRangePayload<ExtArgs>
        fields: Prisma.ReferenceRangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceRangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceRangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>
          }
          findFirst: {
            args: Prisma.ReferenceRangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceRangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>
          }
          findMany: {
            args: Prisma.ReferenceRangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>[]
          }
          create: {
            args: Prisma.ReferenceRangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>
          }
          createMany: {
            args: Prisma.ReferenceRangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferenceRangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>[]
          }
          delete: {
            args: Prisma.ReferenceRangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>
          }
          update: {
            args: Prisma.ReferenceRangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>
          }
          deleteMany: {
            args: Prisma.ReferenceRangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceRangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferenceRangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>[]
          }
          upsert: {
            args: Prisma.ReferenceRangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceRangePayload>
          }
          aggregate: {
            args: Prisma.ReferenceRangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferenceRange>
          }
          groupBy: {
            args: Prisma.ReferenceRangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceRangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferenceRangeCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceRangeCountAggregateOutputType> | number
          }
        }
      }
      LabOrder: {
        payload: Prisma.$LabOrderPayload<ExtArgs>
        fields: Prisma.LabOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          findFirst: {
            args: Prisma.LabOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          findMany: {
            args: Prisma.LabOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>[]
          }
          create: {
            args: Prisma.LabOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          createMany: {
            args: Prisma.LabOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>[]
          }
          delete: {
            args: Prisma.LabOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          update: {
            args: Prisma.LabOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          deleteMany: {
            args: Prisma.LabOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>[]
          }
          upsert: {
            args: Prisma.LabOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          aggregate: {
            args: Prisma.LabOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabOrder>
          }
          groupBy: {
            args: Prisma.LabOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabOrderCountArgs<ExtArgs>
            result: $Utils.Optional<LabOrderCountAggregateOutputType> | number
          }
        }
      }
      LabOrderTest: {
        payload: Prisma.$LabOrderTestPayload<ExtArgs>
        fields: Prisma.LabOrderTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabOrderTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabOrderTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          findFirst: {
            args: Prisma.LabOrderTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabOrderTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          findMany: {
            args: Prisma.LabOrderTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>[]
          }
          create: {
            args: Prisma.LabOrderTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          createMany: {
            args: Prisma.LabOrderTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabOrderTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>[]
          }
          delete: {
            args: Prisma.LabOrderTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          update: {
            args: Prisma.LabOrderTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          deleteMany: {
            args: Prisma.LabOrderTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabOrderTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabOrderTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>[]
          }
          upsert: {
            args: Prisma.LabOrderTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          aggregate: {
            args: Prisma.LabOrderTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabOrderTest>
          }
          groupBy: {
            args: Prisma.LabOrderTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabOrderTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabOrderTestCountArgs<ExtArgs>
            result: $Utils.Optional<LabOrderTestCountAggregateOutputType> | number
          }
        }
      }
      LabDeviceMessage: {
        payload: Prisma.$LabDeviceMessagePayload<ExtArgs>
        fields: Prisma.LabDeviceMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabDeviceMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabDeviceMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>
          }
          findFirst: {
            args: Prisma.LabDeviceMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabDeviceMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>
          }
          findMany: {
            args: Prisma.LabDeviceMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>[]
          }
          create: {
            args: Prisma.LabDeviceMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>
          }
          createMany: {
            args: Prisma.LabDeviceMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabDeviceMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>[]
          }
          delete: {
            args: Prisma.LabDeviceMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>
          }
          update: {
            args: Prisma.LabDeviceMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>
          }
          deleteMany: {
            args: Prisma.LabDeviceMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabDeviceMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabDeviceMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>[]
          }
          upsert: {
            args: Prisma.LabDeviceMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabDeviceMessagePayload>
          }
          aggregate: {
            args: Prisma.LabDeviceMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabDeviceMessage>
          }
          groupBy: {
            args: Prisma.LabDeviceMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabDeviceMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabDeviceMessageCountArgs<ExtArgs>
            result: $Utils.Optional<LabDeviceMessageCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    bootstrap?: bootstrapOmit
    role?: RoleOmit
    user?: UserOmit
    userRole?: UserRoleOmit
    location?: LocationOmit
    cashRegister?: CashRegisterOmit
    posTerminal?: PosTerminalOmit
    workstation?: WorkstationOmit
    patient?: PatientOmit
    authSession?: AuthSessionOmit
    requestContext?: RequestContextOmit
    preclinic?: PreclinicOmit
    allergy?: AllergyOmit
    problem?: ProblemOmit
    medication?: MedicationOmit
    serviceCategory?: ServiceCategoryOmit
    service?: ServiceOmit
    provider?: ProviderOmit
    invoice?: InvoiceOmit
    invoiceLine?: InvoiceLineOmit
    providerCommission?: ProviderCommissionOmit
    payment?: PaymentOmit
    cashSession?: CashSessionOmit
    cashMovement?: CashMovementOmit
    inventoryProduct?: InventoryProductOmit
    productStock?: ProductStockOmit
    stockMovement?: StockMovementOmit
    labInstrument?: LabInstrumentOmit
    specimenType?: SpecimenTypeOmit
    testCatalog?: TestCatalogOmit
    referenceRange?: ReferenceRangeOmit
    labOrder?: LabOrderOmit
    labOrderTest?: LabOrderTestOmit
    labDeviceMessage?: LabDeviceMessageOmit
    activityLog?: ActivityLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
    sessions: number
    patientsCreated: number
    preclinics: number
    problemsRecorded: number
    allergiesRecorded: number
    medicationsRx: number
    invoicesCashier: number
    paymentsCreated: number
    cashSessionsOpen: number
    cashSessionsClose: number
    cashMovements: number
    labOrdersOrdered: number
    labOrdersCollected: number
    activity: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    patientsCreated?: boolean | UserCountOutputTypeCountPatientsCreatedArgs
    preclinics?: boolean | UserCountOutputTypeCountPreclinicsArgs
    problemsRecorded?: boolean | UserCountOutputTypeCountProblemsRecordedArgs
    allergiesRecorded?: boolean | UserCountOutputTypeCountAllergiesRecordedArgs
    medicationsRx?: boolean | UserCountOutputTypeCountMedicationsRxArgs
    invoicesCashier?: boolean | UserCountOutputTypeCountInvoicesCashierArgs
    paymentsCreated?: boolean | UserCountOutputTypeCountPaymentsCreatedArgs
    cashSessionsOpen?: boolean | UserCountOutputTypeCountCashSessionsOpenArgs
    cashSessionsClose?: boolean | UserCountOutputTypeCountCashSessionsCloseArgs
    cashMovements?: boolean | UserCountOutputTypeCountCashMovementsArgs
    labOrdersOrdered?: boolean | UserCountOutputTypeCountLabOrdersOrderedArgs
    labOrdersCollected?: boolean | UserCountOutputTypeCountLabOrdersCollectedArgs
    activity?: boolean | UserCountOutputTypeCountActivityArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatientsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPreclinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreclinicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProblemsRecordedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAllergiesRecordedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicationsRxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesCashierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashSessionsOpenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashSessionsCloseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabOrdersOrderedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabOrdersCollectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    registers: number
    posTerminals: number
    workstations: number
    productStock: number
    stockMoves: number
    labInstruments: number
    invoices: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registers?: boolean | LocationCountOutputTypeCountRegistersArgs
    posTerminals?: boolean | LocationCountOutputTypeCountPosTerminalsArgs
    workstations?: boolean | LocationCountOutputTypeCountWorkstationsArgs
    productStock?: boolean | LocationCountOutputTypeCountProductStockArgs
    stockMoves?: boolean | LocationCountOutputTypeCountStockMovesArgs
    labInstruments?: boolean | LocationCountOutputTypeCountLabInstrumentsArgs
    invoices?: boolean | LocationCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPosTerminalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosTerminalWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountWorkstationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkstationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountProductStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountLabInstrumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabInstrumentWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type CashRegisterCountOutputType
   */

  export type CashRegisterCountOutputType = {
    sessions: number
    invoices: number
  }

  export type CashRegisterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | CashRegisterCountOutputTypeCountSessionsArgs
    invoices?: boolean | CashRegisterCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegisterCountOutputType
     */
    select?: CashRegisterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashSessionWhereInput
  }

  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type PosTerminalCountOutputType
   */

  export type PosTerminalCountOutputType = {
    payments: number
  }

  export type PosTerminalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PosTerminalCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PosTerminalCountOutputType without action
   */
  export type PosTerminalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminalCountOutputType
     */
    select?: PosTerminalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PosTerminalCountOutputType without action
   */
  export type PosTerminalCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type WorkstationCountOutputType
   */

  export type WorkstationCountOutputType = {
    sessions: number
    contexts: number
  }

  export type WorkstationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | WorkstationCountOutputTypeCountSessionsArgs
    contexts?: boolean | WorkstationCountOutputTypeCountContextsArgs
  }

  // Custom InputTypes
  /**
   * WorkstationCountOutputType without action
   */
  export type WorkstationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkstationCountOutputType
     */
    select?: WorkstationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkstationCountOutputType without action
   */
  export type WorkstationCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
  }

  /**
   * WorkstationCountOutputType without action
   */
  export type WorkstationCountOutputTypeCountContextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestContextWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    preclinics: number
    allergies: number
    problems: number
    medications: number
    invoices: number
    labOrders: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preclinics?: boolean | PatientCountOutputTypeCountPreclinicsArgs
    allergies?: boolean | PatientCountOutputTypeCountAllergiesArgs
    problems?: boolean | PatientCountOutputTypeCountProblemsArgs
    medications?: boolean | PatientCountOutputTypeCountMedicationsArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    labOrders?: boolean | PatientCountOutputTypeCountLabOrdersArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPreclinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreclinicWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAllergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountProblemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }


  /**
   * Count Type AuthSessionCountOutputType
   */

  export type AuthSessionCountOutputType = {
    contexts: number
  }

  export type AuthSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contexts?: boolean | AuthSessionCountOutputTypeCountContextsArgs
  }

  // Custom InputTypes
  /**
   * AuthSessionCountOutputType without action
   */
  export type AuthSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSessionCountOutputType
     */
    select?: AuthSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthSessionCountOutputType without action
   */
  export type AuthSessionCountOutputTypeCountContextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestContextWhereInput
  }


  /**
   * Count Type RequestContextCountOutputType
   */

  export type RequestContextCountOutputType = {
    invoices: number
    payments: number
    cashMoves: number
    preclinics: number
    labOrders: number
    labOrderTests: number
    activities: number
  }

  export type RequestContextCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | RequestContextCountOutputTypeCountInvoicesArgs
    payments?: boolean | RequestContextCountOutputTypeCountPaymentsArgs
    cashMoves?: boolean | RequestContextCountOutputTypeCountCashMovesArgs
    preclinics?: boolean | RequestContextCountOutputTypeCountPreclinicsArgs
    labOrders?: boolean | RequestContextCountOutputTypeCountLabOrdersArgs
    labOrderTests?: boolean | RequestContextCountOutputTypeCountLabOrderTestsArgs
    activities?: boolean | RequestContextCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContextCountOutputType
     */
    select?: RequestContextCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountCashMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountPreclinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreclinicWhereInput
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountLabOrderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }

  /**
   * RequestContextCountOutputType without action
   */
  export type RequestContextCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type PreclinicCountOutputType
   */

  export type PreclinicCountOutputType = {
    labOrders: number
    invoices: number
  }

  export type PreclinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labOrders?: boolean | PreclinicCountOutputTypeCountLabOrdersArgs
    invoices?: boolean | PreclinicCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * PreclinicCountOutputType without action
   */
  export type PreclinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreclinicCountOutputType
     */
    select?: PreclinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PreclinicCountOutputType without action
   */
  export type PreclinicCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * PreclinicCountOutputType without action
   */
  export type PreclinicCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    services: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategoryCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    lines: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | ServiceCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    lines: number
    commissions: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | ProviderCountOutputTypeCountLinesArgs
    commissions?: boolean | ProviderCountOutputTypeCountCommissionsArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderCommissionWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lines: number
    payments: number
    labOrders: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceCountOutputTypeCountLinesArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    labOrders?: boolean | InvoiceCountOutputTypeCountLabOrdersArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }


  /**
   * Count Type CashSessionCountOutputType
   */

  export type CashSessionCountOutputType = {
    movements: number
  }

  export type CashSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | CashSessionCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * CashSessionCountOutputType without action
   */
  export type CashSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSessionCountOutputType
     */
    select?: CashSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashSessionCountOutputType without action
   */
  export type CashSessionCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
  }


  /**
   * Count Type InventoryProductCountOutputType
   */

  export type InventoryProductCountOutputType = {
    stock: number
    stockMoves: number
    lines: number
  }

  export type InventoryProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | InventoryProductCountOutputTypeCountStockArgs
    stockMoves?: boolean | InventoryProductCountOutputTypeCountStockMovesArgs
    lines?: boolean | InventoryProductCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * InventoryProductCountOutputType without action
   */
  export type InventoryProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProductCountOutputType
     */
    select?: InventoryProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryProductCountOutputType without action
   */
  export type InventoryProductCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
  }

  /**
   * InventoryProductCountOutputType without action
   */
  export type InventoryProductCountOutputTypeCountStockMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * InventoryProductCountOutputType without action
   */
  export type InventoryProductCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }


  /**
   * Count Type LabInstrumentCountOutputType
   */

  export type LabInstrumentCountOutputType = {
    testsDefault: number
    orderTests: number
    messages: number
  }

  export type LabInstrumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testsDefault?: boolean | LabInstrumentCountOutputTypeCountTestsDefaultArgs
    orderTests?: boolean | LabInstrumentCountOutputTypeCountOrderTestsArgs
    messages?: boolean | LabInstrumentCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * LabInstrumentCountOutputType without action
   */
  export type LabInstrumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrumentCountOutputType
     */
    select?: LabInstrumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabInstrumentCountOutputType without action
   */
  export type LabInstrumentCountOutputTypeCountTestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCatalogWhereInput
  }

  /**
   * LabInstrumentCountOutputType without action
   */
  export type LabInstrumentCountOutputTypeCountOrderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }

  /**
   * LabInstrumentCountOutputType without action
   */
  export type LabInstrumentCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabDeviceMessageWhereInput
  }


  /**
   * Count Type SpecimenTypeCountOutputType
   */

  export type SpecimenTypeCountOutputType = {
    tests: number
    orders: number
  }

  export type SpecimenTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | SpecimenTypeCountOutputTypeCountTestsArgs
    orders?: boolean | SpecimenTypeCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * SpecimenTypeCountOutputType without action
   */
  export type SpecimenTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenTypeCountOutputType
     */
    select?: SpecimenTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecimenTypeCountOutputType without action
   */
  export type SpecimenTypeCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCatalogWhereInput
  }

  /**
   * SpecimenTypeCountOutputType without action
   */
  export type SpecimenTypeCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }


  /**
   * Count Type TestCatalogCountOutputType
   */

  export type TestCatalogCountOutputType = {
    panelMembers: number
    ranges: number
    orderTests: number
  }

  export type TestCatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panelMembers?: boolean | TestCatalogCountOutputTypeCountPanelMembersArgs
    ranges?: boolean | TestCatalogCountOutputTypeCountRangesArgs
    orderTests?: boolean | TestCatalogCountOutputTypeCountOrderTestsArgs
  }

  // Custom InputTypes
  /**
   * TestCatalogCountOutputType without action
   */
  export type TestCatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalogCountOutputType
     */
    select?: TestCatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCatalogCountOutputType without action
   */
  export type TestCatalogCountOutputTypeCountPanelMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCatalogWhereInput
  }

  /**
   * TestCatalogCountOutputType without action
   */
  export type TestCatalogCountOutputTypeCountRangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceRangeWhereInput
  }

  /**
   * TestCatalogCountOutputType without action
   */
  export type TestCatalogCountOutputTypeCountOrderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }


  /**
   * Count Type LabOrderCountOutputType
   */

  export type LabOrderCountOutputType = {
    tests: number
    messages: number
  }

  export type LabOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | LabOrderCountOutputTypeCountTestsArgs
    messages?: boolean | LabOrderCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * LabOrderCountOutputType without action
   */
  export type LabOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderCountOutputType
     */
    select?: LabOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabOrderCountOutputType without action
   */
  export type LabOrderCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }

  /**
   * LabOrderCountOutputType without action
   */
  export type LabOrderCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabDeviceMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model bootstrap
   */

  export type AggregateBootstrap = {
    _count: BootstrapCountAggregateOutputType | null
    _min: BootstrapMinAggregateOutputType | null
    _max: BootstrapMaxAggregateOutputType | null
  }

  export type BootstrapMinAggregateOutputType = {
    id: string | null
    txt: string | null
  }

  export type BootstrapMaxAggregateOutputType = {
    id: string | null
    txt: string | null
  }

  export type BootstrapCountAggregateOutputType = {
    id: number
    txt: number
    _all: number
  }


  export type BootstrapMinAggregateInputType = {
    id?: true
    txt?: true
  }

  export type BootstrapMaxAggregateInputType = {
    id?: true
    txt?: true
  }

  export type BootstrapCountAggregateInputType = {
    id?: true
    txt?: true
    _all?: true
  }

  export type BootstrapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootstrap to aggregate.
     */
    where?: bootstrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootstraps to fetch.
     */
    orderBy?: bootstrapOrderByWithRelationInput | bootstrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bootstrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootstraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootstraps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bootstraps
    **/
    _count?: true | BootstrapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BootstrapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BootstrapMaxAggregateInputType
  }

  export type GetBootstrapAggregateType<T extends BootstrapAggregateArgs> = {
        [P in keyof T & keyof AggregateBootstrap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBootstrap[P]>
      : GetScalarType<T[P], AggregateBootstrap[P]>
  }




  export type bootstrapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootstrapWhereInput
    orderBy?: bootstrapOrderByWithAggregationInput | bootstrapOrderByWithAggregationInput[]
    by: BootstrapScalarFieldEnum[] | BootstrapScalarFieldEnum
    having?: bootstrapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BootstrapCountAggregateInputType | true
    _min?: BootstrapMinAggregateInputType
    _max?: BootstrapMaxAggregateInputType
  }

  export type BootstrapGroupByOutputType = {
    id: string
    txt: string
    _count: BootstrapCountAggregateOutputType | null
    _min: BootstrapMinAggregateOutputType | null
    _max: BootstrapMaxAggregateOutputType | null
  }

  type GetBootstrapGroupByPayload<T extends bootstrapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BootstrapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BootstrapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BootstrapGroupByOutputType[P]>
            : GetScalarType<T[P], BootstrapGroupByOutputType[P]>
        }
      >
    >


  export type bootstrapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txt?: boolean
  }, ExtArgs["result"]["bootstrap"]>

  export type bootstrapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txt?: boolean
  }, ExtArgs["result"]["bootstrap"]>

  export type bootstrapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txt?: boolean
  }, ExtArgs["result"]["bootstrap"]>

  export type bootstrapSelectScalar = {
    id?: boolean
    txt?: boolean
  }

  export type bootstrapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "txt", ExtArgs["result"]["bootstrap"]>

  export type $bootstrapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bootstrap"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      txt: string
    }, ExtArgs["result"]["bootstrap"]>
    composites: {}
  }

  type bootstrapGetPayload<S extends boolean | null | undefined | bootstrapDefaultArgs> = $Result.GetResult<Prisma.$bootstrapPayload, S>

  type bootstrapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bootstrapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BootstrapCountAggregateInputType | true
    }

  export interface bootstrapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bootstrap'], meta: { name: 'bootstrap' } }
    /**
     * Find zero or one Bootstrap that matches the filter.
     * @param {bootstrapFindUniqueArgs} args - Arguments to find a Bootstrap
     * @example
     * // Get one Bootstrap
     * const bootstrap = await prisma.bootstrap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bootstrapFindUniqueArgs>(args: SelectSubset<T, bootstrapFindUniqueArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bootstrap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bootstrapFindUniqueOrThrowArgs} args - Arguments to find a Bootstrap
     * @example
     * // Get one Bootstrap
     * const bootstrap = await prisma.bootstrap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bootstrapFindUniqueOrThrowArgs>(args: SelectSubset<T, bootstrapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootstrap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootstrapFindFirstArgs} args - Arguments to find a Bootstrap
     * @example
     * // Get one Bootstrap
     * const bootstrap = await prisma.bootstrap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bootstrapFindFirstArgs>(args?: SelectSubset<T, bootstrapFindFirstArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootstrap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootstrapFindFirstOrThrowArgs} args - Arguments to find a Bootstrap
     * @example
     * // Get one Bootstrap
     * const bootstrap = await prisma.bootstrap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bootstrapFindFirstOrThrowArgs>(args?: SelectSubset<T, bootstrapFindFirstOrThrowArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bootstraps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootstrapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bootstraps
     * const bootstraps = await prisma.bootstrap.findMany()
     * 
     * // Get first 10 Bootstraps
     * const bootstraps = await prisma.bootstrap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bootstrapWithIdOnly = await prisma.bootstrap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bootstrapFindManyArgs>(args?: SelectSubset<T, bootstrapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bootstrap.
     * @param {bootstrapCreateArgs} args - Arguments to create a Bootstrap.
     * @example
     * // Create one Bootstrap
     * const Bootstrap = await prisma.bootstrap.create({
     *   data: {
     *     // ... data to create a Bootstrap
     *   }
     * })
     * 
     */
    create<T extends bootstrapCreateArgs>(args: SelectSubset<T, bootstrapCreateArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bootstraps.
     * @param {bootstrapCreateManyArgs} args - Arguments to create many Bootstraps.
     * @example
     * // Create many Bootstraps
     * const bootstrap = await prisma.bootstrap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bootstrapCreateManyArgs>(args?: SelectSubset<T, bootstrapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bootstraps and returns the data saved in the database.
     * @param {bootstrapCreateManyAndReturnArgs} args - Arguments to create many Bootstraps.
     * @example
     * // Create many Bootstraps
     * const bootstrap = await prisma.bootstrap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bootstraps and only return the `id`
     * const bootstrapWithIdOnly = await prisma.bootstrap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bootstrapCreateManyAndReturnArgs>(args?: SelectSubset<T, bootstrapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bootstrap.
     * @param {bootstrapDeleteArgs} args - Arguments to delete one Bootstrap.
     * @example
     * // Delete one Bootstrap
     * const Bootstrap = await prisma.bootstrap.delete({
     *   where: {
     *     // ... filter to delete one Bootstrap
     *   }
     * })
     * 
     */
    delete<T extends bootstrapDeleteArgs>(args: SelectSubset<T, bootstrapDeleteArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bootstrap.
     * @param {bootstrapUpdateArgs} args - Arguments to update one Bootstrap.
     * @example
     * // Update one Bootstrap
     * const bootstrap = await prisma.bootstrap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bootstrapUpdateArgs>(args: SelectSubset<T, bootstrapUpdateArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bootstraps.
     * @param {bootstrapDeleteManyArgs} args - Arguments to filter Bootstraps to delete.
     * @example
     * // Delete a few Bootstraps
     * const { count } = await prisma.bootstrap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bootstrapDeleteManyArgs>(args?: SelectSubset<T, bootstrapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootstraps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootstrapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bootstraps
     * const bootstrap = await prisma.bootstrap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bootstrapUpdateManyArgs>(args: SelectSubset<T, bootstrapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootstraps and returns the data updated in the database.
     * @param {bootstrapUpdateManyAndReturnArgs} args - Arguments to update many Bootstraps.
     * @example
     * // Update many Bootstraps
     * const bootstrap = await prisma.bootstrap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bootstraps and only return the `id`
     * const bootstrapWithIdOnly = await prisma.bootstrap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bootstrapUpdateManyAndReturnArgs>(args: SelectSubset<T, bootstrapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bootstrap.
     * @param {bootstrapUpsertArgs} args - Arguments to update or create a Bootstrap.
     * @example
     * // Update or create a Bootstrap
     * const bootstrap = await prisma.bootstrap.upsert({
     *   create: {
     *     // ... data to create a Bootstrap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bootstrap we want to update
     *   }
     * })
     */
    upsert<T extends bootstrapUpsertArgs>(args: SelectSubset<T, bootstrapUpsertArgs<ExtArgs>>): Prisma__bootstrapClient<$Result.GetResult<Prisma.$bootstrapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bootstraps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootstrapCountArgs} args - Arguments to filter Bootstraps to count.
     * @example
     * // Count the number of Bootstraps
     * const count = await prisma.bootstrap.count({
     *   where: {
     *     // ... the filter for the Bootstraps we want to count
     *   }
     * })
    **/
    count<T extends bootstrapCountArgs>(
      args?: Subset<T, bootstrapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BootstrapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bootstrap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BootstrapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BootstrapAggregateArgs>(args: Subset<T, BootstrapAggregateArgs>): Prisma.PrismaPromise<GetBootstrapAggregateType<T>>

    /**
     * Group by Bootstrap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootstrapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bootstrapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bootstrapGroupByArgs['orderBy'] }
        : { orderBy?: bootstrapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bootstrapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBootstrapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bootstrap model
   */
  readonly fields: bootstrapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bootstrap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bootstrapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bootstrap model
   */
  interface bootstrapFieldRefs {
    readonly id: FieldRef<"bootstrap", 'String'>
    readonly txt: FieldRef<"bootstrap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bootstrap findUnique
   */
  export type bootstrapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * Filter, which bootstrap to fetch.
     */
    where: bootstrapWhereUniqueInput
  }

  /**
   * bootstrap findUniqueOrThrow
   */
  export type bootstrapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * Filter, which bootstrap to fetch.
     */
    where: bootstrapWhereUniqueInput
  }

  /**
   * bootstrap findFirst
   */
  export type bootstrapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * Filter, which bootstrap to fetch.
     */
    where?: bootstrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootstraps to fetch.
     */
    orderBy?: bootstrapOrderByWithRelationInput | bootstrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootstraps.
     */
    cursor?: bootstrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootstraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootstraps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootstraps.
     */
    distinct?: BootstrapScalarFieldEnum | BootstrapScalarFieldEnum[]
  }

  /**
   * bootstrap findFirstOrThrow
   */
  export type bootstrapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * Filter, which bootstrap to fetch.
     */
    where?: bootstrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootstraps to fetch.
     */
    orderBy?: bootstrapOrderByWithRelationInput | bootstrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootstraps.
     */
    cursor?: bootstrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootstraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootstraps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootstraps.
     */
    distinct?: BootstrapScalarFieldEnum | BootstrapScalarFieldEnum[]
  }

  /**
   * bootstrap findMany
   */
  export type bootstrapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * Filter, which bootstraps to fetch.
     */
    where?: bootstrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootstraps to fetch.
     */
    orderBy?: bootstrapOrderByWithRelationInput | bootstrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bootstraps.
     */
    cursor?: bootstrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootstraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootstraps.
     */
    skip?: number
    distinct?: BootstrapScalarFieldEnum | BootstrapScalarFieldEnum[]
  }

  /**
   * bootstrap create
   */
  export type bootstrapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * The data needed to create a bootstrap.
     */
    data: XOR<bootstrapCreateInput, bootstrapUncheckedCreateInput>
  }

  /**
   * bootstrap createMany
   */
  export type bootstrapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bootstraps.
     */
    data: bootstrapCreateManyInput | bootstrapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bootstrap createManyAndReturn
   */
  export type bootstrapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * The data used to create many bootstraps.
     */
    data: bootstrapCreateManyInput | bootstrapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bootstrap update
   */
  export type bootstrapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * The data needed to update a bootstrap.
     */
    data: XOR<bootstrapUpdateInput, bootstrapUncheckedUpdateInput>
    /**
     * Choose, which bootstrap to update.
     */
    where: bootstrapWhereUniqueInput
  }

  /**
   * bootstrap updateMany
   */
  export type bootstrapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bootstraps.
     */
    data: XOR<bootstrapUpdateManyMutationInput, bootstrapUncheckedUpdateManyInput>
    /**
     * Filter which bootstraps to update
     */
    where?: bootstrapWhereInput
    /**
     * Limit how many bootstraps to update.
     */
    limit?: number
  }

  /**
   * bootstrap updateManyAndReturn
   */
  export type bootstrapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * The data used to update bootstraps.
     */
    data: XOR<bootstrapUpdateManyMutationInput, bootstrapUncheckedUpdateManyInput>
    /**
     * Filter which bootstraps to update
     */
    where?: bootstrapWhereInput
    /**
     * Limit how many bootstraps to update.
     */
    limit?: number
  }

  /**
   * bootstrap upsert
   */
  export type bootstrapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * The filter to search for the bootstrap to update in case it exists.
     */
    where: bootstrapWhereUniqueInput
    /**
     * In case the bootstrap found by the `where` argument doesn't exist, create a new bootstrap with this data.
     */
    create: XOR<bootstrapCreateInput, bootstrapUncheckedCreateInput>
    /**
     * In case the bootstrap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bootstrapUpdateInput, bootstrapUncheckedUpdateInput>
  }

  /**
   * bootstrap delete
   */
  export type bootstrapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
    /**
     * Filter which bootstrap to delete.
     */
    where: bootstrapWhereUniqueInput
  }

  /**
   * bootstrap deleteMany
   */
  export type bootstrapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootstraps to delete
     */
    where?: bootstrapWhereInput
    /**
     * Limit how many bootstraps to delete.
     */
    limit?: number
  }

  /**
   * bootstrap without action
   */
  export type bootstrapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootstrap
     */
    select?: bootstrapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootstrap
     */
    omit?: bootstrapOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    fullName: number
    email: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    fullName?: true
    email?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    fullName?: true
    email?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    fullName?: true
    email?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    fullName: string
    email: string
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    patientsCreated?: boolean | User$patientsCreatedArgs<ExtArgs>
    preclinics?: boolean | User$preclinicsArgs<ExtArgs>
    problemsRecorded?: boolean | User$problemsRecordedArgs<ExtArgs>
    allergiesRecorded?: boolean | User$allergiesRecordedArgs<ExtArgs>
    medicationsRx?: boolean | User$medicationsRxArgs<ExtArgs>
    invoicesCashier?: boolean | User$invoicesCashierArgs<ExtArgs>
    paymentsCreated?: boolean | User$paymentsCreatedArgs<ExtArgs>
    cashSessionsOpen?: boolean | User$cashSessionsOpenArgs<ExtArgs>
    cashSessionsClose?: boolean | User$cashSessionsCloseArgs<ExtArgs>
    cashMovements?: boolean | User$cashMovementsArgs<ExtArgs>
    labOrdersOrdered?: boolean | User$labOrdersOrderedArgs<ExtArgs>
    labOrdersCollected?: boolean | User$labOrdersCollectedArgs<ExtArgs>
    activity?: boolean | User$activityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "fullName" | "email" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    patientsCreated?: boolean | User$patientsCreatedArgs<ExtArgs>
    preclinics?: boolean | User$preclinicsArgs<ExtArgs>
    problemsRecorded?: boolean | User$problemsRecordedArgs<ExtArgs>
    allergiesRecorded?: boolean | User$allergiesRecordedArgs<ExtArgs>
    medicationsRx?: boolean | User$medicationsRxArgs<ExtArgs>
    invoicesCashier?: boolean | User$invoicesCashierArgs<ExtArgs>
    paymentsCreated?: boolean | User$paymentsCreatedArgs<ExtArgs>
    cashSessionsOpen?: boolean | User$cashSessionsOpenArgs<ExtArgs>
    cashSessionsClose?: boolean | User$cashSessionsCloseArgs<ExtArgs>
    cashMovements?: boolean | User$cashMovementsArgs<ExtArgs>
    labOrdersOrdered?: boolean | User$labOrdersOrderedArgs<ExtArgs>
    labOrdersCollected?: boolean | User$labOrdersCollectedArgs<ExtArgs>
    activity?: boolean | User$activityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      sessions: Prisma.$AuthSessionPayload<ExtArgs>[]
      patientsCreated: Prisma.$PatientPayload<ExtArgs>[]
      preclinics: Prisma.$PreclinicPayload<ExtArgs>[]
      problemsRecorded: Prisma.$ProblemPayload<ExtArgs>[]
      allergiesRecorded: Prisma.$AllergyPayload<ExtArgs>[]
      medicationsRx: Prisma.$MedicationPayload<ExtArgs>[]
      invoicesCashier: Prisma.$InvoicePayload<ExtArgs>[]
      paymentsCreated: Prisma.$PaymentPayload<ExtArgs>[]
      cashSessionsOpen: Prisma.$CashSessionPayload<ExtArgs>[]
      cashSessionsClose: Prisma.$CashSessionPayload<ExtArgs>[]
      cashMovements: Prisma.$CashMovementPayload<ExtArgs>[]
      labOrdersOrdered: Prisma.$LabOrderPayload<ExtArgs>[]
      labOrdersCollected: Prisma.$LabOrderPayload<ExtArgs>[]
      activity: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      fullName: string
      email: string
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patientsCreated<T extends User$patientsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$patientsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preclinics<T extends User$preclinicsArgs<ExtArgs> = {}>(args?: Subset<T, User$preclinicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    problemsRecorded<T extends User$problemsRecordedArgs<ExtArgs> = {}>(args?: Subset<T, User$problemsRecordedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allergiesRecorded<T extends User$allergiesRecordedArgs<ExtArgs> = {}>(args?: Subset<T, User$allergiesRecordedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicationsRx<T extends User$medicationsRxArgs<ExtArgs> = {}>(args?: Subset<T, User$medicationsRxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoicesCashier<T extends User$invoicesCashierArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesCashierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsCreated<T extends User$paymentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashSessionsOpen<T extends User$cashSessionsOpenArgs<ExtArgs> = {}>(args?: Subset<T, User$cashSessionsOpenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashSessionsClose<T extends User$cashSessionsCloseArgs<ExtArgs> = {}>(args?: Subset<T, User$cashSessionsCloseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashMovements<T extends User$cashMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrdersOrdered<T extends User$labOrdersOrderedArgs<ExtArgs> = {}>(args?: Subset<T, User$labOrdersOrderedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrdersCollected<T extends User$labOrdersCollectedArgs<ExtArgs> = {}>(args?: Subset<T, User$labOrdersCollectedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity<T extends User$activityArgs<ExtArgs> = {}>(args?: Subset<T, User$activityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    cursor?: AuthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * User.patientsCreated
   */
  export type User$patientsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * User.preclinics
   */
  export type User$preclinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    where?: PreclinicWhereInput
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    cursor?: PreclinicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreclinicScalarFieldEnum | PreclinicScalarFieldEnum[]
  }

  /**
   * User.problemsRecorded
   */
  export type User$problemsRecordedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    where?: ProblemWhereInput
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    cursor?: ProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * User.allergiesRecorded
   */
  export type User$allergiesRecordedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    cursor?: AllergyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * User.medicationsRx
   */
  export type User$medicationsRxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * User.invoicesCashier
   */
  export type User$invoicesCashierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.paymentsCreated
   */
  export type User$paymentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.cashSessionsOpen
   */
  export type User$cashSessionsOpenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    where?: CashSessionWhereInput
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    cursor?: CashSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashSessionScalarFieldEnum | CashSessionScalarFieldEnum[]
  }

  /**
   * User.cashSessionsClose
   */
  export type User$cashSessionsCloseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    where?: CashSessionWhereInput
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    cursor?: CashSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashSessionScalarFieldEnum | CashSessionScalarFieldEnum[]
  }

  /**
   * User.cashMovements
   */
  export type User$cashMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    cursor?: CashMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }

  /**
   * User.labOrdersOrdered
   */
  export type User$labOrdersOrderedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * User.labOrdersCollected
   */
  export type User$labOrdersCollectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * User.activity
   */
  export type User$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string | null
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    registers?: boolean | Location$registersArgs<ExtArgs>
    posTerminals?: boolean | Location$posTerminalsArgs<ExtArgs>
    workstations?: boolean | Location$workstationsArgs<ExtArgs>
    productStock?: boolean | Location$productStockArgs<ExtArgs>
    stockMoves?: boolean | Location$stockMovesArgs<ExtArgs>
    labInstruments?: boolean | Location$labInstrumentsArgs<ExtArgs>
    invoices?: boolean | Location$invoicesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registers?: boolean | Location$registersArgs<ExtArgs>
    posTerminals?: boolean | Location$posTerminalsArgs<ExtArgs>
    workstations?: boolean | Location$workstationsArgs<ExtArgs>
    productStock?: boolean | Location$productStockArgs<ExtArgs>
    stockMoves?: boolean | Location$stockMovesArgs<ExtArgs>
    labInstruments?: boolean | Location$labInstrumentsArgs<ExtArgs>
    invoices?: boolean | Location$invoicesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      registers: Prisma.$CashRegisterPayload<ExtArgs>[]
      posTerminals: Prisma.$PosTerminalPayload<ExtArgs>[]
      workstations: Prisma.$WorkstationPayload<ExtArgs>[]
      productStock: Prisma.$ProductStockPayload<ExtArgs>[]
      stockMoves: Prisma.$StockMovementPayload<ExtArgs>[]
      labInstruments: Prisma.$LabInstrumentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    registers<T extends Location$registersArgs<ExtArgs> = {}>(args?: Subset<T, Location$registersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posTerminals<T extends Location$posTerminalsArgs<ExtArgs> = {}>(args?: Subset<T, Location$posTerminalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workstations<T extends Location$workstationsArgs<ExtArgs> = {}>(args?: Subset<T, Location$workstationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productStock<T extends Location$productStockArgs<ExtArgs> = {}>(args?: Subset<T, Location$productStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMoves<T extends Location$stockMovesArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockMovesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labInstruments<T extends Location$labInstrumentsArgs<ExtArgs> = {}>(args?: Subset<T, Location$labInstrumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Location$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Location$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.registers
   */
  export type Location$registersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    cursor?: CashRegisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * Location.posTerminals
   */
  export type Location$posTerminalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    where?: PosTerminalWhereInput
    orderBy?: PosTerminalOrderByWithRelationInput | PosTerminalOrderByWithRelationInput[]
    cursor?: PosTerminalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosTerminalScalarFieldEnum | PosTerminalScalarFieldEnum[]
  }

  /**
   * Location.workstations
   */
  export type Location$workstationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    where?: WorkstationWhereInput
    orderBy?: WorkstationOrderByWithRelationInput | WorkstationOrderByWithRelationInput[]
    cursor?: WorkstationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkstationScalarFieldEnum | WorkstationScalarFieldEnum[]
  }

  /**
   * Location.productStock
   */
  export type Location$productStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    cursor?: ProductStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * Location.stockMoves
   */
  export type Location$stockMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Location.labInstruments
   */
  export type Location$labInstrumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    where?: LabInstrumentWhereInput
    orderBy?: LabInstrumentOrderByWithRelationInput | LabInstrumentOrderByWithRelationInput[]
    cursor?: LabInstrumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabInstrumentScalarFieldEnum | LabInstrumentScalarFieldEnum[]
  }

  /**
   * Location.invoices
   */
  export type Location$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model CashRegister
   */

  export type AggregateCashRegister = {
    _count: CashRegisterCountAggregateOutputType | null
    _min: CashRegisterMinAggregateOutputType | null
    _max: CashRegisterMaxAggregateOutputType | null
  }

  export type CashRegisterMinAggregateOutputType = {
    id: string | null
    name: string | null
    locationId: string | null
  }

  export type CashRegisterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    locationId: string | null
  }

  export type CashRegisterCountAggregateOutputType = {
    id: number
    name: number
    locationId: number
    _all: number
  }


  export type CashRegisterMinAggregateInputType = {
    id?: true
    name?: true
    locationId?: true
  }

  export type CashRegisterMaxAggregateInputType = {
    id?: true
    name?: true
    locationId?: true
  }

  export type CashRegisterCountAggregateInputType = {
    id?: true
    name?: true
    locationId?: true
    _all?: true
  }

  export type CashRegisterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRegister to aggregate.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashRegisters
    **/
    _count?: true | CashRegisterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashRegisterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashRegisterMaxAggregateInputType
  }

  export type GetCashRegisterAggregateType<T extends CashRegisterAggregateArgs> = {
        [P in keyof T & keyof AggregateCashRegister]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashRegister[P]>
      : GetScalarType<T[P], AggregateCashRegister[P]>
  }




  export type CashRegisterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithAggregationInput | CashRegisterOrderByWithAggregationInput[]
    by: CashRegisterScalarFieldEnum[] | CashRegisterScalarFieldEnum
    having?: CashRegisterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashRegisterCountAggregateInputType | true
    _min?: CashRegisterMinAggregateInputType
    _max?: CashRegisterMaxAggregateInputType
  }

  export type CashRegisterGroupByOutputType = {
    id: string
    name: string
    locationId: string
    _count: CashRegisterCountAggregateOutputType | null
    _min: CashRegisterMinAggregateOutputType | null
    _max: CashRegisterMaxAggregateOutputType | null
  }

  type GetCashRegisterGroupByPayload<T extends CashRegisterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashRegisterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashRegisterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashRegisterGroupByOutputType[P]>
            : GetScalarType<T[P], CashRegisterGroupByOutputType[P]>
        }
      >
    >


  export type CashRegisterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    sessions?: boolean | CashRegister$sessionsArgs<ExtArgs>
    invoices?: boolean | CashRegister$invoicesArgs<ExtArgs>
    _count?: boolean | CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectScalar = {
    id?: boolean
    name?: boolean
    locationId?: boolean
  }

  export type CashRegisterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "locationId", ExtArgs["result"]["cashRegister"]>
  export type CashRegisterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    sessions?: boolean | CashRegister$sessionsArgs<ExtArgs>
    invoices?: boolean | CashRegister$invoicesArgs<ExtArgs>
    _count?: boolean | CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashRegisterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type CashRegisterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $CashRegisterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashRegister"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      sessions: Prisma.$CashSessionPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      locationId: string
    }, ExtArgs["result"]["cashRegister"]>
    composites: {}
  }

  type CashRegisterGetPayload<S extends boolean | null | undefined | CashRegisterDefaultArgs> = $Result.GetResult<Prisma.$CashRegisterPayload, S>

  type CashRegisterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashRegisterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashRegisterCountAggregateInputType | true
    }

  export interface CashRegisterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashRegister'], meta: { name: 'CashRegister' } }
    /**
     * Find zero or one CashRegister that matches the filter.
     * @param {CashRegisterFindUniqueArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashRegisterFindUniqueArgs>(args: SelectSubset<T, CashRegisterFindUniqueArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashRegister that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashRegisterFindUniqueOrThrowArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashRegisterFindUniqueOrThrowArgs>(args: SelectSubset<T, CashRegisterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashRegister that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindFirstArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashRegisterFindFirstArgs>(args?: SelectSubset<T, CashRegisterFindFirstArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashRegister that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindFirstOrThrowArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashRegisterFindFirstOrThrowArgs>(args?: SelectSubset<T, CashRegisterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashRegisters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashRegisters
     * const cashRegisters = await prisma.cashRegister.findMany()
     * 
     * // Get first 10 CashRegisters
     * const cashRegisters = await prisma.cashRegister.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashRegisterFindManyArgs>(args?: SelectSubset<T, CashRegisterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashRegister.
     * @param {CashRegisterCreateArgs} args - Arguments to create a CashRegister.
     * @example
     * // Create one CashRegister
     * const CashRegister = await prisma.cashRegister.create({
     *   data: {
     *     // ... data to create a CashRegister
     *   }
     * })
     * 
     */
    create<T extends CashRegisterCreateArgs>(args: SelectSubset<T, CashRegisterCreateArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashRegisters.
     * @param {CashRegisterCreateManyArgs} args - Arguments to create many CashRegisters.
     * @example
     * // Create many CashRegisters
     * const cashRegister = await prisma.cashRegister.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashRegisterCreateManyArgs>(args?: SelectSubset<T, CashRegisterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashRegisters and returns the data saved in the database.
     * @param {CashRegisterCreateManyAndReturnArgs} args - Arguments to create many CashRegisters.
     * @example
     * // Create many CashRegisters
     * const cashRegister = await prisma.cashRegister.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashRegisters and only return the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashRegisterCreateManyAndReturnArgs>(args?: SelectSubset<T, CashRegisterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashRegister.
     * @param {CashRegisterDeleteArgs} args - Arguments to delete one CashRegister.
     * @example
     * // Delete one CashRegister
     * const CashRegister = await prisma.cashRegister.delete({
     *   where: {
     *     // ... filter to delete one CashRegister
     *   }
     * })
     * 
     */
    delete<T extends CashRegisterDeleteArgs>(args: SelectSubset<T, CashRegisterDeleteArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashRegister.
     * @param {CashRegisterUpdateArgs} args - Arguments to update one CashRegister.
     * @example
     * // Update one CashRegister
     * const cashRegister = await prisma.cashRegister.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashRegisterUpdateArgs>(args: SelectSubset<T, CashRegisterUpdateArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashRegisters.
     * @param {CashRegisterDeleteManyArgs} args - Arguments to filter CashRegisters to delete.
     * @example
     * // Delete a few CashRegisters
     * const { count } = await prisma.cashRegister.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashRegisterDeleteManyArgs>(args?: SelectSubset<T, CashRegisterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashRegisters
     * const cashRegister = await prisma.cashRegister.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashRegisterUpdateManyArgs>(args: SelectSubset<T, CashRegisterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRegisters and returns the data updated in the database.
     * @param {CashRegisterUpdateManyAndReturnArgs} args - Arguments to update many CashRegisters.
     * @example
     * // Update many CashRegisters
     * const cashRegister = await prisma.cashRegister.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashRegisters and only return the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashRegisterUpdateManyAndReturnArgs>(args: SelectSubset<T, CashRegisterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashRegister.
     * @param {CashRegisterUpsertArgs} args - Arguments to update or create a CashRegister.
     * @example
     * // Update or create a CashRegister
     * const cashRegister = await prisma.cashRegister.upsert({
     *   create: {
     *     // ... data to create a CashRegister
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashRegister we want to update
     *   }
     * })
     */
    upsert<T extends CashRegisterUpsertArgs>(args: SelectSubset<T, CashRegisterUpsertArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterCountArgs} args - Arguments to filter CashRegisters to count.
     * @example
     * // Count the number of CashRegisters
     * const count = await prisma.cashRegister.count({
     *   where: {
     *     // ... the filter for the CashRegisters we want to count
     *   }
     * })
    **/
    count<T extends CashRegisterCountArgs>(
      args?: Subset<T, CashRegisterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashRegisterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashRegisterAggregateArgs>(args: Subset<T, CashRegisterAggregateArgs>): Prisma.PrismaPromise<GetCashRegisterAggregateType<T>>

    /**
     * Group by CashRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashRegisterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashRegisterGroupByArgs['orderBy'] }
        : { orderBy?: CashRegisterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashRegisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashRegisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashRegister model
   */
  readonly fields: CashRegisterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashRegister.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashRegisterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends CashRegister$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends CashRegister$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashRegister model
   */
  interface CashRegisterFieldRefs {
    readonly id: FieldRef<"CashRegister", 'String'>
    readonly name: FieldRef<"CashRegister", 'String'>
    readonly locationId: FieldRef<"CashRegister", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CashRegister findUnique
   */
  export type CashRegisterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister findUniqueOrThrow
   */
  export type CashRegisterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister findFirst
   */
  export type CashRegisterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRegisters.
     */
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister findFirstOrThrow
   */
  export type CashRegisterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRegisters.
     */
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister findMany
   */
  export type CashRegisterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegisters to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister create
   */
  export type CashRegisterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The data needed to create a CashRegister.
     */
    data: XOR<CashRegisterCreateInput, CashRegisterUncheckedCreateInput>
  }

  /**
   * CashRegister createMany
   */
  export type CashRegisterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashRegisters.
     */
    data: CashRegisterCreateManyInput | CashRegisterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashRegister createManyAndReturn
   */
  export type CashRegisterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * The data used to create many CashRegisters.
     */
    data: CashRegisterCreateManyInput | CashRegisterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashRegister update
   */
  export type CashRegisterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The data needed to update a CashRegister.
     */
    data: XOR<CashRegisterUpdateInput, CashRegisterUncheckedUpdateInput>
    /**
     * Choose, which CashRegister to update.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister updateMany
   */
  export type CashRegisterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashRegisters.
     */
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyInput>
    /**
     * Filter which CashRegisters to update
     */
    where?: CashRegisterWhereInput
    /**
     * Limit how many CashRegisters to update.
     */
    limit?: number
  }

  /**
   * CashRegister updateManyAndReturn
   */
  export type CashRegisterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * The data used to update CashRegisters.
     */
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyInput>
    /**
     * Filter which CashRegisters to update
     */
    where?: CashRegisterWhereInput
    /**
     * Limit how many CashRegisters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashRegister upsert
   */
  export type CashRegisterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The filter to search for the CashRegister to update in case it exists.
     */
    where: CashRegisterWhereUniqueInput
    /**
     * In case the CashRegister found by the `where` argument doesn't exist, create a new CashRegister with this data.
     */
    create: XOR<CashRegisterCreateInput, CashRegisterUncheckedCreateInput>
    /**
     * In case the CashRegister was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashRegisterUpdateInput, CashRegisterUncheckedUpdateInput>
  }

  /**
   * CashRegister delete
   */
  export type CashRegisterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter which CashRegister to delete.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister deleteMany
   */
  export type CashRegisterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRegisters to delete
     */
    where?: CashRegisterWhereInput
    /**
     * Limit how many CashRegisters to delete.
     */
    limit?: number
  }

  /**
   * CashRegister.sessions
   */
  export type CashRegister$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    where?: CashSessionWhereInput
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    cursor?: CashSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashSessionScalarFieldEnum | CashSessionScalarFieldEnum[]
  }

  /**
   * CashRegister.invoices
   */
  export type CashRegister$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * CashRegister without action
   */
  export type CashRegisterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
  }


  /**
   * Model PosTerminal
   */

  export type AggregatePosTerminal = {
    _count: PosTerminalCountAggregateOutputType | null
    _min: PosTerminalMinAggregateOutputType | null
    _max: PosTerminalMaxAggregateOutputType | null
  }

  export type PosTerminalMinAggregateOutputType = {
    id: string | null
    name: string | null
    provider: string | null
    merchantId: string | null
    locationId: string | null
  }

  export type PosTerminalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    provider: string | null
    merchantId: string | null
    locationId: string | null
  }

  export type PosTerminalCountAggregateOutputType = {
    id: number
    name: number
    provider: number
    merchantId: number
    locationId: number
    _all: number
  }


  export type PosTerminalMinAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    merchantId?: true
    locationId?: true
  }

  export type PosTerminalMaxAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    merchantId?: true
    locationId?: true
  }

  export type PosTerminalCountAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    merchantId?: true
    locationId?: true
    _all?: true
  }

  export type PosTerminalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosTerminal to aggregate.
     */
    where?: PosTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosTerminals to fetch.
     */
    orderBy?: PosTerminalOrderByWithRelationInput | PosTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosTerminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosTerminals
    **/
    _count?: true | PosTerminalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosTerminalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosTerminalMaxAggregateInputType
  }

  export type GetPosTerminalAggregateType<T extends PosTerminalAggregateArgs> = {
        [P in keyof T & keyof AggregatePosTerminal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosTerminal[P]>
      : GetScalarType<T[P], AggregatePosTerminal[P]>
  }




  export type PosTerminalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosTerminalWhereInput
    orderBy?: PosTerminalOrderByWithAggregationInput | PosTerminalOrderByWithAggregationInput[]
    by: PosTerminalScalarFieldEnum[] | PosTerminalScalarFieldEnum
    having?: PosTerminalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosTerminalCountAggregateInputType | true
    _min?: PosTerminalMinAggregateInputType
    _max?: PosTerminalMaxAggregateInputType
  }

  export type PosTerminalGroupByOutputType = {
    id: string
    name: string
    provider: string
    merchantId: string | null
    locationId: string
    _count: PosTerminalCountAggregateOutputType | null
    _min: PosTerminalMinAggregateOutputType | null
    _max: PosTerminalMaxAggregateOutputType | null
  }

  type GetPosTerminalGroupByPayload<T extends PosTerminalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosTerminalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosTerminalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosTerminalGroupByOutputType[P]>
            : GetScalarType<T[P], PosTerminalGroupByOutputType[P]>
        }
      >
    >


  export type PosTerminalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    merchantId?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    payments?: boolean | PosTerminal$paymentsArgs<ExtArgs>
    _count?: boolean | PosTerminalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posTerminal"]>

  export type PosTerminalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    merchantId?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posTerminal"]>

  export type PosTerminalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    merchantId?: boolean
    locationId?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posTerminal"]>

  export type PosTerminalSelectScalar = {
    id?: boolean
    name?: boolean
    provider?: boolean
    merchantId?: boolean
    locationId?: boolean
  }

  export type PosTerminalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "provider" | "merchantId" | "locationId", ExtArgs["result"]["posTerminal"]>
  export type PosTerminalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    payments?: boolean | PosTerminal$paymentsArgs<ExtArgs>
    _count?: boolean | PosTerminalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PosTerminalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type PosTerminalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $PosTerminalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosTerminal"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      provider: string
      merchantId: string | null
      locationId: string
    }, ExtArgs["result"]["posTerminal"]>
    composites: {}
  }

  type PosTerminalGetPayload<S extends boolean | null | undefined | PosTerminalDefaultArgs> = $Result.GetResult<Prisma.$PosTerminalPayload, S>

  type PosTerminalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosTerminalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosTerminalCountAggregateInputType | true
    }

  export interface PosTerminalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosTerminal'], meta: { name: 'PosTerminal' } }
    /**
     * Find zero or one PosTerminal that matches the filter.
     * @param {PosTerminalFindUniqueArgs} args - Arguments to find a PosTerminal
     * @example
     * // Get one PosTerminal
     * const posTerminal = await prisma.posTerminal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosTerminalFindUniqueArgs>(args: SelectSubset<T, PosTerminalFindUniqueArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosTerminal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosTerminalFindUniqueOrThrowArgs} args - Arguments to find a PosTerminal
     * @example
     * // Get one PosTerminal
     * const posTerminal = await prisma.posTerminal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosTerminalFindUniqueOrThrowArgs>(args: SelectSubset<T, PosTerminalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosTerminal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalFindFirstArgs} args - Arguments to find a PosTerminal
     * @example
     * // Get one PosTerminal
     * const posTerminal = await prisma.posTerminal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosTerminalFindFirstArgs>(args?: SelectSubset<T, PosTerminalFindFirstArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosTerminal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalFindFirstOrThrowArgs} args - Arguments to find a PosTerminal
     * @example
     * // Get one PosTerminal
     * const posTerminal = await prisma.posTerminal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosTerminalFindFirstOrThrowArgs>(args?: SelectSubset<T, PosTerminalFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosTerminals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosTerminals
     * const posTerminals = await prisma.posTerminal.findMany()
     * 
     * // Get first 10 PosTerminals
     * const posTerminals = await prisma.posTerminal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posTerminalWithIdOnly = await prisma.posTerminal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosTerminalFindManyArgs>(args?: SelectSubset<T, PosTerminalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosTerminal.
     * @param {PosTerminalCreateArgs} args - Arguments to create a PosTerminal.
     * @example
     * // Create one PosTerminal
     * const PosTerminal = await prisma.posTerminal.create({
     *   data: {
     *     // ... data to create a PosTerminal
     *   }
     * })
     * 
     */
    create<T extends PosTerminalCreateArgs>(args: SelectSubset<T, PosTerminalCreateArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosTerminals.
     * @param {PosTerminalCreateManyArgs} args - Arguments to create many PosTerminals.
     * @example
     * // Create many PosTerminals
     * const posTerminal = await prisma.posTerminal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosTerminalCreateManyArgs>(args?: SelectSubset<T, PosTerminalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosTerminals and returns the data saved in the database.
     * @param {PosTerminalCreateManyAndReturnArgs} args - Arguments to create many PosTerminals.
     * @example
     * // Create many PosTerminals
     * const posTerminal = await prisma.posTerminal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosTerminals and only return the `id`
     * const posTerminalWithIdOnly = await prisma.posTerminal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosTerminalCreateManyAndReturnArgs>(args?: SelectSubset<T, PosTerminalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosTerminal.
     * @param {PosTerminalDeleteArgs} args - Arguments to delete one PosTerminal.
     * @example
     * // Delete one PosTerminal
     * const PosTerminal = await prisma.posTerminal.delete({
     *   where: {
     *     // ... filter to delete one PosTerminal
     *   }
     * })
     * 
     */
    delete<T extends PosTerminalDeleteArgs>(args: SelectSubset<T, PosTerminalDeleteArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosTerminal.
     * @param {PosTerminalUpdateArgs} args - Arguments to update one PosTerminal.
     * @example
     * // Update one PosTerminal
     * const posTerminal = await prisma.posTerminal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosTerminalUpdateArgs>(args: SelectSubset<T, PosTerminalUpdateArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosTerminals.
     * @param {PosTerminalDeleteManyArgs} args - Arguments to filter PosTerminals to delete.
     * @example
     * // Delete a few PosTerminals
     * const { count } = await prisma.posTerminal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosTerminalDeleteManyArgs>(args?: SelectSubset<T, PosTerminalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosTerminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosTerminals
     * const posTerminal = await prisma.posTerminal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosTerminalUpdateManyArgs>(args: SelectSubset<T, PosTerminalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosTerminals and returns the data updated in the database.
     * @param {PosTerminalUpdateManyAndReturnArgs} args - Arguments to update many PosTerminals.
     * @example
     * // Update many PosTerminals
     * const posTerminal = await prisma.posTerminal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosTerminals and only return the `id`
     * const posTerminalWithIdOnly = await prisma.posTerminal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosTerminalUpdateManyAndReturnArgs>(args: SelectSubset<T, PosTerminalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosTerminal.
     * @param {PosTerminalUpsertArgs} args - Arguments to update or create a PosTerminal.
     * @example
     * // Update or create a PosTerminal
     * const posTerminal = await prisma.posTerminal.upsert({
     *   create: {
     *     // ... data to create a PosTerminal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosTerminal we want to update
     *   }
     * })
     */
    upsert<T extends PosTerminalUpsertArgs>(args: SelectSubset<T, PosTerminalUpsertArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosTerminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalCountArgs} args - Arguments to filter PosTerminals to count.
     * @example
     * // Count the number of PosTerminals
     * const count = await prisma.posTerminal.count({
     *   where: {
     *     // ... the filter for the PosTerminals we want to count
     *   }
     * })
    **/
    count<T extends PosTerminalCountArgs>(
      args?: Subset<T, PosTerminalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosTerminalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosTerminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosTerminalAggregateArgs>(args: Subset<T, PosTerminalAggregateArgs>): Prisma.PrismaPromise<GetPosTerminalAggregateType<T>>

    /**
     * Group by PosTerminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosTerminalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosTerminalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosTerminalGroupByArgs['orderBy'] }
        : { orderBy?: PosTerminalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosTerminalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosTerminalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosTerminal model
   */
  readonly fields: PosTerminalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosTerminal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosTerminalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends PosTerminal$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PosTerminal$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosTerminal model
   */
  interface PosTerminalFieldRefs {
    readonly id: FieldRef<"PosTerminal", 'String'>
    readonly name: FieldRef<"PosTerminal", 'String'>
    readonly provider: FieldRef<"PosTerminal", 'String'>
    readonly merchantId: FieldRef<"PosTerminal", 'String'>
    readonly locationId: FieldRef<"PosTerminal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosTerminal findUnique
   */
  export type PosTerminalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * Filter, which PosTerminal to fetch.
     */
    where: PosTerminalWhereUniqueInput
  }

  /**
   * PosTerminal findUniqueOrThrow
   */
  export type PosTerminalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * Filter, which PosTerminal to fetch.
     */
    where: PosTerminalWhereUniqueInput
  }

  /**
   * PosTerminal findFirst
   */
  export type PosTerminalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * Filter, which PosTerminal to fetch.
     */
    where?: PosTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosTerminals to fetch.
     */
    orderBy?: PosTerminalOrderByWithRelationInput | PosTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosTerminals.
     */
    cursor?: PosTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosTerminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosTerminals.
     */
    distinct?: PosTerminalScalarFieldEnum | PosTerminalScalarFieldEnum[]
  }

  /**
   * PosTerminal findFirstOrThrow
   */
  export type PosTerminalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * Filter, which PosTerminal to fetch.
     */
    where?: PosTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosTerminals to fetch.
     */
    orderBy?: PosTerminalOrderByWithRelationInput | PosTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosTerminals.
     */
    cursor?: PosTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosTerminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosTerminals.
     */
    distinct?: PosTerminalScalarFieldEnum | PosTerminalScalarFieldEnum[]
  }

  /**
   * PosTerminal findMany
   */
  export type PosTerminalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * Filter, which PosTerminals to fetch.
     */
    where?: PosTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosTerminals to fetch.
     */
    orderBy?: PosTerminalOrderByWithRelationInput | PosTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosTerminals.
     */
    cursor?: PosTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosTerminals.
     */
    skip?: number
    distinct?: PosTerminalScalarFieldEnum | PosTerminalScalarFieldEnum[]
  }

  /**
   * PosTerminal create
   */
  export type PosTerminalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * The data needed to create a PosTerminal.
     */
    data: XOR<PosTerminalCreateInput, PosTerminalUncheckedCreateInput>
  }

  /**
   * PosTerminal createMany
   */
  export type PosTerminalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosTerminals.
     */
    data: PosTerminalCreateManyInput | PosTerminalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosTerminal createManyAndReturn
   */
  export type PosTerminalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * The data used to create many PosTerminals.
     */
    data: PosTerminalCreateManyInput | PosTerminalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosTerminal update
   */
  export type PosTerminalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * The data needed to update a PosTerminal.
     */
    data: XOR<PosTerminalUpdateInput, PosTerminalUncheckedUpdateInput>
    /**
     * Choose, which PosTerminal to update.
     */
    where: PosTerminalWhereUniqueInput
  }

  /**
   * PosTerminal updateMany
   */
  export type PosTerminalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosTerminals.
     */
    data: XOR<PosTerminalUpdateManyMutationInput, PosTerminalUncheckedUpdateManyInput>
    /**
     * Filter which PosTerminals to update
     */
    where?: PosTerminalWhereInput
    /**
     * Limit how many PosTerminals to update.
     */
    limit?: number
  }

  /**
   * PosTerminal updateManyAndReturn
   */
  export type PosTerminalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * The data used to update PosTerminals.
     */
    data: XOR<PosTerminalUpdateManyMutationInput, PosTerminalUncheckedUpdateManyInput>
    /**
     * Filter which PosTerminals to update
     */
    where?: PosTerminalWhereInput
    /**
     * Limit how many PosTerminals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosTerminal upsert
   */
  export type PosTerminalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * The filter to search for the PosTerminal to update in case it exists.
     */
    where: PosTerminalWhereUniqueInput
    /**
     * In case the PosTerminal found by the `where` argument doesn't exist, create a new PosTerminal with this data.
     */
    create: XOR<PosTerminalCreateInput, PosTerminalUncheckedCreateInput>
    /**
     * In case the PosTerminal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosTerminalUpdateInput, PosTerminalUncheckedUpdateInput>
  }

  /**
   * PosTerminal delete
   */
  export type PosTerminalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    /**
     * Filter which PosTerminal to delete.
     */
    where: PosTerminalWhereUniqueInput
  }

  /**
   * PosTerminal deleteMany
   */
  export type PosTerminalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosTerminals to delete
     */
    where?: PosTerminalWhereInput
    /**
     * Limit how many PosTerminals to delete.
     */
    limit?: number
  }

  /**
   * PosTerminal.payments
   */
  export type PosTerminal$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PosTerminal without action
   */
  export type PosTerminalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
  }


  /**
   * Model Workstation
   */

  export type AggregateWorkstation = {
    _count: WorkstationCountAggregateOutputType | null
    _min: WorkstationMinAggregateOutputType | null
    _max: WorkstationMaxAggregateOutputType | null
  }

  export type WorkstationMinAggregateOutputType = {
    id: string | null
    name: string | null
    locationId: string | null
    type: $Enums.WorkstationType | null
    macAddress: string | null
    allowedIpCidr: string | null
    isActive: boolean | null
  }

  export type WorkstationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    locationId: string | null
    type: $Enums.WorkstationType | null
    macAddress: string | null
    allowedIpCidr: string | null
    isActive: boolean | null
  }

  export type WorkstationCountAggregateOutputType = {
    id: number
    name: number
    locationId: number
    type: number
    macAddress: number
    allowedIpCidr: number
    isActive: number
    _all: number
  }


  export type WorkstationMinAggregateInputType = {
    id?: true
    name?: true
    locationId?: true
    type?: true
    macAddress?: true
    allowedIpCidr?: true
    isActive?: true
  }

  export type WorkstationMaxAggregateInputType = {
    id?: true
    name?: true
    locationId?: true
    type?: true
    macAddress?: true
    allowedIpCidr?: true
    isActive?: true
  }

  export type WorkstationCountAggregateInputType = {
    id?: true
    name?: true
    locationId?: true
    type?: true
    macAddress?: true
    allowedIpCidr?: true
    isActive?: true
    _all?: true
  }

  export type WorkstationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workstation to aggregate.
     */
    where?: WorkstationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workstations to fetch.
     */
    orderBy?: WorkstationOrderByWithRelationInput | WorkstationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkstationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workstations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workstations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workstations
    **/
    _count?: true | WorkstationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkstationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkstationMaxAggregateInputType
  }

  export type GetWorkstationAggregateType<T extends WorkstationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkstation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkstation[P]>
      : GetScalarType<T[P], AggregateWorkstation[P]>
  }




  export type WorkstationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkstationWhereInput
    orderBy?: WorkstationOrderByWithAggregationInput | WorkstationOrderByWithAggregationInput[]
    by: WorkstationScalarFieldEnum[] | WorkstationScalarFieldEnum
    having?: WorkstationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkstationCountAggregateInputType | true
    _min?: WorkstationMinAggregateInputType
    _max?: WorkstationMaxAggregateInputType
  }

  export type WorkstationGroupByOutputType = {
    id: string
    name: string
    locationId: string
    type: $Enums.WorkstationType
    macAddress: string | null
    allowedIpCidr: string | null
    isActive: boolean
    _count: WorkstationCountAggregateOutputType | null
    _min: WorkstationMinAggregateOutputType | null
    _max: WorkstationMaxAggregateOutputType | null
  }

  type GetWorkstationGroupByPayload<T extends WorkstationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkstationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkstationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkstationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkstationGroupByOutputType[P]>
        }
      >
    >


  export type WorkstationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locationId?: boolean
    type?: boolean
    macAddress?: boolean
    allowedIpCidr?: boolean
    isActive?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    sessions?: boolean | Workstation$sessionsArgs<ExtArgs>
    contexts?: boolean | Workstation$contextsArgs<ExtArgs>
    _count?: boolean | WorkstationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workstation"]>

  export type WorkstationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locationId?: boolean
    type?: boolean
    macAddress?: boolean
    allowedIpCidr?: boolean
    isActive?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workstation"]>

  export type WorkstationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locationId?: boolean
    type?: boolean
    macAddress?: boolean
    allowedIpCidr?: boolean
    isActive?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workstation"]>

  export type WorkstationSelectScalar = {
    id?: boolean
    name?: boolean
    locationId?: boolean
    type?: boolean
    macAddress?: boolean
    allowedIpCidr?: boolean
    isActive?: boolean
  }

  export type WorkstationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "locationId" | "type" | "macAddress" | "allowedIpCidr" | "isActive", ExtArgs["result"]["workstation"]>
  export type WorkstationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    sessions?: boolean | Workstation$sessionsArgs<ExtArgs>
    contexts?: boolean | Workstation$contextsArgs<ExtArgs>
    _count?: boolean | WorkstationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkstationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type WorkstationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $WorkstationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workstation"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      sessions: Prisma.$AuthSessionPayload<ExtArgs>[]
      contexts: Prisma.$RequestContextPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      locationId: string
      type: $Enums.WorkstationType
      macAddress: string | null
      allowedIpCidr: string | null
      isActive: boolean
    }, ExtArgs["result"]["workstation"]>
    composites: {}
  }

  type WorkstationGetPayload<S extends boolean | null | undefined | WorkstationDefaultArgs> = $Result.GetResult<Prisma.$WorkstationPayload, S>

  type WorkstationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkstationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkstationCountAggregateInputType | true
    }

  export interface WorkstationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workstation'], meta: { name: 'Workstation' } }
    /**
     * Find zero or one Workstation that matches the filter.
     * @param {WorkstationFindUniqueArgs} args - Arguments to find a Workstation
     * @example
     * // Get one Workstation
     * const workstation = await prisma.workstation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkstationFindUniqueArgs>(args: SelectSubset<T, WorkstationFindUniqueArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workstation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkstationFindUniqueOrThrowArgs} args - Arguments to find a Workstation
     * @example
     * // Get one Workstation
     * const workstation = await prisma.workstation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkstationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkstationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workstation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationFindFirstArgs} args - Arguments to find a Workstation
     * @example
     * // Get one Workstation
     * const workstation = await prisma.workstation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkstationFindFirstArgs>(args?: SelectSubset<T, WorkstationFindFirstArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workstation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationFindFirstOrThrowArgs} args - Arguments to find a Workstation
     * @example
     * // Get one Workstation
     * const workstation = await prisma.workstation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkstationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkstationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workstations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workstations
     * const workstations = await prisma.workstation.findMany()
     * 
     * // Get first 10 Workstations
     * const workstations = await prisma.workstation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workstationWithIdOnly = await prisma.workstation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkstationFindManyArgs>(args?: SelectSubset<T, WorkstationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workstation.
     * @param {WorkstationCreateArgs} args - Arguments to create a Workstation.
     * @example
     * // Create one Workstation
     * const Workstation = await prisma.workstation.create({
     *   data: {
     *     // ... data to create a Workstation
     *   }
     * })
     * 
     */
    create<T extends WorkstationCreateArgs>(args: SelectSubset<T, WorkstationCreateArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workstations.
     * @param {WorkstationCreateManyArgs} args - Arguments to create many Workstations.
     * @example
     * // Create many Workstations
     * const workstation = await prisma.workstation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkstationCreateManyArgs>(args?: SelectSubset<T, WorkstationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workstations and returns the data saved in the database.
     * @param {WorkstationCreateManyAndReturnArgs} args - Arguments to create many Workstations.
     * @example
     * // Create many Workstations
     * const workstation = await prisma.workstation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workstations and only return the `id`
     * const workstationWithIdOnly = await prisma.workstation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkstationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkstationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workstation.
     * @param {WorkstationDeleteArgs} args - Arguments to delete one Workstation.
     * @example
     * // Delete one Workstation
     * const Workstation = await prisma.workstation.delete({
     *   where: {
     *     // ... filter to delete one Workstation
     *   }
     * })
     * 
     */
    delete<T extends WorkstationDeleteArgs>(args: SelectSubset<T, WorkstationDeleteArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workstation.
     * @param {WorkstationUpdateArgs} args - Arguments to update one Workstation.
     * @example
     * // Update one Workstation
     * const workstation = await prisma.workstation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkstationUpdateArgs>(args: SelectSubset<T, WorkstationUpdateArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workstations.
     * @param {WorkstationDeleteManyArgs} args - Arguments to filter Workstations to delete.
     * @example
     * // Delete a few Workstations
     * const { count } = await prisma.workstation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkstationDeleteManyArgs>(args?: SelectSubset<T, WorkstationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workstations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workstations
     * const workstation = await prisma.workstation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkstationUpdateManyArgs>(args: SelectSubset<T, WorkstationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workstations and returns the data updated in the database.
     * @param {WorkstationUpdateManyAndReturnArgs} args - Arguments to update many Workstations.
     * @example
     * // Update many Workstations
     * const workstation = await prisma.workstation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workstations and only return the `id`
     * const workstationWithIdOnly = await prisma.workstation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkstationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkstationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workstation.
     * @param {WorkstationUpsertArgs} args - Arguments to update or create a Workstation.
     * @example
     * // Update or create a Workstation
     * const workstation = await prisma.workstation.upsert({
     *   create: {
     *     // ... data to create a Workstation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workstation we want to update
     *   }
     * })
     */
    upsert<T extends WorkstationUpsertArgs>(args: SelectSubset<T, WorkstationUpsertArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workstations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationCountArgs} args - Arguments to filter Workstations to count.
     * @example
     * // Count the number of Workstations
     * const count = await prisma.workstation.count({
     *   where: {
     *     // ... the filter for the Workstations we want to count
     *   }
     * })
    **/
    count<T extends WorkstationCountArgs>(
      args?: Subset<T, WorkstationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkstationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workstation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkstationAggregateArgs>(args: Subset<T, WorkstationAggregateArgs>): Prisma.PrismaPromise<GetWorkstationAggregateType<T>>

    /**
     * Group by Workstation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkstationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkstationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkstationGroupByArgs['orderBy'] }
        : { orderBy?: WorkstationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkstationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkstationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workstation model
   */
  readonly fields: WorkstationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workstation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkstationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Workstation$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Workstation$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contexts<T extends Workstation$contextsArgs<ExtArgs> = {}>(args?: Subset<T, Workstation$contextsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workstation model
   */
  interface WorkstationFieldRefs {
    readonly id: FieldRef<"Workstation", 'String'>
    readonly name: FieldRef<"Workstation", 'String'>
    readonly locationId: FieldRef<"Workstation", 'String'>
    readonly type: FieldRef<"Workstation", 'WorkstationType'>
    readonly macAddress: FieldRef<"Workstation", 'String'>
    readonly allowedIpCidr: FieldRef<"Workstation", 'String'>
    readonly isActive: FieldRef<"Workstation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Workstation findUnique
   */
  export type WorkstationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * Filter, which Workstation to fetch.
     */
    where: WorkstationWhereUniqueInput
  }

  /**
   * Workstation findUniqueOrThrow
   */
  export type WorkstationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * Filter, which Workstation to fetch.
     */
    where: WorkstationWhereUniqueInput
  }

  /**
   * Workstation findFirst
   */
  export type WorkstationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * Filter, which Workstation to fetch.
     */
    where?: WorkstationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workstations to fetch.
     */
    orderBy?: WorkstationOrderByWithRelationInput | WorkstationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workstations.
     */
    cursor?: WorkstationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workstations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workstations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workstations.
     */
    distinct?: WorkstationScalarFieldEnum | WorkstationScalarFieldEnum[]
  }

  /**
   * Workstation findFirstOrThrow
   */
  export type WorkstationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * Filter, which Workstation to fetch.
     */
    where?: WorkstationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workstations to fetch.
     */
    orderBy?: WorkstationOrderByWithRelationInput | WorkstationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workstations.
     */
    cursor?: WorkstationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workstations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workstations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workstations.
     */
    distinct?: WorkstationScalarFieldEnum | WorkstationScalarFieldEnum[]
  }

  /**
   * Workstation findMany
   */
  export type WorkstationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * Filter, which Workstations to fetch.
     */
    where?: WorkstationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workstations to fetch.
     */
    orderBy?: WorkstationOrderByWithRelationInput | WorkstationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workstations.
     */
    cursor?: WorkstationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workstations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workstations.
     */
    skip?: number
    distinct?: WorkstationScalarFieldEnum | WorkstationScalarFieldEnum[]
  }

  /**
   * Workstation create
   */
  export type WorkstationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * The data needed to create a Workstation.
     */
    data: XOR<WorkstationCreateInput, WorkstationUncheckedCreateInput>
  }

  /**
   * Workstation createMany
   */
  export type WorkstationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workstations.
     */
    data: WorkstationCreateManyInput | WorkstationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workstation createManyAndReturn
   */
  export type WorkstationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * The data used to create many Workstations.
     */
    data: WorkstationCreateManyInput | WorkstationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workstation update
   */
  export type WorkstationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * The data needed to update a Workstation.
     */
    data: XOR<WorkstationUpdateInput, WorkstationUncheckedUpdateInput>
    /**
     * Choose, which Workstation to update.
     */
    where: WorkstationWhereUniqueInput
  }

  /**
   * Workstation updateMany
   */
  export type WorkstationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workstations.
     */
    data: XOR<WorkstationUpdateManyMutationInput, WorkstationUncheckedUpdateManyInput>
    /**
     * Filter which Workstations to update
     */
    where?: WorkstationWhereInput
    /**
     * Limit how many Workstations to update.
     */
    limit?: number
  }

  /**
   * Workstation updateManyAndReturn
   */
  export type WorkstationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * The data used to update Workstations.
     */
    data: XOR<WorkstationUpdateManyMutationInput, WorkstationUncheckedUpdateManyInput>
    /**
     * Filter which Workstations to update
     */
    where?: WorkstationWhereInput
    /**
     * Limit how many Workstations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workstation upsert
   */
  export type WorkstationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * The filter to search for the Workstation to update in case it exists.
     */
    where: WorkstationWhereUniqueInput
    /**
     * In case the Workstation found by the `where` argument doesn't exist, create a new Workstation with this data.
     */
    create: XOR<WorkstationCreateInput, WorkstationUncheckedCreateInput>
    /**
     * In case the Workstation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkstationUpdateInput, WorkstationUncheckedUpdateInput>
  }

  /**
   * Workstation delete
   */
  export type WorkstationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    /**
     * Filter which Workstation to delete.
     */
    where: WorkstationWhereUniqueInput
  }

  /**
   * Workstation deleteMany
   */
  export type WorkstationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workstations to delete
     */
    where?: WorkstationWhereInput
    /**
     * Limit how many Workstations to delete.
     */
    limit?: number
  }

  /**
   * Workstation.sessions
   */
  export type Workstation$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    cursor?: AuthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * Workstation.contexts
   */
  export type Workstation$contextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    where?: RequestContextWhereInput
    orderBy?: RequestContextOrderByWithRelationInput | RequestContextOrderByWithRelationInput[]
    cursor?: RequestContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestContextScalarFieldEnum | RequestContextScalarFieldEnum[]
  }

  /**
   * Workstation without action
   */
  export type WorkstationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    mrn: string | null
    nationalId: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    sex: $Enums.Sex | null
    maritalStatus: $Enums.MaritalStatus | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    region: string | null
    country: string | null
    bloodType: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    mrn: string | null
    nationalId: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    sex: $Enums.Sex | null
    maritalStatus: $Enums.MaritalStatus | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    region: string | null
    country: string | null
    bloodType: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    mrn: number
    nationalId: number
    firstName: number
    lastName: number
    dob: number
    sex: number
    maritalStatus: number
    phone: number
    email: number
    address: number
    city: number
    region: number
    country: number
    bloodType: number
    emergencyContactName: number
    emergencyContactPhone: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    mrn?: true
    nationalId?: true
    firstName?: true
    lastName?: true
    dob?: true
    sex?: true
    maritalStatus?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    region?: true
    country?: true
    bloodType?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    mrn?: true
    nationalId?: true
    firstName?: true
    lastName?: true
    dob?: true
    sex?: true
    maritalStatus?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    region?: true
    country?: true
    bloodType?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    mrn?: true
    nationalId?: true
    firstName?: true
    lastName?: true
    dob?: true
    sex?: true
    maritalStatus?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    region?: true
    country?: true
    bloodType?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    mrn: string
    nationalId: string | null
    firstName: string
    lastName: string
    dob: Date | null
    sex: $Enums.Sex | null
    maritalStatus: $Enums.MaritalStatus | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    region: string | null
    country: string | null
    bloodType: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrn?: boolean
    nationalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    sex?: boolean
    maritalStatus?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    bloodType?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Patient$createdByArgs<ExtArgs>
    preclinics?: boolean | Patient$preclinicsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    problems?: boolean | Patient$problemsArgs<ExtArgs>
    medications?: boolean | Patient$medicationsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    labOrders?: boolean | Patient$labOrdersArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrn?: boolean
    nationalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    sex?: boolean
    maritalStatus?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    bloodType?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Patient$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrn?: boolean
    nationalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    sex?: boolean
    maritalStatus?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    bloodType?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Patient$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    mrn?: boolean
    nationalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    sex?: boolean
    maritalStatus?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    bloodType?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mrn" | "nationalId" | "firstName" | "lastName" | "dob" | "sex" | "maritalStatus" | "phone" | "email" | "address" | "city" | "region" | "country" | "bloodType" | "emergencyContactName" | "emergencyContactPhone" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Patient$createdByArgs<ExtArgs>
    preclinics?: boolean | Patient$preclinicsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    problems?: boolean | Patient$problemsArgs<ExtArgs>
    medications?: boolean | Patient$medicationsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    labOrders?: boolean | Patient$labOrdersArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Patient$createdByArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Patient$createdByArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      preclinics: Prisma.$PreclinicPayload<ExtArgs>[]
      allergies: Prisma.$AllergyPayload<ExtArgs>[]
      problems: Prisma.$ProblemPayload<ExtArgs>[]
      medications: Prisma.$MedicationPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mrn: string
      nationalId: string | null
      firstName: string
      lastName: string
      dob: Date | null
      sex: $Enums.Sex | null
      maritalStatus: $Enums.MaritalStatus | null
      phone: string | null
      email: string | null
      address: string | null
      city: string | null
      region: string | null
      country: string | null
      bloodType: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Patient$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Patient$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preclinics<T extends Patient$preclinicsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$preclinicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allergies<T extends Patient$allergiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$allergiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    problems<T extends Patient$problemsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$problemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medications<T extends Patient$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrders<T extends Patient$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly mrn: FieldRef<"Patient", 'String'>
    readonly nationalId: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly sex: FieldRef<"Patient", 'Sex'>
    readonly maritalStatus: FieldRef<"Patient", 'MaritalStatus'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly city: FieldRef<"Patient", 'String'>
    readonly region: FieldRef<"Patient", 'String'>
    readonly country: FieldRef<"Patient", 'String'>
    readonly bloodType: FieldRef<"Patient", 'String'>
    readonly emergencyContactName: FieldRef<"Patient", 'String'>
    readonly emergencyContactPhone: FieldRef<"Patient", 'String'>
    readonly createdById: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.createdBy
   */
  export type Patient$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Patient.preclinics
   */
  export type Patient$preclinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    where?: PreclinicWhereInput
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    cursor?: PreclinicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreclinicScalarFieldEnum | PreclinicScalarFieldEnum[]
  }

  /**
   * Patient.allergies
   */
  export type Patient$allergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    cursor?: AllergyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Patient.problems
   */
  export type Patient$problemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    where?: ProblemWhereInput
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    cursor?: ProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Patient.medications
   */
  export type Patient$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.labOrders
   */
  export type Patient$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model AuthSession
   */

  export type AggregateAuthSession = {
    _count: AuthSessionCountAggregateOutputType | null
    _avg: AuthSessionAvgAggregateOutputType | null
    _sum: AuthSessionSumAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  export type AuthSessionAvgAggregateOutputType = {
    geoLat: Decimal | null
    geoLon: Decimal | null
  }

  export type AuthSessionSumAggregateOutputType = {
    geoLat: Decimal | null
    geoLon: Decimal | null
  }

  export type AuthSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startedAt: Date | null
    endedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    workstationId: string | null
    geoCountry: string | null
    geoRegion: string | null
    geoCity: string | null
    geoLat: Decimal | null
    geoLon: Decimal | null
    mfaPassed: boolean | null
  }

  export type AuthSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startedAt: Date | null
    endedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    workstationId: string | null
    geoCountry: string | null
    geoRegion: string | null
    geoCity: string | null
    geoLat: Decimal | null
    geoLon: Decimal | null
    mfaPassed: boolean | null
  }

  export type AuthSessionCountAggregateOutputType = {
    id: number
    userId: number
    startedAt: number
    endedAt: number
    ipAddress: number
    userAgent: number
    deviceFingerprint: number
    workstationId: number
    geoCountry: number
    geoRegion: number
    geoCity: number
    geoLat: number
    geoLon: number
    mfaPassed: number
    _all: number
  }


  export type AuthSessionAvgAggregateInputType = {
    geoLat?: true
    geoLon?: true
  }

  export type AuthSessionSumAggregateInputType = {
    geoLat?: true
    geoLon?: true
  }

  export type AuthSessionMinAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    workstationId?: true
    geoCountry?: true
    geoRegion?: true
    geoCity?: true
    geoLat?: true
    geoLon?: true
    mfaPassed?: true
  }

  export type AuthSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    workstationId?: true
    geoCountry?: true
    geoRegion?: true
    geoCity?: true
    geoLat?: true
    geoLon?: true
    mfaPassed?: true
  }

  export type AuthSessionCountAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    workstationId?: true
    geoCountry?: true
    geoRegion?: true
    geoCity?: true
    geoLat?: true
    geoLon?: true
    mfaPassed?: true
    _all?: true
  }

  export type AuthSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSession to aggregate.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthSessions
    **/
    _count?: true | AuthSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthSessionMaxAggregateInputType
  }

  export type GetAuthSessionAggregateType<T extends AuthSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthSession[P]>
      : GetScalarType<T[P], AggregateAuthSession[P]>
  }




  export type AuthSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithAggregationInput | AuthSessionOrderByWithAggregationInput[]
    by: AuthSessionScalarFieldEnum[] | AuthSessionScalarFieldEnum
    having?: AuthSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthSessionCountAggregateInputType | true
    _avg?: AuthSessionAvgAggregateInputType
    _sum?: AuthSessionSumAggregateInputType
    _min?: AuthSessionMinAggregateInputType
    _max?: AuthSessionMaxAggregateInputType
  }

  export type AuthSessionGroupByOutputType = {
    id: string
    userId: string
    startedAt: Date
    endedAt: Date | null
    ipAddress: string
    userAgent: string
    deviceFingerprint: string | null
    workstationId: string | null
    geoCountry: string | null
    geoRegion: string | null
    geoCity: string | null
    geoLat: Decimal | null
    geoLon: Decimal | null
    mfaPassed: boolean
    _count: AuthSessionCountAggregateOutputType | null
    _avg: AuthSessionAvgAggregateOutputType | null
    _sum: AuthSessionSumAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  type GetAuthSessionGroupByPayload<T extends AuthSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
        }
      >
    >


  export type AuthSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    mfaPassed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workstation?: boolean | AuthSession$workstationArgs<ExtArgs>
    contexts?: boolean | AuthSession$contextsArgs<ExtArgs>
    _count?: boolean | AuthSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    mfaPassed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workstation?: boolean | AuthSession$workstationArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    mfaPassed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workstation?: boolean | AuthSession$workstationArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    mfaPassed?: boolean
  }

  export type AuthSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startedAt" | "endedAt" | "ipAddress" | "userAgent" | "deviceFingerprint" | "workstationId" | "geoCountry" | "geoRegion" | "geoCity" | "geoLat" | "geoLon" | "mfaPassed", ExtArgs["result"]["authSession"]>
  export type AuthSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workstation?: boolean | AuthSession$workstationArgs<ExtArgs>
    contexts?: boolean | AuthSession$contextsArgs<ExtArgs>
    _count?: boolean | AuthSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workstation?: boolean | AuthSession$workstationArgs<ExtArgs>
  }
  export type AuthSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workstation?: boolean | AuthSession$workstationArgs<ExtArgs>
  }

  export type $AuthSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workstation: Prisma.$WorkstationPayload<ExtArgs> | null
      contexts: Prisma.$RequestContextPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startedAt: Date
      endedAt: Date | null
      ipAddress: string
      userAgent: string
      deviceFingerprint: string | null
      workstationId: string | null
      geoCountry: string | null
      geoRegion: string | null
      geoCity: string | null
      geoLat: Prisma.Decimal | null
      geoLon: Prisma.Decimal | null
      mfaPassed: boolean
    }, ExtArgs["result"]["authSession"]>
    composites: {}
  }

  type AuthSessionGetPayload<S extends boolean | null | undefined | AuthSessionDefaultArgs> = $Result.GetResult<Prisma.$AuthSessionPayload, S>

  type AuthSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthSessionCountAggregateInputType | true
    }

  export interface AuthSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthSession'], meta: { name: 'AuthSession' } }
    /**
     * Find zero or one AuthSession that matches the filter.
     * @param {AuthSessionFindUniqueArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthSessionFindUniqueArgs>(args: SelectSubset<T, AuthSessionFindUniqueArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthSessionFindUniqueOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthSessionFindFirstArgs>(args?: SelectSubset<T, AuthSessionFindFirstArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthSessions
     * const authSessions = await prisma.authSession.findMany()
     * 
     * // Get first 10 AuthSessions
     * const authSessions = await prisma.authSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authSessionWithIdOnly = await prisma.authSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthSessionFindManyArgs>(args?: SelectSubset<T, AuthSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthSession.
     * @param {AuthSessionCreateArgs} args - Arguments to create a AuthSession.
     * @example
     * // Create one AuthSession
     * const AuthSession = await prisma.authSession.create({
     *   data: {
     *     // ... data to create a AuthSession
     *   }
     * })
     * 
     */
    create<T extends AuthSessionCreateArgs>(args: SelectSubset<T, AuthSessionCreateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthSessions.
     * @param {AuthSessionCreateManyArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthSessionCreateManyArgs>(args?: SelectSubset<T, AuthSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthSessions and returns the data saved in the database.
     * @param {AuthSessionCreateManyAndReturnArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthSession.
     * @param {AuthSessionDeleteArgs} args - Arguments to delete one AuthSession.
     * @example
     * // Delete one AuthSession
     * const AuthSession = await prisma.authSession.delete({
     *   where: {
     *     // ... filter to delete one AuthSession
     *   }
     * })
     * 
     */
    delete<T extends AuthSessionDeleteArgs>(args: SelectSubset<T, AuthSessionDeleteArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthSession.
     * @param {AuthSessionUpdateArgs} args - Arguments to update one AuthSession.
     * @example
     * // Update one AuthSession
     * const authSession = await prisma.authSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthSessionUpdateArgs>(args: SelectSubset<T, AuthSessionUpdateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthSessions.
     * @param {AuthSessionDeleteManyArgs} args - Arguments to filter AuthSessions to delete.
     * @example
     * // Delete a few AuthSessions
     * const { count } = await prisma.authSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthSessionDeleteManyArgs>(args?: SelectSubset<T, AuthSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthSessionUpdateManyArgs>(args: SelectSubset<T, AuthSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions and returns the data updated in the database.
     * @param {AuthSessionUpdateManyAndReturnArgs} args - Arguments to update many AuthSessions.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthSession.
     * @param {AuthSessionUpsertArgs} args - Arguments to update or create a AuthSession.
     * @example
     * // Update or create a AuthSession
     * const authSession = await prisma.authSession.upsert({
     *   create: {
     *     // ... data to create a AuthSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthSession we want to update
     *   }
     * })
     */
    upsert<T extends AuthSessionUpsertArgs>(args: SelectSubset<T, AuthSessionUpsertArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionCountArgs} args - Arguments to filter AuthSessions to count.
     * @example
     * // Count the number of AuthSessions
     * const count = await prisma.authSession.count({
     *   where: {
     *     // ... the filter for the AuthSessions we want to count
     *   }
     * })
    **/
    count<T extends AuthSessionCountArgs>(
      args?: Subset<T, AuthSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthSessionAggregateArgs>(args: Subset<T, AuthSessionAggregateArgs>): Prisma.PrismaPromise<GetAuthSessionAggregateType<T>>

    /**
     * Group by AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthSessionGroupByArgs['orderBy'] }
        : { orderBy?: AuthSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthSession model
   */
  readonly fields: AuthSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workstation<T extends AuthSession$workstationArgs<ExtArgs> = {}>(args?: Subset<T, AuthSession$workstationArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contexts<T extends AuthSession$contextsArgs<ExtArgs> = {}>(args?: Subset<T, AuthSession$contextsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthSession model
   */
  interface AuthSessionFieldRefs {
    readonly id: FieldRef<"AuthSession", 'String'>
    readonly userId: FieldRef<"AuthSession", 'String'>
    readonly startedAt: FieldRef<"AuthSession", 'DateTime'>
    readonly endedAt: FieldRef<"AuthSession", 'DateTime'>
    readonly ipAddress: FieldRef<"AuthSession", 'String'>
    readonly userAgent: FieldRef<"AuthSession", 'String'>
    readonly deviceFingerprint: FieldRef<"AuthSession", 'String'>
    readonly workstationId: FieldRef<"AuthSession", 'String'>
    readonly geoCountry: FieldRef<"AuthSession", 'String'>
    readonly geoRegion: FieldRef<"AuthSession", 'String'>
    readonly geoCity: FieldRef<"AuthSession", 'String'>
    readonly geoLat: FieldRef<"AuthSession", 'Decimal'>
    readonly geoLon: FieldRef<"AuthSession", 'Decimal'>
    readonly mfaPassed: FieldRef<"AuthSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AuthSession findUnique
   */
  export type AuthSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findUniqueOrThrow
   */
  export type AuthSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findFirst
   */
  export type AuthSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findFirstOrThrow
   */
  export type AuthSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findMany
   */
  export type AuthSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSessions to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession create
   */
  export type AuthSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthSession.
     */
    data: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
  }

  /**
   * AuthSession createMany
   */
  export type AuthSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthSession createManyAndReturn
   */
  export type AuthSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession update
   */
  export type AuthSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthSession.
     */
    data: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
    /**
     * Choose, which AuthSession to update.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession updateMany
   */
  export type AuthSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
  }

  /**
   * AuthSession updateManyAndReturn
   */
  export type AuthSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession upsert
   */
  export type AuthSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthSession to update in case it exists.
     */
    where: AuthSessionWhereUniqueInput
    /**
     * In case the AuthSession found by the `where` argument doesn't exist, create a new AuthSession with this data.
     */
    create: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
    /**
     * In case the AuthSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
  }

  /**
   * AuthSession delete
   */
  export type AuthSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter which AuthSession to delete.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession deleteMany
   */
  export type AuthSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSessions to delete
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to delete.
     */
    limit?: number
  }

  /**
   * AuthSession.workstation
   */
  export type AuthSession$workstationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    where?: WorkstationWhereInput
  }

  /**
   * AuthSession.contexts
   */
  export type AuthSession$contextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    where?: RequestContextWhereInput
    orderBy?: RequestContextOrderByWithRelationInput | RequestContextOrderByWithRelationInput[]
    cursor?: RequestContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestContextScalarFieldEnum | RequestContextScalarFieldEnum[]
  }

  /**
   * AuthSession without action
   */
  export type AuthSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
  }


  /**
   * Model RequestContext
   */

  export type AggregateRequestContext = {
    _count: RequestContextCountAggregateOutputType | null
    _avg: RequestContextAvgAggregateOutputType | null
    _sum: RequestContextSumAggregateOutputType | null
    _min: RequestContextMinAggregateOutputType | null
    _max: RequestContextMaxAggregateOutputType | null
  }

  export type RequestContextAvgAggregateOutputType = {
    geoLat: Decimal | null
    geoLon: Decimal | null
  }

  export type RequestContextSumAggregateOutputType = {
    geoLat: Decimal | null
    geoLon: Decimal | null
  }

  export type RequestContextMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    occurredAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    workstationId: string | null
    geoCountry: string | null
    geoRegion: string | null
    geoCity: string | null
    geoLat: Decimal | null
    geoLon: Decimal | null
  }

  export type RequestContextMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    occurredAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    workstationId: string | null
    geoCountry: string | null
    geoRegion: string | null
    geoCity: string | null
    geoLat: Decimal | null
    geoLon: Decimal | null
  }

  export type RequestContextCountAggregateOutputType = {
    id: number
    sessionId: number
    occurredAt: number
    ipAddress: number
    userAgent: number
    deviceFingerprint: number
    workstationId: number
    geoCountry: number
    geoRegion: number
    geoCity: number
    geoLat: number
    geoLon: number
    _all: number
  }


  export type RequestContextAvgAggregateInputType = {
    geoLat?: true
    geoLon?: true
  }

  export type RequestContextSumAggregateInputType = {
    geoLat?: true
    geoLon?: true
  }

  export type RequestContextMinAggregateInputType = {
    id?: true
    sessionId?: true
    occurredAt?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    workstationId?: true
    geoCountry?: true
    geoRegion?: true
    geoCity?: true
    geoLat?: true
    geoLon?: true
  }

  export type RequestContextMaxAggregateInputType = {
    id?: true
    sessionId?: true
    occurredAt?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    workstationId?: true
    geoCountry?: true
    geoRegion?: true
    geoCity?: true
    geoLat?: true
    geoLon?: true
  }

  export type RequestContextCountAggregateInputType = {
    id?: true
    sessionId?: true
    occurredAt?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    workstationId?: true
    geoCountry?: true
    geoRegion?: true
    geoCity?: true
    geoLat?: true
    geoLon?: true
    _all?: true
  }

  export type RequestContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestContext to aggregate.
     */
    where?: RequestContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestContexts to fetch.
     */
    orderBy?: RequestContextOrderByWithRelationInput | RequestContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestContexts
    **/
    _count?: true | RequestContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestContextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestContextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestContextMaxAggregateInputType
  }

  export type GetRequestContextAggregateType<T extends RequestContextAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestContext[P]>
      : GetScalarType<T[P], AggregateRequestContext[P]>
  }




  export type RequestContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestContextWhereInput
    orderBy?: RequestContextOrderByWithAggregationInput | RequestContextOrderByWithAggregationInput[]
    by: RequestContextScalarFieldEnum[] | RequestContextScalarFieldEnum
    having?: RequestContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestContextCountAggregateInputType | true
    _avg?: RequestContextAvgAggregateInputType
    _sum?: RequestContextSumAggregateInputType
    _min?: RequestContextMinAggregateInputType
    _max?: RequestContextMaxAggregateInputType
  }

  export type RequestContextGroupByOutputType = {
    id: string
    sessionId: string
    occurredAt: Date
    ipAddress: string
    userAgent: string
    deviceFingerprint: string | null
    workstationId: string | null
    geoCountry: string | null
    geoRegion: string | null
    geoCity: string | null
    geoLat: Decimal | null
    geoLon: Decimal | null
    _count: RequestContextCountAggregateOutputType | null
    _avg: RequestContextAvgAggregateOutputType | null
    _sum: RequestContextSumAggregateOutputType | null
    _min: RequestContextMinAggregateOutputType | null
    _max: RequestContextMaxAggregateOutputType | null
  }

  type GetRequestContextGroupByPayload<T extends RequestContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestContextGroupByOutputType[P]>
            : GetScalarType<T[P], RequestContextGroupByOutputType[P]>
        }
      >
    >


  export type RequestContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    occurredAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    session?: boolean | AuthSessionDefaultArgs<ExtArgs>
    workstation?: boolean | RequestContext$workstationArgs<ExtArgs>
    invoices?: boolean | RequestContext$invoicesArgs<ExtArgs>
    payments?: boolean | RequestContext$paymentsArgs<ExtArgs>
    cashMoves?: boolean | RequestContext$cashMovesArgs<ExtArgs>
    preclinics?: boolean | RequestContext$preclinicsArgs<ExtArgs>
    labOrders?: boolean | RequestContext$labOrdersArgs<ExtArgs>
    labOrderTests?: boolean | RequestContext$labOrderTestsArgs<ExtArgs>
    activities?: boolean | RequestContext$activitiesArgs<ExtArgs>
    _count?: boolean | RequestContextCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestContext"]>

  export type RequestContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    occurredAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    session?: boolean | AuthSessionDefaultArgs<ExtArgs>
    workstation?: boolean | RequestContext$workstationArgs<ExtArgs>
  }, ExtArgs["result"]["requestContext"]>

  export type RequestContextSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    occurredAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
    session?: boolean | AuthSessionDefaultArgs<ExtArgs>
    workstation?: boolean | RequestContext$workstationArgs<ExtArgs>
  }, ExtArgs["result"]["requestContext"]>

  export type RequestContextSelectScalar = {
    id?: boolean
    sessionId?: boolean
    occurredAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    workstationId?: boolean
    geoCountry?: boolean
    geoRegion?: boolean
    geoCity?: boolean
    geoLat?: boolean
    geoLon?: boolean
  }

  export type RequestContextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "occurredAt" | "ipAddress" | "userAgent" | "deviceFingerprint" | "workstationId" | "geoCountry" | "geoRegion" | "geoCity" | "geoLat" | "geoLon", ExtArgs["result"]["requestContext"]>
  export type RequestContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AuthSessionDefaultArgs<ExtArgs>
    workstation?: boolean | RequestContext$workstationArgs<ExtArgs>
    invoices?: boolean | RequestContext$invoicesArgs<ExtArgs>
    payments?: boolean | RequestContext$paymentsArgs<ExtArgs>
    cashMoves?: boolean | RequestContext$cashMovesArgs<ExtArgs>
    preclinics?: boolean | RequestContext$preclinicsArgs<ExtArgs>
    labOrders?: boolean | RequestContext$labOrdersArgs<ExtArgs>
    labOrderTests?: boolean | RequestContext$labOrderTestsArgs<ExtArgs>
    activities?: boolean | RequestContext$activitiesArgs<ExtArgs>
    _count?: boolean | RequestContextCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestContextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AuthSessionDefaultArgs<ExtArgs>
    workstation?: boolean | RequestContext$workstationArgs<ExtArgs>
  }
  export type RequestContextIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AuthSessionDefaultArgs<ExtArgs>
    workstation?: boolean | RequestContext$workstationArgs<ExtArgs>
  }

  export type $RequestContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestContext"
    objects: {
      session: Prisma.$AuthSessionPayload<ExtArgs>
      workstation: Prisma.$WorkstationPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      cashMoves: Prisma.$CashMovementPayload<ExtArgs>[]
      preclinics: Prisma.$PreclinicPayload<ExtArgs>[]
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
      labOrderTests: Prisma.$LabOrderTestPayload<ExtArgs>[]
      activities: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      occurredAt: Date
      ipAddress: string
      userAgent: string
      deviceFingerprint: string | null
      workstationId: string | null
      geoCountry: string | null
      geoRegion: string | null
      geoCity: string | null
      geoLat: Prisma.Decimal | null
      geoLon: Prisma.Decimal | null
    }, ExtArgs["result"]["requestContext"]>
    composites: {}
  }

  type RequestContextGetPayload<S extends boolean | null | undefined | RequestContextDefaultArgs> = $Result.GetResult<Prisma.$RequestContextPayload, S>

  type RequestContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestContextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestContextCountAggregateInputType | true
    }

  export interface RequestContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestContext'], meta: { name: 'RequestContext' } }
    /**
     * Find zero or one RequestContext that matches the filter.
     * @param {RequestContextFindUniqueArgs} args - Arguments to find a RequestContext
     * @example
     * // Get one RequestContext
     * const requestContext = await prisma.requestContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestContextFindUniqueArgs>(args: SelectSubset<T, RequestContextFindUniqueArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestContext that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestContextFindUniqueOrThrowArgs} args - Arguments to find a RequestContext
     * @example
     * // Get one RequestContext
     * const requestContext = await prisma.requestContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestContextFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextFindFirstArgs} args - Arguments to find a RequestContext
     * @example
     * // Get one RequestContext
     * const requestContext = await prisma.requestContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestContextFindFirstArgs>(args?: SelectSubset<T, RequestContextFindFirstArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextFindFirstOrThrowArgs} args - Arguments to find a RequestContext
     * @example
     * // Get one RequestContext
     * const requestContext = await prisma.requestContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestContextFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestContexts
     * const requestContexts = await prisma.requestContext.findMany()
     * 
     * // Get first 10 RequestContexts
     * const requestContexts = await prisma.requestContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestContextWithIdOnly = await prisma.requestContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestContextFindManyArgs>(args?: SelectSubset<T, RequestContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestContext.
     * @param {RequestContextCreateArgs} args - Arguments to create a RequestContext.
     * @example
     * // Create one RequestContext
     * const RequestContext = await prisma.requestContext.create({
     *   data: {
     *     // ... data to create a RequestContext
     *   }
     * })
     * 
     */
    create<T extends RequestContextCreateArgs>(args: SelectSubset<T, RequestContextCreateArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestContexts.
     * @param {RequestContextCreateManyArgs} args - Arguments to create many RequestContexts.
     * @example
     * // Create many RequestContexts
     * const requestContext = await prisma.requestContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestContextCreateManyArgs>(args?: SelectSubset<T, RequestContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestContexts and returns the data saved in the database.
     * @param {RequestContextCreateManyAndReturnArgs} args - Arguments to create many RequestContexts.
     * @example
     * // Create many RequestContexts
     * const requestContext = await prisma.requestContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestContexts and only return the `id`
     * const requestContextWithIdOnly = await prisma.requestContext.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestContextCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestContext.
     * @param {RequestContextDeleteArgs} args - Arguments to delete one RequestContext.
     * @example
     * // Delete one RequestContext
     * const RequestContext = await prisma.requestContext.delete({
     *   where: {
     *     // ... filter to delete one RequestContext
     *   }
     * })
     * 
     */
    delete<T extends RequestContextDeleteArgs>(args: SelectSubset<T, RequestContextDeleteArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestContext.
     * @param {RequestContextUpdateArgs} args - Arguments to update one RequestContext.
     * @example
     * // Update one RequestContext
     * const requestContext = await prisma.requestContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestContextUpdateArgs>(args: SelectSubset<T, RequestContextUpdateArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestContexts.
     * @param {RequestContextDeleteManyArgs} args - Arguments to filter RequestContexts to delete.
     * @example
     * // Delete a few RequestContexts
     * const { count } = await prisma.requestContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestContextDeleteManyArgs>(args?: SelectSubset<T, RequestContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestContexts
     * const requestContext = await prisma.requestContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestContextUpdateManyArgs>(args: SelectSubset<T, RequestContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestContexts and returns the data updated in the database.
     * @param {RequestContextUpdateManyAndReturnArgs} args - Arguments to update many RequestContexts.
     * @example
     * // Update many RequestContexts
     * const requestContext = await prisma.requestContext.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestContexts and only return the `id`
     * const requestContextWithIdOnly = await prisma.requestContext.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestContextUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestContextUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestContext.
     * @param {RequestContextUpsertArgs} args - Arguments to update or create a RequestContext.
     * @example
     * // Update or create a RequestContext
     * const requestContext = await prisma.requestContext.upsert({
     *   create: {
     *     // ... data to create a RequestContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestContext we want to update
     *   }
     * })
     */
    upsert<T extends RequestContextUpsertArgs>(args: SelectSubset<T, RequestContextUpsertArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextCountArgs} args - Arguments to filter RequestContexts to count.
     * @example
     * // Count the number of RequestContexts
     * const count = await prisma.requestContext.count({
     *   where: {
     *     // ... the filter for the RequestContexts we want to count
     *   }
     * })
    **/
    count<T extends RequestContextCountArgs>(
      args?: Subset<T, RequestContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestContextAggregateArgs>(args: Subset<T, RequestContextAggregateArgs>): Prisma.PrismaPromise<GetRequestContextAggregateType<T>>

    /**
     * Group by RequestContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestContextGroupByArgs['orderBy'] }
        : { orderBy?: RequestContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestContext model
   */
  readonly fields: RequestContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AuthSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthSessionDefaultArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workstation<T extends RequestContext$workstationArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$workstationArgs<ExtArgs>>): Prisma__WorkstationClient<$Result.GetResult<Prisma.$WorkstationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends RequestContext$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends RequestContext$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashMoves<T extends RequestContext$cashMovesArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$cashMovesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preclinics<T extends RequestContext$preclinicsArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$preclinicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrders<T extends RequestContext$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrderTests<T extends RequestContext$labOrderTestsArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$labOrderTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends RequestContext$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, RequestContext$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestContext model
   */
  interface RequestContextFieldRefs {
    readonly id: FieldRef<"RequestContext", 'String'>
    readonly sessionId: FieldRef<"RequestContext", 'String'>
    readonly occurredAt: FieldRef<"RequestContext", 'DateTime'>
    readonly ipAddress: FieldRef<"RequestContext", 'String'>
    readonly userAgent: FieldRef<"RequestContext", 'String'>
    readonly deviceFingerprint: FieldRef<"RequestContext", 'String'>
    readonly workstationId: FieldRef<"RequestContext", 'String'>
    readonly geoCountry: FieldRef<"RequestContext", 'String'>
    readonly geoRegion: FieldRef<"RequestContext", 'String'>
    readonly geoCity: FieldRef<"RequestContext", 'String'>
    readonly geoLat: FieldRef<"RequestContext", 'Decimal'>
    readonly geoLon: FieldRef<"RequestContext", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * RequestContext findUnique
   */
  export type RequestContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * Filter, which RequestContext to fetch.
     */
    where: RequestContextWhereUniqueInput
  }

  /**
   * RequestContext findUniqueOrThrow
   */
  export type RequestContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * Filter, which RequestContext to fetch.
     */
    where: RequestContextWhereUniqueInput
  }

  /**
   * RequestContext findFirst
   */
  export type RequestContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * Filter, which RequestContext to fetch.
     */
    where?: RequestContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestContexts to fetch.
     */
    orderBy?: RequestContextOrderByWithRelationInput | RequestContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestContexts.
     */
    cursor?: RequestContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestContexts.
     */
    distinct?: RequestContextScalarFieldEnum | RequestContextScalarFieldEnum[]
  }

  /**
   * RequestContext findFirstOrThrow
   */
  export type RequestContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * Filter, which RequestContext to fetch.
     */
    where?: RequestContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestContexts to fetch.
     */
    orderBy?: RequestContextOrderByWithRelationInput | RequestContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestContexts.
     */
    cursor?: RequestContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestContexts.
     */
    distinct?: RequestContextScalarFieldEnum | RequestContextScalarFieldEnum[]
  }

  /**
   * RequestContext findMany
   */
  export type RequestContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * Filter, which RequestContexts to fetch.
     */
    where?: RequestContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestContexts to fetch.
     */
    orderBy?: RequestContextOrderByWithRelationInput | RequestContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestContexts.
     */
    cursor?: RequestContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestContexts.
     */
    skip?: number
    distinct?: RequestContextScalarFieldEnum | RequestContextScalarFieldEnum[]
  }

  /**
   * RequestContext create
   */
  export type RequestContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestContext.
     */
    data: XOR<RequestContextCreateInput, RequestContextUncheckedCreateInput>
  }

  /**
   * RequestContext createMany
   */
  export type RequestContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestContexts.
     */
    data: RequestContextCreateManyInput | RequestContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestContext createManyAndReturn
   */
  export type RequestContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * The data used to create many RequestContexts.
     */
    data: RequestContextCreateManyInput | RequestContextCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestContext update
   */
  export type RequestContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestContext.
     */
    data: XOR<RequestContextUpdateInput, RequestContextUncheckedUpdateInput>
    /**
     * Choose, which RequestContext to update.
     */
    where: RequestContextWhereUniqueInput
  }

  /**
   * RequestContext updateMany
   */
  export type RequestContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestContexts.
     */
    data: XOR<RequestContextUpdateManyMutationInput, RequestContextUncheckedUpdateManyInput>
    /**
     * Filter which RequestContexts to update
     */
    where?: RequestContextWhereInput
    /**
     * Limit how many RequestContexts to update.
     */
    limit?: number
  }

  /**
   * RequestContext updateManyAndReturn
   */
  export type RequestContextUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * The data used to update RequestContexts.
     */
    data: XOR<RequestContextUpdateManyMutationInput, RequestContextUncheckedUpdateManyInput>
    /**
     * Filter which RequestContexts to update
     */
    where?: RequestContextWhereInput
    /**
     * Limit how many RequestContexts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestContext upsert
   */
  export type RequestContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestContext to update in case it exists.
     */
    where: RequestContextWhereUniqueInput
    /**
     * In case the RequestContext found by the `where` argument doesn't exist, create a new RequestContext with this data.
     */
    create: XOR<RequestContextCreateInput, RequestContextUncheckedCreateInput>
    /**
     * In case the RequestContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestContextUpdateInput, RequestContextUncheckedUpdateInput>
  }

  /**
   * RequestContext delete
   */
  export type RequestContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
    /**
     * Filter which RequestContext to delete.
     */
    where: RequestContextWhereUniqueInput
  }

  /**
   * RequestContext deleteMany
   */
  export type RequestContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestContexts to delete
     */
    where?: RequestContextWhereInput
    /**
     * Limit how many RequestContexts to delete.
     */
    limit?: number
  }

  /**
   * RequestContext.workstation
   */
  export type RequestContext$workstationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workstation
     */
    select?: WorkstationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workstation
     */
    omit?: WorkstationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkstationInclude<ExtArgs> | null
    where?: WorkstationWhereInput
  }

  /**
   * RequestContext.invoices
   */
  export type RequestContext$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * RequestContext.payments
   */
  export type RequestContext$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * RequestContext.cashMoves
   */
  export type RequestContext$cashMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    cursor?: CashMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }

  /**
   * RequestContext.preclinics
   */
  export type RequestContext$preclinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    where?: PreclinicWhereInput
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    cursor?: PreclinicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreclinicScalarFieldEnum | PreclinicScalarFieldEnum[]
  }

  /**
   * RequestContext.labOrders
   */
  export type RequestContext$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * RequestContext.labOrderTests
   */
  export type RequestContext$labOrderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * RequestContext.activities
   */
  export type RequestContext$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * RequestContext without action
   */
  export type RequestContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestContext
     */
    select?: RequestContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestContext
     */
    omit?: RequestContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestContextInclude<ExtArgs> | null
  }


  /**
   * Model Preclinic
   */

  export type AggregatePreclinic = {
    _count: PreclinicCountAggregateOutputType | null
    _avg: PreclinicAvgAggregateOutputType | null
    _sum: PreclinicSumAggregateOutputType | null
    _min: PreclinicMinAggregateOutputType | null
    _max: PreclinicMaxAggregateOutputType | null
  }

  export type PreclinicAvgAggregateOutputType = {
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respRate: number | null
    temperatureC: Decimal | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    bmi: Decimal | null
  }

  export type PreclinicSumAggregateOutputType = {
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respRate: number | null
    temperatureC: Decimal | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    bmi: Decimal | null
  }

  export type PreclinicMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    visitDate: Date | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respRate: number | null
    temperatureC: Decimal | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    bmi: Decimal | null
    chiefComplaint: string | null
    currentMedications: string | null
    diabetes: boolean | null
    hypertension: boolean | null
    otherConditions: string | null
    allergiesReported: string | null
    recordedById: string | null
    requestContextId: string | null
  }

  export type PreclinicMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    visitDate: Date | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respRate: number | null
    temperatureC: Decimal | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    bmi: Decimal | null
    chiefComplaint: string | null
    currentMedications: string | null
    diabetes: boolean | null
    hypertension: boolean | null
    otherConditions: string | null
    allergiesReported: string | null
    recordedById: string | null
    requestContextId: string | null
  }

  export type PreclinicCountAggregateOutputType = {
    id: number
    patientId: number
    visitDate: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    heartRate: number
    respRate: number
    temperatureC: number
    weightKg: number
    heightCm: number
    bmi: number
    chiefComplaint: number
    currentMedications: number
    diabetes: number
    hypertension: number
    otherConditions: number
    allergiesReported: number
    recordedById: number
    requestContextId: number
    _all: number
  }


  export type PreclinicAvgAggregateInputType = {
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respRate?: true
    temperatureC?: true
    weightKg?: true
    heightCm?: true
    bmi?: true
  }

  export type PreclinicSumAggregateInputType = {
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respRate?: true
    temperatureC?: true
    weightKg?: true
    heightCm?: true
    bmi?: true
  }

  export type PreclinicMinAggregateInputType = {
    id?: true
    patientId?: true
    visitDate?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respRate?: true
    temperatureC?: true
    weightKg?: true
    heightCm?: true
    bmi?: true
    chiefComplaint?: true
    currentMedications?: true
    diabetes?: true
    hypertension?: true
    otherConditions?: true
    allergiesReported?: true
    recordedById?: true
    requestContextId?: true
  }

  export type PreclinicMaxAggregateInputType = {
    id?: true
    patientId?: true
    visitDate?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respRate?: true
    temperatureC?: true
    weightKg?: true
    heightCm?: true
    bmi?: true
    chiefComplaint?: true
    currentMedications?: true
    diabetes?: true
    hypertension?: true
    otherConditions?: true
    allergiesReported?: true
    recordedById?: true
    requestContextId?: true
  }

  export type PreclinicCountAggregateInputType = {
    id?: true
    patientId?: true
    visitDate?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    respRate?: true
    temperatureC?: true
    weightKg?: true
    heightCm?: true
    bmi?: true
    chiefComplaint?: true
    currentMedications?: true
    diabetes?: true
    hypertension?: true
    otherConditions?: true
    allergiesReported?: true
    recordedById?: true
    requestContextId?: true
    _all?: true
  }

  export type PreclinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preclinic to aggregate.
     */
    where?: PreclinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preclinics to fetch.
     */
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreclinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preclinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preclinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preclinics
    **/
    _count?: true | PreclinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreclinicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreclinicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreclinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreclinicMaxAggregateInputType
  }

  export type GetPreclinicAggregateType<T extends PreclinicAggregateArgs> = {
        [P in keyof T & keyof AggregatePreclinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreclinic[P]>
      : GetScalarType<T[P], AggregatePreclinic[P]>
  }




  export type PreclinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreclinicWhereInput
    orderBy?: PreclinicOrderByWithAggregationInput | PreclinicOrderByWithAggregationInput[]
    by: PreclinicScalarFieldEnum[] | PreclinicScalarFieldEnum
    having?: PreclinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreclinicCountAggregateInputType | true
    _avg?: PreclinicAvgAggregateInputType
    _sum?: PreclinicSumAggregateInputType
    _min?: PreclinicMinAggregateInputType
    _max?: PreclinicMaxAggregateInputType
  }

  export type PreclinicGroupByOutputType = {
    id: string
    patientId: string
    visitDate: Date
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    respRate: number | null
    temperatureC: Decimal | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    bmi: Decimal | null
    chiefComplaint: string | null
    currentMedications: string | null
    diabetes: boolean | null
    hypertension: boolean | null
    otherConditions: string | null
    allergiesReported: string | null
    recordedById: string
    requestContextId: string
    _count: PreclinicCountAggregateOutputType | null
    _avg: PreclinicAvgAggregateOutputType | null
    _sum: PreclinicSumAggregateOutputType | null
    _min: PreclinicMinAggregateOutputType | null
    _max: PreclinicMaxAggregateOutputType | null
  }

  type GetPreclinicGroupByPayload<T extends PreclinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreclinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreclinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreclinicGroupByOutputType[P]>
            : GetScalarType<T[P], PreclinicGroupByOutputType[P]>
        }
      >
    >


  export type PreclinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitDate?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respRate?: boolean
    temperatureC?: boolean
    weightKg?: boolean
    heightCm?: boolean
    bmi?: boolean
    chiefComplaint?: boolean
    currentMedications?: boolean
    diabetes?: boolean
    hypertension?: boolean
    otherConditions?: boolean
    allergiesReported?: boolean
    recordedById?: boolean
    requestContextId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    labOrders?: boolean | Preclinic$labOrdersArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
    invoices?: boolean | Preclinic$invoicesArgs<ExtArgs>
    _count?: boolean | PreclinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preclinic"]>

  export type PreclinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitDate?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respRate?: boolean
    temperatureC?: boolean
    weightKg?: boolean
    heightCm?: boolean
    bmi?: boolean
    chiefComplaint?: boolean
    currentMedications?: boolean
    diabetes?: boolean
    hypertension?: boolean
    otherConditions?: boolean
    allergiesReported?: boolean
    recordedById?: boolean
    requestContextId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preclinic"]>

  export type PreclinicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitDate?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respRate?: boolean
    temperatureC?: boolean
    weightKg?: boolean
    heightCm?: boolean
    bmi?: boolean
    chiefComplaint?: boolean
    currentMedications?: boolean
    diabetes?: boolean
    hypertension?: boolean
    otherConditions?: boolean
    allergiesReported?: boolean
    recordedById?: boolean
    requestContextId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preclinic"]>

  export type PreclinicSelectScalar = {
    id?: boolean
    patientId?: boolean
    visitDate?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    respRate?: boolean
    temperatureC?: boolean
    weightKg?: boolean
    heightCm?: boolean
    bmi?: boolean
    chiefComplaint?: boolean
    currentMedications?: boolean
    diabetes?: boolean
    hypertension?: boolean
    otherConditions?: boolean
    allergiesReported?: boolean
    recordedById?: boolean
    requestContextId?: boolean
  }

  export type PreclinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "visitDate" | "bloodPressureSystolic" | "bloodPressureDiastolic" | "heartRate" | "respRate" | "temperatureC" | "weightKg" | "heightCm" | "bmi" | "chiefComplaint" | "currentMedications" | "diabetes" | "hypertension" | "otherConditions" | "allergiesReported" | "recordedById" | "requestContextId", ExtArgs["result"]["preclinic"]>
  export type PreclinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    labOrders?: boolean | Preclinic$labOrdersArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
    invoices?: boolean | Preclinic$invoicesArgs<ExtArgs>
    _count?: boolean | PreclinicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PreclinicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type PreclinicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $PreclinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Preclinic"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
      recordedBy: Prisma.$UserPayload<ExtArgs>
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      visitDate: Date
      bloodPressureSystolic: number | null
      bloodPressureDiastolic: number | null
      heartRate: number | null
      respRate: number | null
      temperatureC: Prisma.Decimal | null
      weightKg: Prisma.Decimal | null
      heightCm: Prisma.Decimal | null
      bmi: Prisma.Decimal | null
      chiefComplaint: string | null
      currentMedications: string | null
      diabetes: boolean | null
      hypertension: boolean | null
      otherConditions: string | null
      allergiesReported: string | null
      recordedById: string
      requestContextId: string
    }, ExtArgs["result"]["preclinic"]>
    composites: {}
  }

  type PreclinicGetPayload<S extends boolean | null | undefined | PreclinicDefaultArgs> = $Result.GetResult<Prisma.$PreclinicPayload, S>

  type PreclinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreclinicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreclinicCountAggregateInputType | true
    }

  export interface PreclinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Preclinic'], meta: { name: 'Preclinic' } }
    /**
     * Find zero or one Preclinic that matches the filter.
     * @param {PreclinicFindUniqueArgs} args - Arguments to find a Preclinic
     * @example
     * // Get one Preclinic
     * const preclinic = await prisma.preclinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreclinicFindUniqueArgs>(args: SelectSubset<T, PreclinicFindUniqueArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Preclinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreclinicFindUniqueOrThrowArgs} args - Arguments to find a Preclinic
     * @example
     * // Get one Preclinic
     * const preclinic = await prisma.preclinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreclinicFindUniqueOrThrowArgs>(args: SelectSubset<T, PreclinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preclinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicFindFirstArgs} args - Arguments to find a Preclinic
     * @example
     * // Get one Preclinic
     * const preclinic = await prisma.preclinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreclinicFindFirstArgs>(args?: SelectSubset<T, PreclinicFindFirstArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preclinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicFindFirstOrThrowArgs} args - Arguments to find a Preclinic
     * @example
     * // Get one Preclinic
     * const preclinic = await prisma.preclinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreclinicFindFirstOrThrowArgs>(args?: SelectSubset<T, PreclinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Preclinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preclinics
     * const preclinics = await prisma.preclinic.findMany()
     * 
     * // Get first 10 Preclinics
     * const preclinics = await prisma.preclinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preclinicWithIdOnly = await prisma.preclinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreclinicFindManyArgs>(args?: SelectSubset<T, PreclinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Preclinic.
     * @param {PreclinicCreateArgs} args - Arguments to create a Preclinic.
     * @example
     * // Create one Preclinic
     * const Preclinic = await prisma.preclinic.create({
     *   data: {
     *     // ... data to create a Preclinic
     *   }
     * })
     * 
     */
    create<T extends PreclinicCreateArgs>(args: SelectSubset<T, PreclinicCreateArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Preclinics.
     * @param {PreclinicCreateManyArgs} args - Arguments to create many Preclinics.
     * @example
     * // Create many Preclinics
     * const preclinic = await prisma.preclinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreclinicCreateManyArgs>(args?: SelectSubset<T, PreclinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Preclinics and returns the data saved in the database.
     * @param {PreclinicCreateManyAndReturnArgs} args - Arguments to create many Preclinics.
     * @example
     * // Create many Preclinics
     * const preclinic = await prisma.preclinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Preclinics and only return the `id`
     * const preclinicWithIdOnly = await prisma.preclinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreclinicCreateManyAndReturnArgs>(args?: SelectSubset<T, PreclinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Preclinic.
     * @param {PreclinicDeleteArgs} args - Arguments to delete one Preclinic.
     * @example
     * // Delete one Preclinic
     * const Preclinic = await prisma.preclinic.delete({
     *   where: {
     *     // ... filter to delete one Preclinic
     *   }
     * })
     * 
     */
    delete<T extends PreclinicDeleteArgs>(args: SelectSubset<T, PreclinicDeleteArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Preclinic.
     * @param {PreclinicUpdateArgs} args - Arguments to update one Preclinic.
     * @example
     * // Update one Preclinic
     * const preclinic = await prisma.preclinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreclinicUpdateArgs>(args: SelectSubset<T, PreclinicUpdateArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Preclinics.
     * @param {PreclinicDeleteManyArgs} args - Arguments to filter Preclinics to delete.
     * @example
     * // Delete a few Preclinics
     * const { count } = await prisma.preclinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreclinicDeleteManyArgs>(args?: SelectSubset<T, PreclinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preclinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preclinics
     * const preclinic = await prisma.preclinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreclinicUpdateManyArgs>(args: SelectSubset<T, PreclinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preclinics and returns the data updated in the database.
     * @param {PreclinicUpdateManyAndReturnArgs} args - Arguments to update many Preclinics.
     * @example
     * // Update many Preclinics
     * const preclinic = await prisma.preclinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Preclinics and only return the `id`
     * const preclinicWithIdOnly = await prisma.preclinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreclinicUpdateManyAndReturnArgs>(args: SelectSubset<T, PreclinicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Preclinic.
     * @param {PreclinicUpsertArgs} args - Arguments to update or create a Preclinic.
     * @example
     * // Update or create a Preclinic
     * const preclinic = await prisma.preclinic.upsert({
     *   create: {
     *     // ... data to create a Preclinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preclinic we want to update
     *   }
     * })
     */
    upsert<T extends PreclinicUpsertArgs>(args: SelectSubset<T, PreclinicUpsertArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Preclinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicCountArgs} args - Arguments to filter Preclinics to count.
     * @example
     * // Count the number of Preclinics
     * const count = await prisma.preclinic.count({
     *   where: {
     *     // ... the filter for the Preclinics we want to count
     *   }
     * })
    **/
    count<T extends PreclinicCountArgs>(
      args?: Subset<T, PreclinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreclinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preclinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreclinicAggregateArgs>(args: Subset<T, PreclinicAggregateArgs>): Prisma.PrismaPromise<GetPreclinicAggregateType<T>>

    /**
     * Group by Preclinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreclinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreclinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreclinicGroupByArgs['orderBy'] }
        : { orderBy?: PreclinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreclinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreclinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Preclinic model
   */
  readonly fields: PreclinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preclinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreclinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labOrders<T extends Preclinic$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Preclinic$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recordedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Preclinic$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Preclinic$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Preclinic model
   */
  interface PreclinicFieldRefs {
    readonly id: FieldRef<"Preclinic", 'String'>
    readonly patientId: FieldRef<"Preclinic", 'String'>
    readonly visitDate: FieldRef<"Preclinic", 'DateTime'>
    readonly bloodPressureSystolic: FieldRef<"Preclinic", 'Int'>
    readonly bloodPressureDiastolic: FieldRef<"Preclinic", 'Int'>
    readonly heartRate: FieldRef<"Preclinic", 'Int'>
    readonly respRate: FieldRef<"Preclinic", 'Int'>
    readonly temperatureC: FieldRef<"Preclinic", 'Decimal'>
    readonly weightKg: FieldRef<"Preclinic", 'Decimal'>
    readonly heightCm: FieldRef<"Preclinic", 'Decimal'>
    readonly bmi: FieldRef<"Preclinic", 'Decimal'>
    readonly chiefComplaint: FieldRef<"Preclinic", 'String'>
    readonly currentMedications: FieldRef<"Preclinic", 'String'>
    readonly diabetes: FieldRef<"Preclinic", 'Boolean'>
    readonly hypertension: FieldRef<"Preclinic", 'Boolean'>
    readonly otherConditions: FieldRef<"Preclinic", 'String'>
    readonly allergiesReported: FieldRef<"Preclinic", 'String'>
    readonly recordedById: FieldRef<"Preclinic", 'String'>
    readonly requestContextId: FieldRef<"Preclinic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Preclinic findUnique
   */
  export type PreclinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * Filter, which Preclinic to fetch.
     */
    where: PreclinicWhereUniqueInput
  }

  /**
   * Preclinic findUniqueOrThrow
   */
  export type PreclinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * Filter, which Preclinic to fetch.
     */
    where: PreclinicWhereUniqueInput
  }

  /**
   * Preclinic findFirst
   */
  export type PreclinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * Filter, which Preclinic to fetch.
     */
    where?: PreclinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preclinics to fetch.
     */
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preclinics.
     */
    cursor?: PreclinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preclinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preclinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preclinics.
     */
    distinct?: PreclinicScalarFieldEnum | PreclinicScalarFieldEnum[]
  }

  /**
   * Preclinic findFirstOrThrow
   */
  export type PreclinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * Filter, which Preclinic to fetch.
     */
    where?: PreclinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preclinics to fetch.
     */
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preclinics.
     */
    cursor?: PreclinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preclinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preclinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preclinics.
     */
    distinct?: PreclinicScalarFieldEnum | PreclinicScalarFieldEnum[]
  }

  /**
   * Preclinic findMany
   */
  export type PreclinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * Filter, which Preclinics to fetch.
     */
    where?: PreclinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preclinics to fetch.
     */
    orderBy?: PreclinicOrderByWithRelationInput | PreclinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preclinics.
     */
    cursor?: PreclinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preclinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preclinics.
     */
    skip?: number
    distinct?: PreclinicScalarFieldEnum | PreclinicScalarFieldEnum[]
  }

  /**
   * Preclinic create
   */
  export type PreclinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Preclinic.
     */
    data: XOR<PreclinicCreateInput, PreclinicUncheckedCreateInput>
  }

  /**
   * Preclinic createMany
   */
  export type PreclinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Preclinics.
     */
    data: PreclinicCreateManyInput | PreclinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Preclinic createManyAndReturn
   */
  export type PreclinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * The data used to create many Preclinics.
     */
    data: PreclinicCreateManyInput | PreclinicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Preclinic update
   */
  export type PreclinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Preclinic.
     */
    data: XOR<PreclinicUpdateInput, PreclinicUncheckedUpdateInput>
    /**
     * Choose, which Preclinic to update.
     */
    where: PreclinicWhereUniqueInput
  }

  /**
   * Preclinic updateMany
   */
  export type PreclinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Preclinics.
     */
    data: XOR<PreclinicUpdateManyMutationInput, PreclinicUncheckedUpdateManyInput>
    /**
     * Filter which Preclinics to update
     */
    where?: PreclinicWhereInput
    /**
     * Limit how many Preclinics to update.
     */
    limit?: number
  }

  /**
   * Preclinic updateManyAndReturn
   */
  export type PreclinicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * The data used to update Preclinics.
     */
    data: XOR<PreclinicUpdateManyMutationInput, PreclinicUncheckedUpdateManyInput>
    /**
     * Filter which Preclinics to update
     */
    where?: PreclinicWhereInput
    /**
     * Limit how many Preclinics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Preclinic upsert
   */
  export type PreclinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Preclinic to update in case it exists.
     */
    where: PreclinicWhereUniqueInput
    /**
     * In case the Preclinic found by the `where` argument doesn't exist, create a new Preclinic with this data.
     */
    create: XOR<PreclinicCreateInput, PreclinicUncheckedCreateInput>
    /**
     * In case the Preclinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreclinicUpdateInput, PreclinicUncheckedUpdateInput>
  }

  /**
   * Preclinic delete
   */
  export type PreclinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    /**
     * Filter which Preclinic to delete.
     */
    where: PreclinicWhereUniqueInput
  }

  /**
   * Preclinic deleteMany
   */
  export type PreclinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preclinics to delete
     */
    where?: PreclinicWhereInput
    /**
     * Limit how many Preclinics to delete.
     */
    limit?: number
  }

  /**
   * Preclinic.labOrders
   */
  export type Preclinic$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * Preclinic.invoices
   */
  export type Preclinic$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Preclinic without action
   */
  export type PreclinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
  }


  /**
   * Model Allergy
   */

  export type AggregateAllergy = {
    _count: AllergyCountAggregateOutputType | null
    _min: AllergyMinAggregateOutputType | null
    _max: AllergyMaxAggregateOutputType | null
  }

  export type AllergyMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    substance: string | null
    reaction: string | null
    severity: $Enums.AllergySeverity | null
    recordedAt: Date | null
    recordedById: string | null
  }

  export type AllergyMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    substance: string | null
    reaction: string | null
    severity: $Enums.AllergySeverity | null
    recordedAt: Date | null
    recordedById: string | null
  }

  export type AllergyCountAggregateOutputType = {
    id: number
    patientId: number
    substance: number
    reaction: number
    severity: number
    recordedAt: number
    recordedById: number
    _all: number
  }


  export type AllergyMinAggregateInputType = {
    id?: true
    patientId?: true
    substance?: true
    reaction?: true
    severity?: true
    recordedAt?: true
    recordedById?: true
  }

  export type AllergyMaxAggregateInputType = {
    id?: true
    patientId?: true
    substance?: true
    reaction?: true
    severity?: true
    recordedAt?: true
    recordedById?: true
  }

  export type AllergyCountAggregateInputType = {
    id?: true
    patientId?: true
    substance?: true
    reaction?: true
    severity?: true
    recordedAt?: true
    recordedById?: true
    _all?: true
  }

  export type AllergyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergy to aggregate.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allergies
    **/
    _count?: true | AllergyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllergyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllergyMaxAggregateInputType
  }

  export type GetAllergyAggregateType<T extends AllergyAggregateArgs> = {
        [P in keyof T & keyof AggregateAllergy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllergy[P]>
      : GetScalarType<T[P], AggregateAllergy[P]>
  }




  export type AllergyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithAggregationInput | AllergyOrderByWithAggregationInput[]
    by: AllergyScalarFieldEnum[] | AllergyScalarFieldEnum
    having?: AllergyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllergyCountAggregateInputType | true
    _min?: AllergyMinAggregateInputType
    _max?: AllergyMaxAggregateInputType
  }

  export type AllergyGroupByOutputType = {
    id: string
    patientId: string
    substance: string
    reaction: string | null
    severity: $Enums.AllergySeverity | null
    recordedAt: Date
    recordedById: string | null
    _count: AllergyCountAggregateOutputType | null
    _min: AllergyMinAggregateOutputType | null
    _max: AllergyMaxAggregateOutputType | null
  }

  type GetAllergyGroupByPayload<T extends AllergyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllergyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllergyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllergyGroupByOutputType[P]>
            : GetScalarType<T[P], AllergyGroupByOutputType[P]>
        }
      >
    >


  export type AllergySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    substance?: boolean
    reaction?: boolean
    severity?: boolean
    recordedAt?: boolean
    recordedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Allergy$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    substance?: boolean
    reaction?: boolean
    severity?: boolean
    recordedAt?: boolean
    recordedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Allergy$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    substance?: boolean
    reaction?: boolean
    severity?: boolean
    recordedAt?: boolean
    recordedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Allergy$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectScalar = {
    id?: boolean
    patientId?: boolean
    substance?: boolean
    reaction?: boolean
    severity?: boolean
    recordedAt?: boolean
    recordedById?: boolean
  }

  export type AllergyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "substance" | "reaction" | "severity" | "recordedAt" | "recordedById", ExtArgs["result"]["allergy"]>
  export type AllergyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Allergy$recordedByArgs<ExtArgs>
  }
  export type AllergyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Allergy$recordedByArgs<ExtArgs>
  }
  export type AllergyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Allergy$recordedByArgs<ExtArgs>
  }

  export type $AllergyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allergy"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      recordedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      substance: string
      reaction: string | null
      severity: $Enums.AllergySeverity | null
      recordedAt: Date
      recordedById: string | null
    }, ExtArgs["result"]["allergy"]>
    composites: {}
  }

  type AllergyGetPayload<S extends boolean | null | undefined | AllergyDefaultArgs> = $Result.GetResult<Prisma.$AllergyPayload, S>

  type AllergyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllergyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllergyCountAggregateInputType | true
    }

  export interface AllergyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allergy'], meta: { name: 'Allergy' } }
    /**
     * Find zero or one Allergy that matches the filter.
     * @param {AllergyFindUniqueArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllergyFindUniqueArgs>(args: SelectSubset<T, AllergyFindUniqueArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Allergy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllergyFindUniqueOrThrowArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllergyFindUniqueOrThrowArgs>(args: SelectSubset<T, AllergyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allergy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindFirstArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllergyFindFirstArgs>(args?: SelectSubset<T, AllergyFindFirstArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allergy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindFirstOrThrowArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllergyFindFirstOrThrowArgs>(args?: SelectSubset<T, AllergyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Allergies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allergies
     * const allergies = await prisma.allergy.findMany()
     * 
     * // Get first 10 Allergies
     * const allergies = await prisma.allergy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allergyWithIdOnly = await prisma.allergy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllergyFindManyArgs>(args?: SelectSubset<T, AllergyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Allergy.
     * @param {AllergyCreateArgs} args - Arguments to create a Allergy.
     * @example
     * // Create one Allergy
     * const Allergy = await prisma.allergy.create({
     *   data: {
     *     // ... data to create a Allergy
     *   }
     * })
     * 
     */
    create<T extends AllergyCreateArgs>(args: SelectSubset<T, AllergyCreateArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Allergies.
     * @param {AllergyCreateManyArgs} args - Arguments to create many Allergies.
     * @example
     * // Create many Allergies
     * const allergy = await prisma.allergy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllergyCreateManyArgs>(args?: SelectSubset<T, AllergyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Allergies and returns the data saved in the database.
     * @param {AllergyCreateManyAndReturnArgs} args - Arguments to create many Allergies.
     * @example
     * // Create many Allergies
     * const allergy = await prisma.allergy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Allergies and only return the `id`
     * const allergyWithIdOnly = await prisma.allergy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllergyCreateManyAndReturnArgs>(args?: SelectSubset<T, AllergyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Allergy.
     * @param {AllergyDeleteArgs} args - Arguments to delete one Allergy.
     * @example
     * // Delete one Allergy
     * const Allergy = await prisma.allergy.delete({
     *   where: {
     *     // ... filter to delete one Allergy
     *   }
     * })
     * 
     */
    delete<T extends AllergyDeleteArgs>(args: SelectSubset<T, AllergyDeleteArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Allergy.
     * @param {AllergyUpdateArgs} args - Arguments to update one Allergy.
     * @example
     * // Update one Allergy
     * const allergy = await prisma.allergy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllergyUpdateArgs>(args: SelectSubset<T, AllergyUpdateArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Allergies.
     * @param {AllergyDeleteManyArgs} args - Arguments to filter Allergies to delete.
     * @example
     * // Delete a few Allergies
     * const { count } = await prisma.allergy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllergyDeleteManyArgs>(args?: SelectSubset<T, AllergyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allergies
     * const allergy = await prisma.allergy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllergyUpdateManyArgs>(args: SelectSubset<T, AllergyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies and returns the data updated in the database.
     * @param {AllergyUpdateManyAndReturnArgs} args - Arguments to update many Allergies.
     * @example
     * // Update many Allergies
     * const allergy = await prisma.allergy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Allergies and only return the `id`
     * const allergyWithIdOnly = await prisma.allergy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllergyUpdateManyAndReturnArgs>(args: SelectSubset<T, AllergyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Allergy.
     * @param {AllergyUpsertArgs} args - Arguments to update or create a Allergy.
     * @example
     * // Update or create a Allergy
     * const allergy = await prisma.allergy.upsert({
     *   create: {
     *     // ... data to create a Allergy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allergy we want to update
     *   }
     * })
     */
    upsert<T extends AllergyUpsertArgs>(args: SelectSubset<T, AllergyUpsertArgs<ExtArgs>>): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyCountArgs} args - Arguments to filter Allergies to count.
     * @example
     * // Count the number of Allergies
     * const count = await prisma.allergy.count({
     *   where: {
     *     // ... the filter for the Allergies we want to count
     *   }
     * })
    **/
    count<T extends AllergyCountArgs>(
      args?: Subset<T, AllergyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllergyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllergyAggregateArgs>(args: Subset<T, AllergyAggregateArgs>): Prisma.PrismaPromise<GetAllergyAggregateType<T>>

    /**
     * Group by Allergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllergyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllergyGroupByArgs['orderBy'] }
        : { orderBy?: AllergyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllergyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllergyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allergy model
   */
  readonly fields: AllergyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allergy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllergyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recordedBy<T extends Allergy$recordedByArgs<ExtArgs> = {}>(args?: Subset<T, Allergy$recordedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Allergy model
   */
  interface AllergyFieldRefs {
    readonly id: FieldRef<"Allergy", 'String'>
    readonly patientId: FieldRef<"Allergy", 'String'>
    readonly substance: FieldRef<"Allergy", 'String'>
    readonly reaction: FieldRef<"Allergy", 'String'>
    readonly severity: FieldRef<"Allergy", 'AllergySeverity'>
    readonly recordedAt: FieldRef<"Allergy", 'DateTime'>
    readonly recordedById: FieldRef<"Allergy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Allergy findUnique
   */
  export type AllergyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy findUniqueOrThrow
   */
  export type AllergyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy findFirst
   */
  export type AllergyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Allergy findFirstOrThrow
   */
  export type AllergyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Allergy findMany
   */
  export type AllergyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergies to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }

  /**
   * Allergy create
   */
  export type AllergyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The data needed to create a Allergy.
     */
    data: XOR<AllergyCreateInput, AllergyUncheckedCreateInput>
  }

  /**
   * Allergy createMany
   */
  export type AllergyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allergies.
     */
    data: AllergyCreateManyInput | AllergyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Allergy createManyAndReturn
   */
  export type AllergyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * The data used to create many Allergies.
     */
    data: AllergyCreateManyInput | AllergyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allergy update
   */
  export type AllergyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The data needed to update a Allergy.
     */
    data: XOR<AllergyUpdateInput, AllergyUncheckedUpdateInput>
    /**
     * Choose, which Allergy to update.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy updateMany
   */
  export type AllergyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergyWhereInput
    /**
     * Limit how many Allergies to update.
     */
    limit?: number
  }

  /**
   * Allergy updateManyAndReturn
   */
  export type AllergyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergyWhereInput
    /**
     * Limit how many Allergies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allergy upsert
   */
  export type AllergyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The filter to search for the Allergy to update in case it exists.
     */
    where: AllergyWhereUniqueInput
    /**
     * In case the Allergy found by the `where` argument doesn't exist, create a new Allergy with this data.
     */
    create: XOR<AllergyCreateInput, AllergyUncheckedCreateInput>
    /**
     * In case the Allergy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllergyUpdateInput, AllergyUncheckedUpdateInput>
  }

  /**
   * Allergy delete
   */
  export type AllergyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter which Allergy to delete.
     */
    where: AllergyWhereUniqueInput
  }

  /**
   * Allergy deleteMany
   */
  export type AllergyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergies to delete
     */
    where?: AllergyWhereInput
    /**
     * Limit how many Allergies to delete.
     */
    limit?: number
  }

  /**
   * Allergy.recordedBy
   */
  export type Allergy$recordedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Allergy without action
   */
  export type AllergyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergy
     */
    omit?: AllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyInclude<ExtArgs> | null
  }


  /**
   * Model Problem
   */

  export type AggregateProblem = {
    _count: ProblemCountAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  export type ProblemMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    condition: string | null
    status: $Enums.ProblemStatus | null
    diagnosedAt: Date | null
    resolvedAt: Date | null
    recordedById: string | null
  }

  export type ProblemMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    condition: string | null
    status: $Enums.ProblemStatus | null
    diagnosedAt: Date | null
    resolvedAt: Date | null
    recordedById: string | null
  }

  export type ProblemCountAggregateOutputType = {
    id: number
    patientId: number
    condition: number
    status: number
    diagnosedAt: number
    resolvedAt: number
    recordedById: number
    _all: number
  }


  export type ProblemMinAggregateInputType = {
    id?: true
    patientId?: true
    condition?: true
    status?: true
    diagnosedAt?: true
    resolvedAt?: true
    recordedById?: true
  }

  export type ProblemMaxAggregateInputType = {
    id?: true
    patientId?: true
    condition?: true
    status?: true
    diagnosedAt?: true
    resolvedAt?: true
    recordedById?: true
  }

  export type ProblemCountAggregateInputType = {
    id?: true
    patientId?: true
    condition?: true
    status?: true
    diagnosedAt?: true
    resolvedAt?: true
    recordedById?: true
    _all?: true
  }

  export type ProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Problem to aggregate.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Problems
    **/
    _count?: true | ProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProblemMaxAggregateInputType
  }

  export type GetProblemAggregateType<T extends ProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem[P]>
      : GetScalarType<T[P], AggregateProblem[P]>
  }




  export type ProblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemWhereInput
    orderBy?: ProblemOrderByWithAggregationInput | ProblemOrderByWithAggregationInput[]
    by: ProblemScalarFieldEnum[] | ProblemScalarFieldEnum
    having?: ProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProblemCountAggregateInputType | true
    _min?: ProblemMinAggregateInputType
    _max?: ProblemMaxAggregateInputType
  }

  export type ProblemGroupByOutputType = {
    id: string
    patientId: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt: Date | null
    resolvedAt: Date | null
    recordedById: string | null
    _count: ProblemCountAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  type GetProblemGroupByPayload<T extends ProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProblemGroupByOutputType[P]>
            : GetScalarType<T[P], ProblemGroupByOutputType[P]>
        }
      >
    >


  export type ProblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    condition?: boolean
    status?: boolean
    diagnosedAt?: boolean
    resolvedAt?: boolean
    recordedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Problem$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["problem"]>

  export type ProblemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    condition?: boolean
    status?: boolean
    diagnosedAt?: boolean
    resolvedAt?: boolean
    recordedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Problem$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["problem"]>

  export type ProblemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    condition?: boolean
    status?: boolean
    diagnosedAt?: boolean
    resolvedAt?: boolean
    recordedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Problem$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["problem"]>

  export type ProblemSelectScalar = {
    id?: boolean
    patientId?: boolean
    condition?: boolean
    status?: boolean
    diagnosedAt?: boolean
    resolvedAt?: boolean
    recordedById?: boolean
  }

  export type ProblemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "condition" | "status" | "diagnosedAt" | "resolvedAt" | "recordedById", ExtArgs["result"]["problem"]>
  export type ProblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Problem$recordedByArgs<ExtArgs>
  }
  export type ProblemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Problem$recordedByArgs<ExtArgs>
  }
  export type ProblemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    recordedBy?: boolean | Problem$recordedByArgs<ExtArgs>
  }

  export type $ProblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Problem"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      recordedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      condition: string
      status: $Enums.ProblemStatus
      diagnosedAt: Date | null
      resolvedAt: Date | null
      recordedById: string | null
    }, ExtArgs["result"]["problem"]>
    composites: {}
  }

  type ProblemGetPayload<S extends boolean | null | undefined | ProblemDefaultArgs> = $Result.GetResult<Prisma.$ProblemPayload, S>

  type ProblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProblemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProblemCountAggregateInputType | true
    }

  export interface ProblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Problem'], meta: { name: 'Problem' } }
    /**
     * Find zero or one Problem that matches the filter.
     * @param {ProblemFindUniqueArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProblemFindUniqueArgs>(args: SelectSubset<T, ProblemFindUniqueArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Problem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProblemFindUniqueOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProblemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProblemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Problem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindFirstArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProblemFindFirstArgs>(args?: SelectSubset<T, ProblemFindFirstArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Problem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindFirstOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProblemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProblemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Problems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problems
     * const problems = await prisma.problem.findMany()
     * 
     * // Get first 10 Problems
     * const problems = await prisma.problem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problemWithIdOnly = await prisma.problem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProblemFindManyArgs>(args?: SelectSubset<T, ProblemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Problem.
     * @param {ProblemCreateArgs} args - Arguments to create a Problem.
     * @example
     * // Create one Problem
     * const Problem = await prisma.problem.create({
     *   data: {
     *     // ... data to create a Problem
     *   }
     * })
     * 
     */
    create<T extends ProblemCreateArgs>(args: SelectSubset<T, ProblemCreateArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Problems.
     * @param {ProblemCreateManyArgs} args - Arguments to create many Problems.
     * @example
     * // Create many Problems
     * const problem = await prisma.problem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProblemCreateManyArgs>(args?: SelectSubset<T, ProblemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Problems and returns the data saved in the database.
     * @param {ProblemCreateManyAndReturnArgs} args - Arguments to create many Problems.
     * @example
     * // Create many Problems
     * const problem = await prisma.problem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Problems and only return the `id`
     * const problemWithIdOnly = await prisma.problem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProblemCreateManyAndReturnArgs>(args?: SelectSubset<T, ProblemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Problem.
     * @param {ProblemDeleteArgs} args - Arguments to delete one Problem.
     * @example
     * // Delete one Problem
     * const Problem = await prisma.problem.delete({
     *   where: {
     *     // ... filter to delete one Problem
     *   }
     * })
     * 
     */
    delete<T extends ProblemDeleteArgs>(args: SelectSubset<T, ProblemDeleteArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Problem.
     * @param {ProblemUpdateArgs} args - Arguments to update one Problem.
     * @example
     * // Update one Problem
     * const problem = await prisma.problem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProblemUpdateArgs>(args: SelectSubset<T, ProblemUpdateArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Problems.
     * @param {ProblemDeleteManyArgs} args - Arguments to filter Problems to delete.
     * @example
     * // Delete a few Problems
     * const { count } = await prisma.problem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProblemDeleteManyArgs>(args?: SelectSubset<T, ProblemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problems
     * const problem = await prisma.problem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProblemUpdateManyArgs>(args: SelectSubset<T, ProblemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems and returns the data updated in the database.
     * @param {ProblemUpdateManyAndReturnArgs} args - Arguments to update many Problems.
     * @example
     * // Update many Problems
     * const problem = await prisma.problem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Problems and only return the `id`
     * const problemWithIdOnly = await prisma.problem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProblemUpdateManyAndReturnArgs>(args: SelectSubset<T, ProblemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Problem.
     * @param {ProblemUpsertArgs} args - Arguments to update or create a Problem.
     * @example
     * // Update or create a Problem
     * const problem = await prisma.problem.upsert({
     *   create: {
     *     // ... data to create a Problem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem we want to update
     *   }
     * })
     */
    upsert<T extends ProblemUpsertArgs>(args: SelectSubset<T, ProblemUpsertArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemCountArgs} args - Arguments to filter Problems to count.
     * @example
     * // Count the number of Problems
     * const count = await prisma.problem.count({
     *   where: {
     *     // ... the filter for the Problems we want to count
     *   }
     * })
    **/
    count<T extends ProblemCountArgs>(
      args?: Subset<T, ProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProblemAggregateArgs>(args: Subset<T, ProblemAggregateArgs>): Prisma.PrismaPromise<GetProblemAggregateType<T>>

    /**
     * Group by Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProblemGroupByArgs['orderBy'] }
        : { orderBy?: ProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Problem model
   */
  readonly fields: ProblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Problem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recordedBy<T extends Problem$recordedByArgs<ExtArgs> = {}>(args?: Subset<T, Problem$recordedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Problem model
   */
  interface ProblemFieldRefs {
    readonly id: FieldRef<"Problem", 'String'>
    readonly patientId: FieldRef<"Problem", 'String'>
    readonly condition: FieldRef<"Problem", 'String'>
    readonly status: FieldRef<"Problem", 'ProblemStatus'>
    readonly diagnosedAt: FieldRef<"Problem", 'DateTime'>
    readonly resolvedAt: FieldRef<"Problem", 'DateTime'>
    readonly recordedById: FieldRef<"Problem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Problem findUnique
   */
  export type ProblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem findUniqueOrThrow
   */
  export type ProblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem findFirst
   */
  export type ProblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem findFirstOrThrow
   */
  export type ProblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem findMany
   */
  export type ProblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problems to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem create
   */
  export type ProblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The data needed to create a Problem.
     */
    data: XOR<ProblemCreateInput, ProblemUncheckedCreateInput>
  }

  /**
   * Problem createMany
   */
  export type ProblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Problems.
     */
    data: ProblemCreateManyInput | ProblemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Problem createManyAndReturn
   */
  export type ProblemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * The data used to create many Problems.
     */
    data: ProblemCreateManyInput | ProblemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Problem update
   */
  export type ProblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The data needed to update a Problem.
     */
    data: XOR<ProblemUpdateInput, ProblemUncheckedUpdateInput>
    /**
     * Choose, which Problem to update.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem updateMany
   */
  export type ProblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Problems.
     */
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyInput>
    /**
     * Filter which Problems to update
     */
    where?: ProblemWhereInput
    /**
     * Limit how many Problems to update.
     */
    limit?: number
  }

  /**
   * Problem updateManyAndReturn
   */
  export type ProblemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * The data used to update Problems.
     */
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyInput>
    /**
     * Filter which Problems to update
     */
    where?: ProblemWhereInput
    /**
     * Limit how many Problems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Problem upsert
   */
  export type ProblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The filter to search for the Problem to update in case it exists.
     */
    where: ProblemWhereUniqueInput
    /**
     * In case the Problem found by the `where` argument doesn't exist, create a new Problem with this data.
     */
    create: XOR<ProblemCreateInput, ProblemUncheckedCreateInput>
    /**
     * In case the Problem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProblemUpdateInput, ProblemUncheckedUpdateInput>
  }

  /**
   * Problem delete
   */
  export type ProblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter which Problem to delete.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem deleteMany
   */
  export type ProblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Problems to delete
     */
    where?: ProblemWhereInput
    /**
     * Limit how many Problems to delete.
     */
    limit?: number
  }

  /**
   * Problem.recordedBy
   */
  export type Problem$recordedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Problem without action
   */
  export type ProblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Problem
     */
    omit?: ProblemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    drugName: string | null
    dose: string | null
    frequency: string | null
    route: $Enums.Route | null
    startedAt: Date | null
    stoppedAt: Date | null
    prescribedById: string | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    drugName: string | null
    dose: string | null
    frequency: string | null
    route: $Enums.Route | null
    startedAt: Date | null
    stoppedAt: Date | null
    prescribedById: string | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    patientId: number
    drugName: number
    dose: number
    frequency: number
    route: number
    startedAt: number
    stoppedAt: number
    prescribedById: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    patientId?: true
    drugName?: true
    dose?: true
    frequency?: true
    route?: true
    startedAt?: true
    stoppedAt?: true
    prescribedById?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    patientId?: true
    drugName?: true
    dose?: true
    frequency?: true
    route?: true
    startedAt?: true
    stoppedAt?: true
    prescribedById?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    patientId?: true
    drugName?: true
    dose?: true
    frequency?: true
    route?: true
    startedAt?: true
    stoppedAt?: true
    prescribedById?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    patientId: string
    drugName: string
    dose: string | null
    frequency: string | null
    route: $Enums.Route | null
    startedAt: Date | null
    stoppedAt: Date | null
    prescribedById: string | null
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    drugName?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    prescribedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescribedBy?: boolean | Medication$prescribedByArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    drugName?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    prescribedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescribedBy?: boolean | Medication$prescribedByArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    drugName?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    prescribedById?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescribedBy?: boolean | Medication$prescribedByArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    patientId?: boolean
    drugName?: boolean
    dose?: boolean
    frequency?: boolean
    route?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    prescribedById?: boolean
  }

  export type MedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "drugName" | "dose" | "frequency" | "route" | "startedAt" | "stoppedAt" | "prescribedById", ExtArgs["result"]["medication"]>
  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescribedBy?: boolean | Medication$prescribedByArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescribedBy?: boolean | Medication$prescribedByArgs<ExtArgs>
  }
  export type MedicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescribedBy?: boolean | Medication$prescribedByArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      prescribedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      drugName: string
      dose: string | null
      frequency: string | null
      route: $Enums.Route | null
      startedAt: Date | null
      stoppedAt: Date | null
      prescribedById: string | null
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications and returns the data updated in the database.
     * @param {MedicationUpdateManyAndReturnArgs} args - Arguments to update many Medications.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescribedBy<T extends Medication$prescribedByArgs<ExtArgs> = {}>(args?: Subset<T, Medication$prescribedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly patientId: FieldRef<"Medication", 'String'>
    readonly drugName: FieldRef<"Medication", 'String'>
    readonly dose: FieldRef<"Medication", 'String'>
    readonly frequency: FieldRef<"Medication", 'String'>
    readonly route: FieldRef<"Medication", 'Route'>
    readonly startedAt: FieldRef<"Medication", 'DateTime'>
    readonly stoppedAt: FieldRef<"Medication", 'DateTime'>
    readonly prescribedById: FieldRef<"Medication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
  }

  /**
   * Medication updateManyAndReturn
   */
  export type MedicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to delete.
     */
    limit?: number
  }

  /**
   * Medication.prescribedBy
   */
  export type Medication$prescribedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {ServiceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceCategory$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory updateManyAndReturn
   */
  export type ServiceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.services
   */
  export type ServiceCategory$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: Decimal | null
    taxRatePct: Decimal | null
    commissionPct: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    price: Decimal | null
    taxRatePct: Decimal | null
    commissionPct: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    categoryId: string | null
    price: Decimal | null
    taxRatePct: Decimal | null
    commissionPct: Decimal | null
    requiresProvider: boolean | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    categoryId: string | null
    price: Decimal | null
    taxRatePct: Decimal | null
    commissionPct: Decimal | null
    requiresProvider: boolean | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    code: number
    name: number
    categoryId: number
    price: number
    taxRatePct: number
    commissionPct: number
    requiresProvider: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    taxRatePct?: true
    commissionPct?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    taxRatePct?: true
    commissionPct?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    categoryId?: true
    price?: true
    taxRatePct?: true
    commissionPct?: true
    requiresProvider?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    categoryId?: true
    price?: true
    taxRatePct?: true
    commissionPct?: true
    requiresProvider?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    categoryId?: true
    price?: true
    taxRatePct?: true
    commissionPct?: true
    requiresProvider?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    code: string
    name: string
    categoryId: string
    price: Decimal
    taxRatePct: Decimal
    commissionPct: Decimal | null
    requiresProvider: boolean
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    categoryId?: boolean
    price?: boolean
    taxRatePct?: boolean
    commissionPct?: boolean
    requiresProvider?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    lines?: boolean | Service$linesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    categoryId?: boolean
    price?: boolean
    taxRatePct?: boolean
    commissionPct?: boolean
    requiresProvider?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    categoryId?: boolean
    price?: boolean
    taxRatePct?: boolean
    commissionPct?: boolean
    requiresProvider?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    categoryId?: boolean
    price?: boolean
    taxRatePct?: boolean
    commissionPct?: boolean
    requiresProvider?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "categoryId" | "price" | "taxRatePct" | "commissionPct" | "requiresProvider", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    lines?: boolean | Service$linesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      categoryId: string
      price: Prisma.Decimal
      taxRatePct: Prisma.Decimal
      commissionPct: Prisma.Decimal | null
      requiresProvider: boolean
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends Service$linesArgs<ExtArgs> = {}>(args?: Subset<T, Service$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly code: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly categoryId: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Decimal'>
    readonly taxRatePct: FieldRef<"Service", 'Decimal'>
    readonly commissionPct: FieldRef<"Service", 'Decimal'>
    readonly requiresProvider: FieldRef<"Service", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.lines
   */
  export type Service$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderAvgAggregateOutputType = {
    defaultCommissionPct: Decimal | null
  }

  export type ProviderSumAggregateOutputType = {
    defaultCommissionPct: Decimal | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    specialty: string | null
    defaultCommissionPct: Decimal | null
    isActive: boolean | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    specialty: string | null
    defaultCommissionPct: Decimal | null
    isActive: boolean | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    fullName: number
    specialty: number
    defaultCommissionPct: number
    isActive: number
    _all: number
  }


  export type ProviderAvgAggregateInputType = {
    defaultCommissionPct?: true
  }

  export type ProviderSumAggregateInputType = {
    defaultCommissionPct?: true
  }

  export type ProviderMinAggregateInputType = {
    id?: true
    fullName?: true
    specialty?: true
    defaultCommissionPct?: true
    isActive?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    fullName?: true
    specialty?: true
    defaultCommissionPct?: true
    isActive?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    fullName?: true
    specialty?: true
    defaultCommissionPct?: true
    isActive?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _avg?: ProviderAvgAggregateInputType
    _sum?: ProviderSumAggregateInputType
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    fullName: string
    specialty: string | null
    defaultCommissionPct: Decimal | null
    isActive: boolean
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    specialty?: boolean
    defaultCommissionPct?: boolean
    isActive?: boolean
    lines?: boolean | Provider$linesArgs<ExtArgs>
    commissions?: boolean | Provider$commissionsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    specialty?: boolean
    defaultCommissionPct?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    specialty?: boolean
    defaultCommissionPct?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    fullName?: boolean
    specialty?: boolean
    defaultCommissionPct?: boolean
    isActive?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "specialty" | "defaultCommissionPct" | "isActive", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | Provider$linesArgs<ExtArgs>
    commissions?: boolean | Provider$commissionsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      commissions: Prisma.$ProviderCommissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      specialty: string | null
      defaultCommissionPct: Prisma.Decimal | null
      isActive: boolean
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lines<T extends Provider$linesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commissions<T extends Provider$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly fullName: FieldRef<"Provider", 'String'>
    readonly specialty: FieldRef<"Provider", 'String'>
    readonly defaultCommissionPct: FieldRef<"Provider", 'Decimal'>
    readonly isActive: FieldRef<"Provider", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider.lines
   */
  export type Provider$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Provider.commissions
   */
  export type Provider$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    where?: ProviderCommissionWhereInput
    orderBy?: ProviderCommissionOrderByWithRelationInput | ProviderCommissionOrderByWithRelationInput[]
    cursor?: ProviderCommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderCommissionScalarFieldEnum | ProviderCommissionScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    discountTotal: Decimal | null
    taxTotal: Decimal | null
    total: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    discountTotal: Decimal | null
    taxTotal: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    patientId: string | null
    preclinicId: string | null
    status: $Enums.InvoiceStatus | null
    invoiceAt: Date | null
    locationId: string | null
    cashierId: string | null
    registerId: string | null
    requestContextId: string | null
    subtotal: Decimal | null
    discountTotal: Decimal | null
    taxTotal: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    patientId: string | null
    preclinicId: string | null
    status: $Enums.InvoiceStatus | null
    invoiceAt: Date | null
    locationId: string | null
    cashierId: string | null
    registerId: string | null
    requestContextId: string | null
    subtotal: Decimal | null
    discountTotal: Decimal | null
    taxTotal: Decimal | null
    total: Decimal | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNo: number
    patientId: number
    preclinicId: number
    status: number
    invoiceAt: number
    locationId: number
    cashierId: number
    registerId: number
    requestContextId: number
    subtotal: number
    discountTotal: number
    taxTotal: number
    total: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    discountTotal?: true
    taxTotal?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    discountTotal?: true
    taxTotal?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    patientId?: true
    preclinicId?: true
    status?: true
    invoiceAt?: true
    locationId?: true
    cashierId?: true
    registerId?: true
    requestContextId?: true
    subtotal?: true
    discountTotal?: true
    taxTotal?: true
    total?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    patientId?: true
    preclinicId?: true
    status?: true
    invoiceAt?: true
    locationId?: true
    cashierId?: true
    registerId?: true
    requestContextId?: true
    subtotal?: true
    discountTotal?: true
    taxTotal?: true
    total?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    patientId?: true
    preclinicId?: true
    status?: true
    invoiceAt?: true
    locationId?: true
    cashierId?: true
    registerId?: true
    requestContextId?: true
    subtotal?: true
    discountTotal?: true
    taxTotal?: true
    total?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNo: string
    patientId: string | null
    preclinicId: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date
    locationId: string
    cashierId: string
    registerId: string | null
    requestContextId: string
    subtotal: Decimal
    discountTotal: Decimal
    taxTotal: Decimal
    total: Decimal
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    patientId?: boolean
    preclinicId?: boolean
    status?: boolean
    invoiceAt?: boolean
    locationId?: boolean
    cashierId?: boolean
    registerId?: boolean
    requestContextId?: boolean
    subtotal?: boolean
    discountTotal?: boolean
    taxTotal?: boolean
    total?: boolean
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    preclinic?: boolean | Invoice$preclinicArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    register?: boolean | Invoice$registerArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    labOrders?: boolean | Invoice$labOrdersArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    patientId?: boolean
    preclinicId?: boolean
    status?: boolean
    invoiceAt?: boolean
    locationId?: boolean
    cashierId?: boolean
    registerId?: boolean
    requestContextId?: boolean
    subtotal?: boolean
    discountTotal?: boolean
    taxTotal?: boolean
    total?: boolean
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    preclinic?: boolean | Invoice$preclinicArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    register?: boolean | Invoice$registerArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    patientId?: boolean
    preclinicId?: boolean
    status?: boolean
    invoiceAt?: boolean
    locationId?: boolean
    cashierId?: boolean
    registerId?: boolean
    requestContextId?: boolean
    subtotal?: boolean
    discountTotal?: boolean
    taxTotal?: boolean
    total?: boolean
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    preclinic?: boolean | Invoice$preclinicArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    register?: boolean | Invoice$registerArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    patientId?: boolean
    preclinicId?: boolean
    status?: boolean
    invoiceAt?: boolean
    locationId?: boolean
    cashierId?: boolean
    registerId?: boolean
    requestContextId?: boolean
    subtotal?: boolean
    discountTotal?: boolean
    taxTotal?: boolean
    total?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "patientId" | "preclinicId" | "status" | "invoiceAt" | "locationId" | "cashierId" | "registerId" | "requestContextId" | "subtotal" | "discountTotal" | "taxTotal" | "total", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    preclinic?: boolean | Invoice$preclinicArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    register?: boolean | Invoice$registerArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    labOrders?: boolean | Invoice$labOrdersArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    preclinic?: boolean | Invoice$preclinicArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    register?: boolean | Invoice$registerArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    preclinic?: boolean | Invoice$preclinicArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    cashier?: boolean | UserDefaultArgs<ExtArgs>
    register?: boolean | Invoice$registerArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
      preclinic: Prisma.$PreclinicPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
      cashier: Prisma.$UserPayload<ExtArgs>
      register: Prisma.$CashRegisterPayload<ExtArgs> | null
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNo: string
      patientId: string | null
      preclinicId: string | null
      status: $Enums.InvoiceStatus
      invoiceAt: Date
      locationId: string
      cashierId: string
      registerId: string | null
      requestContextId: string
      subtotal: Prisma.Decimal
      discountTotal: Prisma.Decimal
      taxTotal: Prisma.Decimal
      total: Prisma.Decimal
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends Invoice$patientArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preclinic<T extends Invoice$preclinicArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$preclinicArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cashier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    register<T extends Invoice$registerArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$registerArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends Invoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrders<T extends Invoice$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNo: FieldRef<"Invoice", 'String'>
    readonly patientId: FieldRef<"Invoice", 'String'>
    readonly preclinicId: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly invoiceAt: FieldRef<"Invoice", 'DateTime'>
    readonly locationId: FieldRef<"Invoice", 'String'>
    readonly cashierId: FieldRef<"Invoice", 'String'>
    readonly registerId: FieldRef<"Invoice", 'String'>
    readonly requestContextId: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly discountTotal: FieldRef<"Invoice", 'Decimal'>
    readonly taxTotal: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.patient
   */
  export type Invoice$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Invoice.preclinic
   */
  export type Invoice$preclinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    where?: PreclinicWhereInput
  }

  /**
   * Invoice.register
   */
  export type Invoice$registerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
  }

  /**
   * Invoice.lines
   */
  export type Invoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.labOrders
   */
  export type Invoice$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    lineNo: number | null
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPct: Decimal | null
    taxRatePct: Decimal | null
    lineTotal: Decimal | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    lineNo: number | null
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPct: Decimal | null
    taxRatePct: Decimal | null
    lineTotal: Decimal | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    lineNo: number | null
    itemType: $Enums.ItemType | null
    serviceId: string | null
    productId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPct: Decimal | null
    taxRatePct: Decimal | null
    lineTotal: Decimal | null
    providerId: string | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    lineNo: number | null
    itemType: $Enums.ItemType | null
    serviceId: string | null
    productId: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPct: Decimal | null
    taxRatePct: Decimal | null
    lineTotal: Decimal | null
    providerId: string | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    lineNo: number
    itemType: number
    serviceId: number
    productId: number
    description: number
    qty: number
    unitPrice: number
    discountPct: number
    taxRatePct: number
    lineTotal: number
    providerId: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    lineNo?: true
    qty?: true
    unitPrice?: true
    discountPct?: true
    taxRatePct?: true
    lineTotal?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    lineNo?: true
    qty?: true
    unitPrice?: true
    discountPct?: true
    taxRatePct?: true
    lineTotal?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    lineNo?: true
    itemType?: true
    serviceId?: true
    productId?: true
    description?: true
    qty?: true
    unitPrice?: true
    discountPct?: true
    taxRatePct?: true
    lineTotal?: true
    providerId?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    lineNo?: true
    itemType?: true
    serviceId?: true
    productId?: true
    description?: true
    qty?: true
    unitPrice?: true
    discountPct?: true
    taxRatePct?: true
    lineTotal?: true
    providerId?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    lineNo?: true
    itemType?: true
    serviceId?: true
    productId?: true
    description?: true
    qty?: true
    unitPrice?: true
    discountPct?: true
    taxRatePct?: true
    lineTotal?: true
    providerId?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId: string | null
    productId: string | null
    description: string
    qty: Decimal
    unitPrice: Decimal
    discountPct: Decimal
    taxRatePct: Decimal
    lineTotal: Decimal
    providerId: string | null
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    lineNo?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPct?: boolean
    taxRatePct?: boolean
    lineTotal?: boolean
    providerId?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceLine$serviceArgs<ExtArgs>
    product?: boolean | InvoiceLine$productArgs<ExtArgs>
    provider?: boolean | InvoiceLine$providerArgs<ExtArgs>
    commission?: boolean | InvoiceLine$commissionArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    lineNo?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPct?: boolean
    taxRatePct?: boolean
    lineTotal?: boolean
    providerId?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceLine$serviceArgs<ExtArgs>
    product?: boolean | InvoiceLine$productArgs<ExtArgs>
    provider?: boolean | InvoiceLine$providerArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    lineNo?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPct?: boolean
    taxRatePct?: boolean
    lineTotal?: boolean
    providerId?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceLine$serviceArgs<ExtArgs>
    product?: boolean | InvoiceLine$productArgs<ExtArgs>
    provider?: boolean | InvoiceLine$providerArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    lineNo?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPct?: boolean
    taxRatePct?: boolean
    lineTotal?: boolean
    providerId?: boolean
  }

  export type InvoiceLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "lineNo" | "itemType" | "serviceId" | "productId" | "description" | "qty" | "unitPrice" | "discountPct" | "taxRatePct" | "lineTotal" | "providerId", ExtArgs["result"]["invoiceLine"]>
  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceLine$serviceArgs<ExtArgs>
    product?: boolean | InvoiceLine$productArgs<ExtArgs>
    provider?: boolean | InvoiceLine$providerArgs<ExtArgs>
    commission?: boolean | InvoiceLine$commissionArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceLine$serviceArgs<ExtArgs>
    product?: boolean | InvoiceLine$productArgs<ExtArgs>
    provider?: boolean | InvoiceLine$providerArgs<ExtArgs>
  }
  export type InvoiceLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceLine$serviceArgs<ExtArgs>
    product?: boolean | InvoiceLine$productArgs<ExtArgs>
    provider?: boolean | InvoiceLine$providerArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      product: Prisma.$InventoryProductPayload<ExtArgs> | null
      provider: Prisma.$ProviderPayload<ExtArgs> | null
      commission: Prisma.$ProviderCommissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      lineNo: number
      itemType: $Enums.ItemType
      serviceId: string | null
      productId: string | null
      description: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      discountPct: Prisma.Decimal
      taxRatePct: Prisma.Decimal
      lineTotal: Prisma.Decimal
      providerId: string | null
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines and returns the data updated in the database.
     * @param {InvoiceLineUpdateManyAndReturnArgs} args - Arguments to update many InvoiceLines.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceLineUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends InvoiceLine$serviceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLine$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends InvoiceLine$productArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLine$productArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    provider<T extends InvoiceLine$providerArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLine$providerArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    commission<T extends InvoiceLine$commissionArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLine$commissionArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */
  interface InvoiceLineFieldRefs {
    readonly id: FieldRef<"InvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'String'>
    readonly lineNo: FieldRef<"InvoiceLine", 'Int'>
    readonly itemType: FieldRef<"InvoiceLine", 'ItemType'>
    readonly serviceId: FieldRef<"InvoiceLine", 'String'>
    readonly productId: FieldRef<"InvoiceLine", 'String'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly qty: FieldRef<"InvoiceLine", 'Decimal'>
    readonly unitPrice: FieldRef<"InvoiceLine", 'Decimal'>
    readonly discountPct: FieldRef<"InvoiceLine", 'Decimal'>
    readonly taxRatePct: FieldRef<"InvoiceLine", 'Decimal'>
    readonly lineTotal: FieldRef<"InvoiceLine", 'Decimal'>
    readonly providerId: FieldRef<"InvoiceLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to update.
     */
    limit?: number
  }

  /**
   * InvoiceLine updateManyAndReturn
   */
  export type InvoiceLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to delete.
     */
    limit?: number
  }

  /**
   * InvoiceLine.service
   */
  export type InvoiceLine$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * InvoiceLine.product
   */
  export type InvoiceLine$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    where?: InventoryProductWhereInput
  }

  /**
   * InvoiceLine.provider
   */
  export type InvoiceLine$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
  }

  /**
   * InvoiceLine.commission
   */
  export type InvoiceLine$commissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    where?: ProviderCommissionWhereInput
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model ProviderCommission
   */

  export type AggregateProviderCommission = {
    _count: ProviderCommissionCountAggregateOutputType | null
    _avg: ProviderCommissionAvgAggregateOutputType | null
    _sum: ProviderCommissionSumAggregateOutputType | null
    _min: ProviderCommissionMinAggregateOutputType | null
    _max: ProviderCommissionMaxAggregateOutputType | null
  }

  export type ProviderCommissionAvgAggregateOutputType = {
    baseAmount: Decimal | null
    ratePct: Decimal | null
    commissionAmount: Decimal | null
  }

  export type ProviderCommissionSumAggregateOutputType = {
    baseAmount: Decimal | null
    ratePct: Decimal | null
    commissionAmount: Decimal | null
  }

  export type ProviderCommissionMinAggregateOutputType = {
    id: string | null
    invoiceLineId: string | null
    providerId: string | null
    baseAmount: Decimal | null
    ratePct: Decimal | null
    commissionAmount: Decimal | null
    isPaid: boolean | null
  }

  export type ProviderCommissionMaxAggregateOutputType = {
    id: string | null
    invoiceLineId: string | null
    providerId: string | null
    baseAmount: Decimal | null
    ratePct: Decimal | null
    commissionAmount: Decimal | null
    isPaid: boolean | null
  }

  export type ProviderCommissionCountAggregateOutputType = {
    id: number
    invoiceLineId: number
    providerId: number
    baseAmount: number
    ratePct: number
    commissionAmount: number
    isPaid: number
    _all: number
  }


  export type ProviderCommissionAvgAggregateInputType = {
    baseAmount?: true
    ratePct?: true
    commissionAmount?: true
  }

  export type ProviderCommissionSumAggregateInputType = {
    baseAmount?: true
    ratePct?: true
    commissionAmount?: true
  }

  export type ProviderCommissionMinAggregateInputType = {
    id?: true
    invoiceLineId?: true
    providerId?: true
    baseAmount?: true
    ratePct?: true
    commissionAmount?: true
    isPaid?: true
  }

  export type ProviderCommissionMaxAggregateInputType = {
    id?: true
    invoiceLineId?: true
    providerId?: true
    baseAmount?: true
    ratePct?: true
    commissionAmount?: true
    isPaid?: true
  }

  export type ProviderCommissionCountAggregateInputType = {
    id?: true
    invoiceLineId?: true
    providerId?: true
    baseAmount?: true
    ratePct?: true
    commissionAmount?: true
    isPaid?: true
    _all?: true
  }

  export type ProviderCommissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderCommission to aggregate.
     */
    where?: ProviderCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCommissions to fetch.
     */
    orderBy?: ProviderCommissionOrderByWithRelationInput | ProviderCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderCommissions
    **/
    _count?: true | ProviderCommissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderCommissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderCommissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderCommissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderCommissionMaxAggregateInputType
  }

  export type GetProviderCommissionAggregateType<T extends ProviderCommissionAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderCommission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderCommission[P]>
      : GetScalarType<T[P], AggregateProviderCommission[P]>
  }




  export type ProviderCommissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderCommissionWhereInput
    orderBy?: ProviderCommissionOrderByWithAggregationInput | ProviderCommissionOrderByWithAggregationInput[]
    by: ProviderCommissionScalarFieldEnum[] | ProviderCommissionScalarFieldEnum
    having?: ProviderCommissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCommissionCountAggregateInputType | true
    _avg?: ProviderCommissionAvgAggregateInputType
    _sum?: ProviderCommissionSumAggregateInputType
    _min?: ProviderCommissionMinAggregateInputType
    _max?: ProviderCommissionMaxAggregateInputType
  }

  export type ProviderCommissionGroupByOutputType = {
    id: string
    invoiceLineId: string
    providerId: string
    baseAmount: Decimal
    ratePct: Decimal
    commissionAmount: Decimal
    isPaid: boolean
    _count: ProviderCommissionCountAggregateOutputType | null
    _avg: ProviderCommissionAvgAggregateOutputType | null
    _sum: ProviderCommissionSumAggregateOutputType | null
    _min: ProviderCommissionMinAggregateOutputType | null
    _max: ProviderCommissionMaxAggregateOutputType | null
  }

  type GetProviderCommissionGroupByPayload<T extends ProviderCommissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderCommissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderCommissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderCommissionGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderCommissionGroupByOutputType[P]>
        }
      >
    >


  export type ProviderCommissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceLineId?: boolean
    providerId?: boolean
    baseAmount?: boolean
    ratePct?: boolean
    commissionAmount?: boolean
    isPaid?: boolean
    invoiceLine?: boolean | InvoiceLineDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerCommission"]>

  export type ProviderCommissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceLineId?: boolean
    providerId?: boolean
    baseAmount?: boolean
    ratePct?: boolean
    commissionAmount?: boolean
    isPaid?: boolean
    invoiceLine?: boolean | InvoiceLineDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerCommission"]>

  export type ProviderCommissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceLineId?: boolean
    providerId?: boolean
    baseAmount?: boolean
    ratePct?: boolean
    commissionAmount?: boolean
    isPaid?: boolean
    invoiceLine?: boolean | InvoiceLineDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerCommission"]>

  export type ProviderCommissionSelectScalar = {
    id?: boolean
    invoiceLineId?: boolean
    providerId?: boolean
    baseAmount?: boolean
    ratePct?: boolean
    commissionAmount?: boolean
    isPaid?: boolean
  }

  export type ProviderCommissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceLineId" | "providerId" | "baseAmount" | "ratePct" | "commissionAmount" | "isPaid", ExtArgs["result"]["providerCommission"]>
  export type ProviderCommissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceLine?: boolean | InvoiceLineDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ProviderCommissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceLine?: boolean | InvoiceLineDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ProviderCommissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceLine?: boolean | InvoiceLineDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $ProviderCommissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderCommission"
    objects: {
      invoiceLine: Prisma.$InvoiceLinePayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceLineId: string
      providerId: string
      baseAmount: Prisma.Decimal
      ratePct: Prisma.Decimal
      commissionAmount: Prisma.Decimal
      isPaid: boolean
    }, ExtArgs["result"]["providerCommission"]>
    composites: {}
  }

  type ProviderCommissionGetPayload<S extends boolean | null | undefined | ProviderCommissionDefaultArgs> = $Result.GetResult<Prisma.$ProviderCommissionPayload, S>

  type ProviderCommissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderCommissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCommissionCountAggregateInputType | true
    }

  export interface ProviderCommissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderCommission'], meta: { name: 'ProviderCommission' } }
    /**
     * Find zero or one ProviderCommission that matches the filter.
     * @param {ProviderCommissionFindUniqueArgs} args - Arguments to find a ProviderCommission
     * @example
     * // Get one ProviderCommission
     * const providerCommission = await prisma.providerCommission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderCommissionFindUniqueArgs>(args: SelectSubset<T, ProviderCommissionFindUniqueArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderCommission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderCommissionFindUniqueOrThrowArgs} args - Arguments to find a ProviderCommission
     * @example
     * // Get one ProviderCommission
     * const providerCommission = await prisma.providerCommission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderCommissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderCommissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderCommission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionFindFirstArgs} args - Arguments to find a ProviderCommission
     * @example
     * // Get one ProviderCommission
     * const providerCommission = await prisma.providerCommission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderCommissionFindFirstArgs>(args?: SelectSubset<T, ProviderCommissionFindFirstArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderCommission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionFindFirstOrThrowArgs} args - Arguments to find a ProviderCommission
     * @example
     * // Get one ProviderCommission
     * const providerCommission = await prisma.providerCommission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderCommissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderCommissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderCommissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderCommissions
     * const providerCommissions = await prisma.providerCommission.findMany()
     * 
     * // Get first 10 ProviderCommissions
     * const providerCommissions = await prisma.providerCommission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerCommissionWithIdOnly = await prisma.providerCommission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderCommissionFindManyArgs>(args?: SelectSubset<T, ProviderCommissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderCommission.
     * @param {ProviderCommissionCreateArgs} args - Arguments to create a ProviderCommission.
     * @example
     * // Create one ProviderCommission
     * const ProviderCommission = await prisma.providerCommission.create({
     *   data: {
     *     // ... data to create a ProviderCommission
     *   }
     * })
     * 
     */
    create<T extends ProviderCommissionCreateArgs>(args: SelectSubset<T, ProviderCommissionCreateArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderCommissions.
     * @param {ProviderCommissionCreateManyArgs} args - Arguments to create many ProviderCommissions.
     * @example
     * // Create many ProviderCommissions
     * const providerCommission = await prisma.providerCommission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCommissionCreateManyArgs>(args?: SelectSubset<T, ProviderCommissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderCommissions and returns the data saved in the database.
     * @param {ProviderCommissionCreateManyAndReturnArgs} args - Arguments to create many ProviderCommissions.
     * @example
     * // Create many ProviderCommissions
     * const providerCommission = await prisma.providerCommission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderCommissions and only return the `id`
     * const providerCommissionWithIdOnly = await prisma.providerCommission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCommissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCommissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderCommission.
     * @param {ProviderCommissionDeleteArgs} args - Arguments to delete one ProviderCommission.
     * @example
     * // Delete one ProviderCommission
     * const ProviderCommission = await prisma.providerCommission.delete({
     *   where: {
     *     // ... filter to delete one ProviderCommission
     *   }
     * })
     * 
     */
    delete<T extends ProviderCommissionDeleteArgs>(args: SelectSubset<T, ProviderCommissionDeleteArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderCommission.
     * @param {ProviderCommissionUpdateArgs} args - Arguments to update one ProviderCommission.
     * @example
     * // Update one ProviderCommission
     * const providerCommission = await prisma.providerCommission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderCommissionUpdateArgs>(args: SelectSubset<T, ProviderCommissionUpdateArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderCommissions.
     * @param {ProviderCommissionDeleteManyArgs} args - Arguments to filter ProviderCommissions to delete.
     * @example
     * // Delete a few ProviderCommissions
     * const { count } = await prisma.providerCommission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderCommissionDeleteManyArgs>(args?: SelectSubset<T, ProviderCommissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderCommissions
     * const providerCommission = await prisma.providerCommission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderCommissionUpdateManyArgs>(args: SelectSubset<T, ProviderCommissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderCommissions and returns the data updated in the database.
     * @param {ProviderCommissionUpdateManyAndReturnArgs} args - Arguments to update many ProviderCommissions.
     * @example
     * // Update many ProviderCommissions
     * const providerCommission = await prisma.providerCommission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderCommissions and only return the `id`
     * const providerCommissionWithIdOnly = await prisma.providerCommission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderCommissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderCommissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderCommission.
     * @param {ProviderCommissionUpsertArgs} args - Arguments to update or create a ProviderCommission.
     * @example
     * // Update or create a ProviderCommission
     * const providerCommission = await prisma.providerCommission.upsert({
     *   create: {
     *     // ... data to create a ProviderCommission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderCommission we want to update
     *   }
     * })
     */
    upsert<T extends ProviderCommissionUpsertArgs>(args: SelectSubset<T, ProviderCommissionUpsertArgs<ExtArgs>>): Prisma__ProviderCommissionClient<$Result.GetResult<Prisma.$ProviderCommissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionCountArgs} args - Arguments to filter ProviderCommissions to count.
     * @example
     * // Count the number of ProviderCommissions
     * const count = await prisma.providerCommission.count({
     *   where: {
     *     // ... the filter for the ProviderCommissions we want to count
     *   }
     * })
    **/
    count<T extends ProviderCommissionCountArgs>(
      args?: Subset<T, ProviderCommissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCommissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderCommissionAggregateArgs>(args: Subset<T, ProviderCommissionAggregateArgs>): Prisma.PrismaPromise<GetProviderCommissionAggregateType<T>>

    /**
     * Group by ProviderCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCommissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderCommissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderCommissionGroupByArgs['orderBy'] }
        : { orderBy?: ProviderCommissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderCommissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderCommissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderCommission model
   */
  readonly fields: ProviderCommissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderCommission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderCommissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoiceLine<T extends InvoiceLineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLineDefaultArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderCommission model
   */
  interface ProviderCommissionFieldRefs {
    readonly id: FieldRef<"ProviderCommission", 'String'>
    readonly invoiceLineId: FieldRef<"ProviderCommission", 'String'>
    readonly providerId: FieldRef<"ProviderCommission", 'String'>
    readonly baseAmount: FieldRef<"ProviderCommission", 'Decimal'>
    readonly ratePct: FieldRef<"ProviderCommission", 'Decimal'>
    readonly commissionAmount: FieldRef<"ProviderCommission", 'Decimal'>
    readonly isPaid: FieldRef<"ProviderCommission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ProviderCommission findUnique
   */
  export type ProviderCommissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCommission to fetch.
     */
    where: ProviderCommissionWhereUniqueInput
  }

  /**
   * ProviderCommission findUniqueOrThrow
   */
  export type ProviderCommissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCommission to fetch.
     */
    where: ProviderCommissionWhereUniqueInput
  }

  /**
   * ProviderCommission findFirst
   */
  export type ProviderCommissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCommission to fetch.
     */
    where?: ProviderCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCommissions to fetch.
     */
    orderBy?: ProviderCommissionOrderByWithRelationInput | ProviderCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderCommissions.
     */
    cursor?: ProviderCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderCommissions.
     */
    distinct?: ProviderCommissionScalarFieldEnum | ProviderCommissionScalarFieldEnum[]
  }

  /**
   * ProviderCommission findFirstOrThrow
   */
  export type ProviderCommissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCommission to fetch.
     */
    where?: ProviderCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCommissions to fetch.
     */
    orderBy?: ProviderCommissionOrderByWithRelationInput | ProviderCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderCommissions.
     */
    cursor?: ProviderCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderCommissions.
     */
    distinct?: ProviderCommissionScalarFieldEnum | ProviderCommissionScalarFieldEnum[]
  }

  /**
   * ProviderCommission findMany
   */
  export type ProviderCommissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCommissions to fetch.
     */
    where?: ProviderCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCommissions to fetch.
     */
    orderBy?: ProviderCommissionOrderByWithRelationInput | ProviderCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderCommissions.
     */
    cursor?: ProviderCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCommissions.
     */
    skip?: number
    distinct?: ProviderCommissionScalarFieldEnum | ProviderCommissionScalarFieldEnum[]
  }

  /**
   * ProviderCommission create
   */
  export type ProviderCommissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderCommission.
     */
    data: XOR<ProviderCommissionCreateInput, ProviderCommissionUncheckedCreateInput>
  }

  /**
   * ProviderCommission createMany
   */
  export type ProviderCommissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderCommissions.
     */
    data: ProviderCommissionCreateManyInput | ProviderCommissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderCommission createManyAndReturn
   */
  export type ProviderCommissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderCommissions.
     */
    data: ProviderCommissionCreateManyInput | ProviderCommissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderCommission update
   */
  export type ProviderCommissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderCommission.
     */
    data: XOR<ProviderCommissionUpdateInput, ProviderCommissionUncheckedUpdateInput>
    /**
     * Choose, which ProviderCommission to update.
     */
    where: ProviderCommissionWhereUniqueInput
  }

  /**
   * ProviderCommission updateMany
   */
  export type ProviderCommissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderCommissions.
     */
    data: XOR<ProviderCommissionUpdateManyMutationInput, ProviderCommissionUncheckedUpdateManyInput>
    /**
     * Filter which ProviderCommissions to update
     */
    where?: ProviderCommissionWhereInput
    /**
     * Limit how many ProviderCommissions to update.
     */
    limit?: number
  }

  /**
   * ProviderCommission updateManyAndReturn
   */
  export type ProviderCommissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * The data used to update ProviderCommissions.
     */
    data: XOR<ProviderCommissionUpdateManyMutationInput, ProviderCommissionUncheckedUpdateManyInput>
    /**
     * Filter which ProviderCommissions to update
     */
    where?: ProviderCommissionWhereInput
    /**
     * Limit how many ProviderCommissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderCommission upsert
   */
  export type ProviderCommissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderCommission to update in case it exists.
     */
    where: ProviderCommissionWhereUniqueInput
    /**
     * In case the ProviderCommission found by the `where` argument doesn't exist, create a new ProviderCommission with this data.
     */
    create: XOR<ProviderCommissionCreateInput, ProviderCommissionUncheckedCreateInput>
    /**
     * In case the ProviderCommission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderCommissionUpdateInput, ProviderCommissionUncheckedUpdateInput>
  }

  /**
   * ProviderCommission delete
   */
  export type ProviderCommissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
    /**
     * Filter which ProviderCommission to delete.
     */
    where: ProviderCommissionWhereUniqueInput
  }

  /**
   * ProviderCommission deleteMany
   */
  export type ProviderCommissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderCommissions to delete
     */
    where?: ProviderCommissionWhereInput
    /**
     * Limit how many ProviderCommissions to delete.
     */
    limit?: number
  }

  /**
   * ProviderCommission without action
   */
  export type ProviderCommissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCommission
     */
    select?: ProviderCommissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderCommission
     */
    omit?: ProviderCommissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderCommissionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
    exchangeRate: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
    exchangeRate: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    method: $Enums.PaymentMethod | null
    transferStatus: $Enums.TransferStatus | null
    amount: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    reference: string | null
    posTerminalId: string | null
    createdById: string | null
    requestContextId: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    method: $Enums.PaymentMethod | null
    transferStatus: $Enums.TransferStatus | null
    amount: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    reference: string | null
    posTerminalId: string | null
    createdById: string | null
    requestContextId: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    method: number
    transferStatus: number
    amount: number
    currency: number
    exchangeRate: number
    reference: number
    posTerminalId: number
    createdById: number
    requestContextId: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    exchangeRate?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    exchangeRate?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    transferStatus?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    reference?: true
    posTerminalId?: true
    createdById?: true
    requestContextId?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    transferStatus?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    reference?: true
    posTerminalId?: true
    createdById?: true
    requestContextId?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    transferStatus?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    reference?: true
    posTerminalId?: true
    createdById?: true
    requestContextId?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus: $Enums.TransferStatus | null
    amount: Decimal
    currency: string
    exchangeRate: Decimal | null
    reference: string | null
    posTerminalId: string | null
    createdById: string
    requestContextId: string
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    transferStatus?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    reference?: boolean
    posTerminalId?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    posTerminal?: boolean | Payment$posTerminalArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    transferStatus?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    reference?: boolean
    posTerminalId?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    posTerminal?: boolean | Payment$posTerminalArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    transferStatus?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    reference?: boolean
    posTerminalId?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    posTerminal?: boolean | Payment$posTerminalArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    transferStatus?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    reference?: boolean
    posTerminalId?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "method" | "transferStatus" | "amount" | "currency" | "exchangeRate" | "reference" | "posTerminalId" | "createdById" | "requestContextId" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    posTerminal?: boolean | Payment$posTerminalArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    posTerminal?: boolean | Payment$posTerminalArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    posTerminal?: boolean | Payment$posTerminalArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      posTerminal: Prisma.$PosTerminalPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      method: $Enums.PaymentMethod
      transferStatus: $Enums.TransferStatus | null
      amount: Prisma.Decimal
      currency: string
      exchangeRate: Prisma.Decimal | null
      reference: string | null
      posTerminalId: string | null
      createdById: string
      requestContextId: string
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posTerminal<T extends Payment$posTerminalArgs<ExtArgs> = {}>(args?: Subset<T, Payment$posTerminalArgs<ExtArgs>>): Prisma__PosTerminalClient<$Result.GetResult<Prisma.$PosTerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly transferStatus: FieldRef<"Payment", 'TransferStatus'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly exchangeRate: FieldRef<"Payment", 'Decimal'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly posTerminalId: FieldRef<"Payment", 'String'>
    readonly createdById: FieldRef<"Payment", 'String'>
    readonly requestContextId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.posTerminal
   */
  export type Payment$posTerminalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosTerminal
     */
    select?: PosTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosTerminal
     */
    omit?: PosTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosTerminalInclude<ExtArgs> | null
    where?: PosTerminalWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model CashSession
   */

  export type AggregateCashSession = {
    _count: CashSessionCountAggregateOutputType | null
    _avg: CashSessionAvgAggregateOutputType | null
    _sum: CashSessionSumAggregateOutputType | null
    _min: CashSessionMinAggregateOutputType | null
    _max: CashSessionMaxAggregateOutputType | null
  }

  export type CashSessionAvgAggregateOutputType = {
    openingFloat: Decimal | null
    declaredTotal: Decimal | null
    systemTotal: Decimal | null
    variance: Decimal | null
  }

  export type CashSessionSumAggregateOutputType = {
    openingFloat: Decimal | null
    declaredTotal: Decimal | null
    systemTotal: Decimal | null
    variance: Decimal | null
  }

  export type CashSessionMinAggregateOutputType = {
    id: string | null
    registerId: string | null
    openedById: string | null
    openedAt: Date | null
    openingFloat: Decimal | null
    closedById: string | null
    closedAt: Date | null
    declaredTotal: Decimal | null
    systemTotal: Decimal | null
    variance: Decimal | null
  }

  export type CashSessionMaxAggregateOutputType = {
    id: string | null
    registerId: string | null
    openedById: string | null
    openedAt: Date | null
    openingFloat: Decimal | null
    closedById: string | null
    closedAt: Date | null
    declaredTotal: Decimal | null
    systemTotal: Decimal | null
    variance: Decimal | null
  }

  export type CashSessionCountAggregateOutputType = {
    id: number
    registerId: number
    openedById: number
    openedAt: number
    openingFloat: number
    closedById: number
    closedAt: number
    declaredTotal: number
    systemTotal: number
    variance: number
    _all: number
  }


  export type CashSessionAvgAggregateInputType = {
    openingFloat?: true
    declaredTotal?: true
    systemTotal?: true
    variance?: true
  }

  export type CashSessionSumAggregateInputType = {
    openingFloat?: true
    declaredTotal?: true
    systemTotal?: true
    variance?: true
  }

  export type CashSessionMinAggregateInputType = {
    id?: true
    registerId?: true
    openedById?: true
    openedAt?: true
    openingFloat?: true
    closedById?: true
    closedAt?: true
    declaredTotal?: true
    systemTotal?: true
    variance?: true
  }

  export type CashSessionMaxAggregateInputType = {
    id?: true
    registerId?: true
    openedById?: true
    openedAt?: true
    openingFloat?: true
    closedById?: true
    closedAt?: true
    declaredTotal?: true
    systemTotal?: true
    variance?: true
  }

  export type CashSessionCountAggregateInputType = {
    id?: true
    registerId?: true
    openedById?: true
    openedAt?: true
    openingFloat?: true
    closedById?: true
    closedAt?: true
    declaredTotal?: true
    systemTotal?: true
    variance?: true
    _all?: true
  }

  export type CashSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashSession to aggregate.
     */
    where?: CashSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashSessions to fetch.
     */
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashSessions
    **/
    _count?: true | CashSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashSessionMaxAggregateInputType
  }

  export type GetCashSessionAggregateType<T extends CashSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashSession[P]>
      : GetScalarType<T[P], AggregateCashSession[P]>
  }




  export type CashSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashSessionWhereInput
    orderBy?: CashSessionOrderByWithAggregationInput | CashSessionOrderByWithAggregationInput[]
    by: CashSessionScalarFieldEnum[] | CashSessionScalarFieldEnum
    having?: CashSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashSessionCountAggregateInputType | true
    _avg?: CashSessionAvgAggregateInputType
    _sum?: CashSessionSumAggregateInputType
    _min?: CashSessionMinAggregateInputType
    _max?: CashSessionMaxAggregateInputType
  }

  export type CashSessionGroupByOutputType = {
    id: string
    registerId: string
    openedById: string
    openedAt: Date
    openingFloat: Decimal
    closedById: string | null
    closedAt: Date | null
    declaredTotal: Decimal | null
    systemTotal: Decimal | null
    variance: Decimal | null
    _count: CashSessionCountAggregateOutputType | null
    _avg: CashSessionAvgAggregateOutputType | null
    _sum: CashSessionSumAggregateOutputType | null
    _min: CashSessionMinAggregateOutputType | null
    _max: CashSessionMaxAggregateOutputType | null
  }

  type GetCashSessionGroupByPayload<T extends CashSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CashSessionGroupByOutputType[P]>
        }
      >
    >


  export type CashSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registerId?: boolean
    openedById?: boolean
    openedAt?: boolean
    openingFloat?: boolean
    closedById?: boolean
    closedAt?: boolean
    declaredTotal?: boolean
    systemTotal?: boolean
    variance?: boolean
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    closedBy?: boolean | CashSession$closedByArgs<ExtArgs>
    movements?: boolean | CashSession$movementsArgs<ExtArgs>
    _count?: boolean | CashSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashSession"]>

  export type CashSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registerId?: boolean
    openedById?: boolean
    openedAt?: boolean
    openingFloat?: boolean
    closedById?: boolean
    closedAt?: boolean
    declaredTotal?: boolean
    systemTotal?: boolean
    variance?: boolean
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    closedBy?: boolean | CashSession$closedByArgs<ExtArgs>
  }, ExtArgs["result"]["cashSession"]>

  export type CashSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registerId?: boolean
    openedById?: boolean
    openedAt?: boolean
    openingFloat?: boolean
    closedById?: boolean
    closedAt?: boolean
    declaredTotal?: boolean
    systemTotal?: boolean
    variance?: boolean
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    closedBy?: boolean | CashSession$closedByArgs<ExtArgs>
  }, ExtArgs["result"]["cashSession"]>

  export type CashSessionSelectScalar = {
    id?: boolean
    registerId?: boolean
    openedById?: boolean
    openedAt?: boolean
    openingFloat?: boolean
    closedById?: boolean
    closedAt?: boolean
    declaredTotal?: boolean
    systemTotal?: boolean
    variance?: boolean
  }

  export type CashSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registerId" | "openedById" | "openedAt" | "openingFloat" | "closedById" | "closedAt" | "declaredTotal" | "systemTotal" | "variance", ExtArgs["result"]["cashSession"]>
  export type CashSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    closedBy?: boolean | CashSession$closedByArgs<ExtArgs>
    movements?: boolean | CashSession$movementsArgs<ExtArgs>
    _count?: boolean | CashSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    closedBy?: boolean | CashSession$closedByArgs<ExtArgs>
  }
  export type CashSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    closedBy?: boolean | CashSession$closedByArgs<ExtArgs>
  }

  export type $CashSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashSession"
    objects: {
      register: Prisma.$CashRegisterPayload<ExtArgs>
      openedBy: Prisma.$UserPayload<ExtArgs>
      closedBy: Prisma.$UserPayload<ExtArgs> | null
      movements: Prisma.$CashMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      registerId: string
      openedById: string
      openedAt: Date
      openingFloat: Prisma.Decimal
      closedById: string | null
      closedAt: Date | null
      declaredTotal: Prisma.Decimal | null
      systemTotal: Prisma.Decimal | null
      variance: Prisma.Decimal | null
    }, ExtArgs["result"]["cashSession"]>
    composites: {}
  }

  type CashSessionGetPayload<S extends boolean | null | undefined | CashSessionDefaultArgs> = $Result.GetResult<Prisma.$CashSessionPayload, S>

  type CashSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashSessionCountAggregateInputType | true
    }

  export interface CashSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashSession'], meta: { name: 'CashSession' } }
    /**
     * Find zero or one CashSession that matches the filter.
     * @param {CashSessionFindUniqueArgs} args - Arguments to find a CashSession
     * @example
     * // Get one CashSession
     * const cashSession = await prisma.cashSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashSessionFindUniqueArgs>(args: SelectSubset<T, CashSessionFindUniqueArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashSessionFindUniqueOrThrowArgs} args - Arguments to find a CashSession
     * @example
     * // Get one CashSession
     * const cashSession = await prisma.cashSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionFindFirstArgs} args - Arguments to find a CashSession
     * @example
     * // Get one CashSession
     * const cashSession = await prisma.cashSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashSessionFindFirstArgs>(args?: SelectSubset<T, CashSessionFindFirstArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionFindFirstOrThrowArgs} args - Arguments to find a CashSession
     * @example
     * // Get one CashSession
     * const cashSession = await prisma.cashSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashSessions
     * const cashSessions = await prisma.cashSession.findMany()
     * 
     * // Get first 10 CashSessions
     * const cashSessions = await prisma.cashSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashSessionWithIdOnly = await prisma.cashSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashSessionFindManyArgs>(args?: SelectSubset<T, CashSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashSession.
     * @param {CashSessionCreateArgs} args - Arguments to create a CashSession.
     * @example
     * // Create one CashSession
     * const CashSession = await prisma.cashSession.create({
     *   data: {
     *     // ... data to create a CashSession
     *   }
     * })
     * 
     */
    create<T extends CashSessionCreateArgs>(args: SelectSubset<T, CashSessionCreateArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashSessions.
     * @param {CashSessionCreateManyArgs} args - Arguments to create many CashSessions.
     * @example
     * // Create many CashSessions
     * const cashSession = await prisma.cashSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashSessionCreateManyArgs>(args?: SelectSubset<T, CashSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashSessions and returns the data saved in the database.
     * @param {CashSessionCreateManyAndReturnArgs} args - Arguments to create many CashSessions.
     * @example
     * // Create many CashSessions
     * const cashSession = await prisma.cashSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashSessions and only return the `id`
     * const cashSessionWithIdOnly = await prisma.cashSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashSession.
     * @param {CashSessionDeleteArgs} args - Arguments to delete one CashSession.
     * @example
     * // Delete one CashSession
     * const CashSession = await prisma.cashSession.delete({
     *   where: {
     *     // ... filter to delete one CashSession
     *   }
     * })
     * 
     */
    delete<T extends CashSessionDeleteArgs>(args: SelectSubset<T, CashSessionDeleteArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashSession.
     * @param {CashSessionUpdateArgs} args - Arguments to update one CashSession.
     * @example
     * // Update one CashSession
     * const cashSession = await prisma.cashSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashSessionUpdateArgs>(args: SelectSubset<T, CashSessionUpdateArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashSessions.
     * @param {CashSessionDeleteManyArgs} args - Arguments to filter CashSessions to delete.
     * @example
     * // Delete a few CashSessions
     * const { count } = await prisma.cashSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashSessionDeleteManyArgs>(args?: SelectSubset<T, CashSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashSessions
     * const cashSession = await prisma.cashSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashSessionUpdateManyArgs>(args: SelectSubset<T, CashSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashSessions and returns the data updated in the database.
     * @param {CashSessionUpdateManyAndReturnArgs} args - Arguments to update many CashSessions.
     * @example
     * // Update many CashSessions
     * const cashSession = await prisma.cashSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashSessions and only return the `id`
     * const cashSessionWithIdOnly = await prisma.cashSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CashSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashSession.
     * @param {CashSessionUpsertArgs} args - Arguments to update or create a CashSession.
     * @example
     * // Update or create a CashSession
     * const cashSession = await prisma.cashSession.upsert({
     *   create: {
     *     // ... data to create a CashSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashSession we want to update
     *   }
     * })
     */
    upsert<T extends CashSessionUpsertArgs>(args: SelectSubset<T, CashSessionUpsertArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionCountArgs} args - Arguments to filter CashSessions to count.
     * @example
     * // Count the number of CashSessions
     * const count = await prisma.cashSession.count({
     *   where: {
     *     // ... the filter for the CashSessions we want to count
     *   }
     * })
    **/
    count<T extends CashSessionCountArgs>(
      args?: Subset<T, CashSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashSessionAggregateArgs>(args: Subset<T, CashSessionAggregateArgs>): Prisma.PrismaPromise<GetCashSessionAggregateType<T>>

    /**
     * Group by CashSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashSessionGroupByArgs['orderBy'] }
        : { orderBy?: CashSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashSession model
   */
  readonly fields: CashSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    register<T extends CashRegisterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashRegisterDefaultArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    openedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    closedBy<T extends CashSession$closedByArgs<ExtArgs> = {}>(args?: Subset<T, CashSession$closedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    movements<T extends CashSession$movementsArgs<ExtArgs> = {}>(args?: Subset<T, CashSession$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashSession model
   */
  interface CashSessionFieldRefs {
    readonly id: FieldRef<"CashSession", 'String'>
    readonly registerId: FieldRef<"CashSession", 'String'>
    readonly openedById: FieldRef<"CashSession", 'String'>
    readonly openedAt: FieldRef<"CashSession", 'DateTime'>
    readonly openingFloat: FieldRef<"CashSession", 'Decimal'>
    readonly closedById: FieldRef<"CashSession", 'String'>
    readonly closedAt: FieldRef<"CashSession", 'DateTime'>
    readonly declaredTotal: FieldRef<"CashSession", 'Decimal'>
    readonly systemTotal: FieldRef<"CashSession", 'Decimal'>
    readonly variance: FieldRef<"CashSession", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CashSession findUnique
   */
  export type CashSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * Filter, which CashSession to fetch.
     */
    where: CashSessionWhereUniqueInput
  }

  /**
   * CashSession findUniqueOrThrow
   */
  export type CashSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * Filter, which CashSession to fetch.
     */
    where: CashSessionWhereUniqueInput
  }

  /**
   * CashSession findFirst
   */
  export type CashSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * Filter, which CashSession to fetch.
     */
    where?: CashSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashSessions to fetch.
     */
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashSessions.
     */
    cursor?: CashSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashSessions.
     */
    distinct?: CashSessionScalarFieldEnum | CashSessionScalarFieldEnum[]
  }

  /**
   * CashSession findFirstOrThrow
   */
  export type CashSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * Filter, which CashSession to fetch.
     */
    where?: CashSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashSessions to fetch.
     */
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashSessions.
     */
    cursor?: CashSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashSessions.
     */
    distinct?: CashSessionScalarFieldEnum | CashSessionScalarFieldEnum[]
  }

  /**
   * CashSession findMany
   */
  export type CashSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * Filter, which CashSessions to fetch.
     */
    where?: CashSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashSessions to fetch.
     */
    orderBy?: CashSessionOrderByWithRelationInput | CashSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashSessions.
     */
    cursor?: CashSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashSessions.
     */
    skip?: number
    distinct?: CashSessionScalarFieldEnum | CashSessionScalarFieldEnum[]
  }

  /**
   * CashSession create
   */
  export type CashSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashSession.
     */
    data: XOR<CashSessionCreateInput, CashSessionUncheckedCreateInput>
  }

  /**
   * CashSession createMany
   */
  export type CashSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashSessions.
     */
    data: CashSessionCreateManyInput | CashSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashSession createManyAndReturn
   */
  export type CashSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CashSessions.
     */
    data: CashSessionCreateManyInput | CashSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashSession update
   */
  export type CashSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashSession.
     */
    data: XOR<CashSessionUpdateInput, CashSessionUncheckedUpdateInput>
    /**
     * Choose, which CashSession to update.
     */
    where: CashSessionWhereUniqueInput
  }

  /**
   * CashSession updateMany
   */
  export type CashSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashSessions.
     */
    data: XOR<CashSessionUpdateManyMutationInput, CashSessionUncheckedUpdateManyInput>
    /**
     * Filter which CashSessions to update
     */
    where?: CashSessionWhereInput
    /**
     * Limit how many CashSessions to update.
     */
    limit?: number
  }

  /**
   * CashSession updateManyAndReturn
   */
  export type CashSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * The data used to update CashSessions.
     */
    data: XOR<CashSessionUpdateManyMutationInput, CashSessionUncheckedUpdateManyInput>
    /**
     * Filter which CashSessions to update
     */
    where?: CashSessionWhereInput
    /**
     * Limit how many CashSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashSession upsert
   */
  export type CashSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashSession to update in case it exists.
     */
    where: CashSessionWhereUniqueInput
    /**
     * In case the CashSession found by the `where` argument doesn't exist, create a new CashSession with this data.
     */
    create: XOR<CashSessionCreateInput, CashSessionUncheckedCreateInput>
    /**
     * In case the CashSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashSessionUpdateInput, CashSessionUncheckedUpdateInput>
  }

  /**
   * CashSession delete
   */
  export type CashSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
    /**
     * Filter which CashSession to delete.
     */
    where: CashSessionWhereUniqueInput
  }

  /**
   * CashSession deleteMany
   */
  export type CashSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashSessions to delete
     */
    where?: CashSessionWhereInput
    /**
     * Limit how many CashSessions to delete.
     */
    limit?: number
  }

  /**
   * CashSession.closedBy
   */
  export type CashSession$closedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CashSession.movements
   */
  export type CashSession$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    cursor?: CashMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }

  /**
   * CashSession without action
   */
  export type CashSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashSession
     */
    select?: CashSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashSession
     */
    omit?: CashSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashSessionInclude<ExtArgs> | null
  }


  /**
   * Model CashMovement
   */

  export type AggregateCashMovement = {
    _count: CashMovementCountAggregateOutputType | null
    _avg: CashMovementAvgAggregateOutputType | null
    _sum: CashMovementSumAggregateOutputType | null
    _min: CashMovementMinAggregateOutputType | null
    _max: CashMovementMaxAggregateOutputType | null
  }

  export type CashMovementAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashMovementSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashMovementMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.CashMovementType | null
    amount: Decimal | null
    reference: string | null
    createdById: string | null
    requestContextId: string | null
    createdAt: Date | null
  }

  export type CashMovementMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.CashMovementType | null
    amount: Decimal | null
    reference: string | null
    createdById: string | null
    requestContextId: string | null
    createdAt: Date | null
  }

  export type CashMovementCountAggregateOutputType = {
    id: number
    sessionId: number
    type: number
    amount: number
    reference: number
    createdById: number
    requestContextId: number
    createdAt: number
    _all: number
  }


  export type CashMovementAvgAggregateInputType = {
    amount?: true
  }

  export type CashMovementSumAggregateInputType = {
    amount?: true
  }

  export type CashMovementMinAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    amount?: true
    reference?: true
    createdById?: true
    requestContextId?: true
    createdAt?: true
  }

  export type CashMovementMaxAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    amount?: true
    reference?: true
    createdById?: true
    requestContextId?: true
    createdAt?: true
  }

  export type CashMovementCountAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    amount?: true
    reference?: true
    createdById?: true
    requestContextId?: true
    createdAt?: true
    _all?: true
  }

  export type CashMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashMovement to aggregate.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashMovements
    **/
    _count?: true | CashMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashMovementMaxAggregateInputType
  }

  export type GetCashMovementAggregateType<T extends CashMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateCashMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashMovement[P]>
      : GetScalarType<T[P], AggregateCashMovement[P]>
  }




  export type CashMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashMovementWhereInput
    orderBy?: CashMovementOrderByWithAggregationInput | CashMovementOrderByWithAggregationInput[]
    by: CashMovementScalarFieldEnum[] | CashMovementScalarFieldEnum
    having?: CashMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashMovementCountAggregateInputType | true
    _avg?: CashMovementAvgAggregateInputType
    _sum?: CashMovementSumAggregateInputType
    _min?: CashMovementMinAggregateInputType
    _max?: CashMovementMaxAggregateInputType
  }

  export type CashMovementGroupByOutputType = {
    id: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal
    reference: string | null
    createdById: string
    requestContextId: string
    createdAt: Date
    _count: CashMovementCountAggregateOutputType | null
    _avg: CashMovementAvgAggregateOutputType | null
    _sum: CashMovementSumAggregateOutputType | null
    _min: CashMovementMinAggregateOutputType | null
    _max: CashMovementMaxAggregateOutputType | null
  }

  type GetCashMovementGroupByPayload<T extends CashMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashMovementGroupByOutputType[P]>
            : GetScalarType<T[P], CashMovementGroupByOutputType[P]>
        }
      >
    >


  export type CashMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
    session?: boolean | CashSessionDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashMovement"]>

  export type CashMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
    session?: boolean | CashSessionDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashMovement"]>

  export type CashMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
    session?: boolean | CashSessionDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashMovement"]>

  export type CashMovementSelectScalar = {
    id?: boolean
    sessionId?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    createdById?: boolean
    requestContextId?: boolean
    createdAt?: boolean
  }

  export type CashMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "type" | "amount" | "reference" | "createdById" | "requestContextId" | "createdAt", ExtArgs["result"]["cashMovement"]>
  export type CashMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CashSessionDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type CashMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CashSessionDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type CashMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CashSessionDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $CashMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashMovement"
    objects: {
      session: Prisma.$CashSessionPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      type: $Enums.CashMovementType
      amount: Prisma.Decimal
      reference: string | null
      createdById: string
      requestContextId: string
      createdAt: Date
    }, ExtArgs["result"]["cashMovement"]>
    composites: {}
  }

  type CashMovementGetPayload<S extends boolean | null | undefined | CashMovementDefaultArgs> = $Result.GetResult<Prisma.$CashMovementPayload, S>

  type CashMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashMovementCountAggregateInputType | true
    }

  export interface CashMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashMovement'], meta: { name: 'CashMovement' } }
    /**
     * Find zero or one CashMovement that matches the filter.
     * @param {CashMovementFindUniqueArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashMovementFindUniqueArgs>(args: SelectSubset<T, CashMovementFindUniqueArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashMovementFindUniqueOrThrowArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, CashMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementFindFirstArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashMovementFindFirstArgs>(args?: SelectSubset<T, CashMovementFindFirstArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementFindFirstOrThrowArgs} args - Arguments to find a CashMovement
     * @example
     * // Get one CashMovement
     * const cashMovement = await prisma.cashMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, CashMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashMovements
     * const cashMovements = await prisma.cashMovement.findMany()
     * 
     * // Get first 10 CashMovements
     * const cashMovements = await prisma.cashMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashMovementWithIdOnly = await prisma.cashMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashMovementFindManyArgs>(args?: SelectSubset<T, CashMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashMovement.
     * @param {CashMovementCreateArgs} args - Arguments to create a CashMovement.
     * @example
     * // Create one CashMovement
     * const CashMovement = await prisma.cashMovement.create({
     *   data: {
     *     // ... data to create a CashMovement
     *   }
     * })
     * 
     */
    create<T extends CashMovementCreateArgs>(args: SelectSubset<T, CashMovementCreateArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashMovements.
     * @param {CashMovementCreateManyArgs} args - Arguments to create many CashMovements.
     * @example
     * // Create many CashMovements
     * const cashMovement = await prisma.cashMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashMovementCreateManyArgs>(args?: SelectSubset<T, CashMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashMovements and returns the data saved in the database.
     * @param {CashMovementCreateManyAndReturnArgs} args - Arguments to create many CashMovements.
     * @example
     * // Create many CashMovements
     * const cashMovement = await prisma.cashMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashMovements and only return the `id`
     * const cashMovementWithIdOnly = await prisma.cashMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, CashMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashMovement.
     * @param {CashMovementDeleteArgs} args - Arguments to delete one CashMovement.
     * @example
     * // Delete one CashMovement
     * const CashMovement = await prisma.cashMovement.delete({
     *   where: {
     *     // ... filter to delete one CashMovement
     *   }
     * })
     * 
     */
    delete<T extends CashMovementDeleteArgs>(args: SelectSubset<T, CashMovementDeleteArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashMovement.
     * @param {CashMovementUpdateArgs} args - Arguments to update one CashMovement.
     * @example
     * // Update one CashMovement
     * const cashMovement = await prisma.cashMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashMovementUpdateArgs>(args: SelectSubset<T, CashMovementUpdateArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashMovements.
     * @param {CashMovementDeleteManyArgs} args - Arguments to filter CashMovements to delete.
     * @example
     * // Delete a few CashMovements
     * const { count } = await prisma.cashMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashMovementDeleteManyArgs>(args?: SelectSubset<T, CashMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashMovements
     * const cashMovement = await prisma.cashMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashMovementUpdateManyArgs>(args: SelectSubset<T, CashMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashMovements and returns the data updated in the database.
     * @param {CashMovementUpdateManyAndReturnArgs} args - Arguments to update many CashMovements.
     * @example
     * // Update many CashMovements
     * const cashMovement = await prisma.cashMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashMovements and only return the `id`
     * const cashMovementWithIdOnly = await prisma.cashMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, CashMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashMovement.
     * @param {CashMovementUpsertArgs} args - Arguments to update or create a CashMovement.
     * @example
     * // Update or create a CashMovement
     * const cashMovement = await prisma.cashMovement.upsert({
     *   create: {
     *     // ... data to create a CashMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashMovement we want to update
     *   }
     * })
     */
    upsert<T extends CashMovementUpsertArgs>(args: SelectSubset<T, CashMovementUpsertArgs<ExtArgs>>): Prisma__CashMovementClient<$Result.GetResult<Prisma.$CashMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementCountArgs} args - Arguments to filter CashMovements to count.
     * @example
     * // Count the number of CashMovements
     * const count = await prisma.cashMovement.count({
     *   where: {
     *     // ... the filter for the CashMovements we want to count
     *   }
     * })
    **/
    count<T extends CashMovementCountArgs>(
      args?: Subset<T, CashMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashMovementAggregateArgs>(args: Subset<T, CashMovementAggregateArgs>): Prisma.PrismaPromise<GetCashMovementAggregateType<T>>

    /**
     * Group by CashMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashMovementGroupByArgs['orderBy'] }
        : { orderBy?: CashMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashMovement model
   */
  readonly fields: CashMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CashSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashSessionDefaultArgs<ExtArgs>>): Prisma__CashSessionClient<$Result.GetResult<Prisma.$CashSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashMovement model
   */
  interface CashMovementFieldRefs {
    readonly id: FieldRef<"CashMovement", 'String'>
    readonly sessionId: FieldRef<"CashMovement", 'String'>
    readonly type: FieldRef<"CashMovement", 'CashMovementType'>
    readonly amount: FieldRef<"CashMovement", 'Decimal'>
    readonly reference: FieldRef<"CashMovement", 'String'>
    readonly createdById: FieldRef<"CashMovement", 'String'>
    readonly requestContextId: FieldRef<"CashMovement", 'String'>
    readonly createdAt: FieldRef<"CashMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashMovement findUnique
   */
  export type CashMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where: CashMovementWhereUniqueInput
  }

  /**
   * CashMovement findUniqueOrThrow
   */
  export type CashMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where: CashMovementWhereUniqueInput
  }

  /**
   * CashMovement findFirst
   */
  export type CashMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashMovements.
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashMovements.
     */
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }

  /**
   * CashMovement findFirstOrThrow
   */
  export type CashMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovement to fetch.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashMovements.
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashMovements.
     */
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }

  /**
   * CashMovement findMany
   */
  export type CashMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter, which CashMovements to fetch.
     */
    where?: CashMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashMovements to fetch.
     */
    orderBy?: CashMovementOrderByWithRelationInput | CashMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashMovements.
     */
    cursor?: CashMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashMovements.
     */
    skip?: number
    distinct?: CashMovementScalarFieldEnum | CashMovementScalarFieldEnum[]
  }

  /**
   * CashMovement create
   */
  export type CashMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a CashMovement.
     */
    data: XOR<CashMovementCreateInput, CashMovementUncheckedCreateInput>
  }

  /**
   * CashMovement createMany
   */
  export type CashMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashMovements.
     */
    data: CashMovementCreateManyInput | CashMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashMovement createManyAndReturn
   */
  export type CashMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * The data used to create many CashMovements.
     */
    data: CashMovementCreateManyInput | CashMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashMovement update
   */
  export type CashMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a CashMovement.
     */
    data: XOR<CashMovementUpdateInput, CashMovementUncheckedUpdateInput>
    /**
     * Choose, which CashMovement to update.
     */
    where: CashMovementWhereUniqueInput
  }

  /**
   * CashMovement updateMany
   */
  export type CashMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashMovements.
     */
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyInput>
    /**
     * Filter which CashMovements to update
     */
    where?: CashMovementWhereInput
    /**
     * Limit how many CashMovements to update.
     */
    limit?: number
  }

  /**
   * CashMovement updateManyAndReturn
   */
  export type CashMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * The data used to update CashMovements.
     */
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyInput>
    /**
     * Filter which CashMovements to update
     */
    where?: CashMovementWhereInput
    /**
     * Limit how many CashMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashMovement upsert
   */
  export type CashMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the CashMovement to update in case it exists.
     */
    where: CashMovementWhereUniqueInput
    /**
     * In case the CashMovement found by the `where` argument doesn't exist, create a new CashMovement with this data.
     */
    create: XOR<CashMovementCreateInput, CashMovementUncheckedCreateInput>
    /**
     * In case the CashMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashMovementUpdateInput, CashMovementUncheckedUpdateInput>
  }

  /**
   * CashMovement delete
   */
  export type CashMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
    /**
     * Filter which CashMovement to delete.
     */
    where: CashMovementWhereUniqueInput
  }

  /**
   * CashMovement deleteMany
   */
  export type CashMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashMovements to delete
     */
    where?: CashMovementWhereInput
    /**
     * Limit how many CashMovements to delete.
     */
    limit?: number
  }

  /**
   * CashMovement without action
   */
  export type CashMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashMovement
     */
    select?: CashMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashMovement
     */
    omit?: CashMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashMovementInclude<ExtArgs> | null
  }


  /**
   * Model InventoryProduct
   */

  export type AggregateInventoryProduct = {
    _count: InventoryProductCountAggregateOutputType | null
    _avg: InventoryProductAvgAggregateOutputType | null
    _sum: InventoryProductSumAggregateOutputType | null
    _min: InventoryProductMinAggregateOutputType | null
    _max: InventoryProductMaxAggregateOutputType | null
  }

  export type InventoryProductAvgAggregateOutputType = {
    price: Decimal | null
    taxRatePct: Decimal | null
  }

  export type InventoryProductSumAggregateOutputType = {
    price: Decimal | null
    taxRatePct: Decimal | null
  }

  export type InventoryProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    unit: string | null
    price: Decimal | null
    taxRatePct: Decimal | null
    isActive: boolean | null
  }

  export type InventoryProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    unit: string | null
    price: Decimal | null
    taxRatePct: Decimal | null
    isActive: boolean | null
  }

  export type InventoryProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    unit: number
    price: number
    taxRatePct: number
    isActive: number
    _all: number
  }


  export type InventoryProductAvgAggregateInputType = {
    price?: true
    taxRatePct?: true
  }

  export type InventoryProductSumAggregateInputType = {
    price?: true
    taxRatePct?: true
  }

  export type InventoryProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    unit?: true
    price?: true
    taxRatePct?: true
    isActive?: true
  }

  export type InventoryProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    unit?: true
    price?: true
    taxRatePct?: true
    isActive?: true
  }

  export type InventoryProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    unit?: true
    price?: true
    taxRatePct?: true
    isActive?: true
    _all?: true
  }

  export type InventoryProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryProduct to aggregate.
     */
    where?: InventoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryProducts to fetch.
     */
    orderBy?: InventoryProductOrderByWithRelationInput | InventoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryProducts
    **/
    _count?: true | InventoryProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryProductMaxAggregateInputType
  }

  export type GetInventoryProductAggregateType<T extends InventoryProductAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryProduct[P]>
      : GetScalarType<T[P], AggregateInventoryProduct[P]>
  }




  export type InventoryProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryProductWhereInput
    orderBy?: InventoryProductOrderByWithAggregationInput | InventoryProductOrderByWithAggregationInput[]
    by: InventoryProductScalarFieldEnum[] | InventoryProductScalarFieldEnum
    having?: InventoryProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryProductCountAggregateInputType | true
    _avg?: InventoryProductAvgAggregateInputType
    _sum?: InventoryProductSumAggregateInputType
    _min?: InventoryProductMinAggregateInputType
    _max?: InventoryProductMaxAggregateInputType
  }

  export type InventoryProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    unit: string | null
    price: Decimal
    taxRatePct: Decimal
    isActive: boolean
    _count: InventoryProductCountAggregateOutputType | null
    _avg: InventoryProductAvgAggregateOutputType | null
    _sum: InventoryProductSumAggregateOutputType | null
    _min: InventoryProductMinAggregateOutputType | null
    _max: InventoryProductMaxAggregateOutputType | null
  }

  type GetInventoryProductGroupByPayload<T extends InventoryProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryProductGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryProductGroupByOutputType[P]>
        }
      >
    >


  export type InventoryProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    taxRatePct?: boolean
    isActive?: boolean
    stock?: boolean | InventoryProduct$stockArgs<ExtArgs>
    stockMoves?: boolean | InventoryProduct$stockMovesArgs<ExtArgs>
    lines?: boolean | InventoryProduct$linesArgs<ExtArgs>
    _count?: boolean | InventoryProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryProduct"]>

  export type InventoryProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    taxRatePct?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["inventoryProduct"]>

  export type InventoryProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    taxRatePct?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["inventoryProduct"]>

  export type InventoryProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    taxRatePct?: boolean
    isActive?: boolean
  }

  export type InventoryProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "unit" | "price" | "taxRatePct" | "isActive", ExtArgs["result"]["inventoryProduct"]>
  export type InventoryProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | InventoryProduct$stockArgs<ExtArgs>
    stockMoves?: boolean | InventoryProduct$stockMovesArgs<ExtArgs>
    lines?: boolean | InventoryProduct$linesArgs<ExtArgs>
    _count?: boolean | InventoryProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InventoryProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryProduct"
    objects: {
      stock: Prisma.$ProductStockPayload<ExtArgs>[]
      stockMoves: Prisma.$StockMovementPayload<ExtArgs>[]
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      unit: string | null
      price: Prisma.Decimal
      taxRatePct: Prisma.Decimal
      isActive: boolean
    }, ExtArgs["result"]["inventoryProduct"]>
    composites: {}
  }

  type InventoryProductGetPayload<S extends boolean | null | undefined | InventoryProductDefaultArgs> = $Result.GetResult<Prisma.$InventoryProductPayload, S>

  type InventoryProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryProductCountAggregateInputType | true
    }

  export interface InventoryProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryProduct'], meta: { name: 'InventoryProduct' } }
    /**
     * Find zero or one InventoryProduct that matches the filter.
     * @param {InventoryProductFindUniqueArgs} args - Arguments to find a InventoryProduct
     * @example
     * // Get one InventoryProduct
     * const inventoryProduct = await prisma.inventoryProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryProductFindUniqueArgs>(args: SelectSubset<T, InventoryProductFindUniqueArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryProductFindUniqueOrThrowArgs} args - Arguments to find a InventoryProduct
     * @example
     * // Get one InventoryProduct
     * const inventoryProduct = await prisma.inventoryProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryProductFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductFindFirstArgs} args - Arguments to find a InventoryProduct
     * @example
     * // Get one InventoryProduct
     * const inventoryProduct = await prisma.inventoryProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryProductFindFirstArgs>(args?: SelectSubset<T, InventoryProductFindFirstArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductFindFirstOrThrowArgs} args - Arguments to find a InventoryProduct
     * @example
     * // Get one InventoryProduct
     * const inventoryProduct = await prisma.inventoryProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryProductFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryProducts
     * const inventoryProducts = await prisma.inventoryProduct.findMany()
     * 
     * // Get first 10 InventoryProducts
     * const inventoryProducts = await prisma.inventoryProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryProductWithIdOnly = await prisma.inventoryProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryProductFindManyArgs>(args?: SelectSubset<T, InventoryProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryProduct.
     * @param {InventoryProductCreateArgs} args - Arguments to create a InventoryProduct.
     * @example
     * // Create one InventoryProduct
     * const InventoryProduct = await prisma.inventoryProduct.create({
     *   data: {
     *     // ... data to create a InventoryProduct
     *   }
     * })
     * 
     */
    create<T extends InventoryProductCreateArgs>(args: SelectSubset<T, InventoryProductCreateArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryProducts.
     * @param {InventoryProductCreateManyArgs} args - Arguments to create many InventoryProducts.
     * @example
     * // Create many InventoryProducts
     * const inventoryProduct = await prisma.inventoryProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryProductCreateManyArgs>(args?: SelectSubset<T, InventoryProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryProducts and returns the data saved in the database.
     * @param {InventoryProductCreateManyAndReturnArgs} args - Arguments to create many InventoryProducts.
     * @example
     * // Create many InventoryProducts
     * const inventoryProduct = await prisma.inventoryProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryProducts and only return the `id`
     * const inventoryProductWithIdOnly = await prisma.inventoryProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryProductCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryProduct.
     * @param {InventoryProductDeleteArgs} args - Arguments to delete one InventoryProduct.
     * @example
     * // Delete one InventoryProduct
     * const InventoryProduct = await prisma.inventoryProduct.delete({
     *   where: {
     *     // ... filter to delete one InventoryProduct
     *   }
     * })
     * 
     */
    delete<T extends InventoryProductDeleteArgs>(args: SelectSubset<T, InventoryProductDeleteArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryProduct.
     * @param {InventoryProductUpdateArgs} args - Arguments to update one InventoryProduct.
     * @example
     * // Update one InventoryProduct
     * const inventoryProduct = await prisma.inventoryProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryProductUpdateArgs>(args: SelectSubset<T, InventoryProductUpdateArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryProducts.
     * @param {InventoryProductDeleteManyArgs} args - Arguments to filter InventoryProducts to delete.
     * @example
     * // Delete a few InventoryProducts
     * const { count } = await prisma.inventoryProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryProductDeleteManyArgs>(args?: SelectSubset<T, InventoryProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryProducts
     * const inventoryProduct = await prisma.inventoryProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryProductUpdateManyArgs>(args: SelectSubset<T, InventoryProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryProducts and returns the data updated in the database.
     * @param {InventoryProductUpdateManyAndReturnArgs} args - Arguments to update many InventoryProducts.
     * @example
     * // Update many InventoryProducts
     * const inventoryProduct = await prisma.inventoryProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryProducts and only return the `id`
     * const inventoryProductWithIdOnly = await prisma.inventoryProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryProductUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryProduct.
     * @param {InventoryProductUpsertArgs} args - Arguments to update or create a InventoryProduct.
     * @example
     * // Update or create a InventoryProduct
     * const inventoryProduct = await prisma.inventoryProduct.upsert({
     *   create: {
     *     // ... data to create a InventoryProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryProduct we want to update
     *   }
     * })
     */
    upsert<T extends InventoryProductUpsertArgs>(args: SelectSubset<T, InventoryProductUpsertArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductCountArgs} args - Arguments to filter InventoryProducts to count.
     * @example
     * // Count the number of InventoryProducts
     * const count = await prisma.inventoryProduct.count({
     *   where: {
     *     // ... the filter for the InventoryProducts we want to count
     *   }
     * })
    **/
    count<T extends InventoryProductCountArgs>(
      args?: Subset<T, InventoryProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryProductAggregateArgs>(args: Subset<T, InventoryProductAggregateArgs>): Prisma.PrismaPromise<GetInventoryProductAggregateType<T>>

    /**
     * Group by InventoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryProductGroupByArgs['orderBy'] }
        : { orderBy?: InventoryProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryProduct model
   */
  readonly fields: InventoryProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends InventoryProduct$stockArgs<ExtArgs> = {}>(args?: Subset<T, InventoryProduct$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMoves<T extends InventoryProduct$stockMovesArgs<ExtArgs> = {}>(args?: Subset<T, InventoryProduct$stockMovesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lines<T extends InventoryProduct$linesArgs<ExtArgs> = {}>(args?: Subset<T, InventoryProduct$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryProduct model
   */
  interface InventoryProductFieldRefs {
    readonly id: FieldRef<"InventoryProduct", 'String'>
    readonly sku: FieldRef<"InventoryProduct", 'String'>
    readonly name: FieldRef<"InventoryProduct", 'String'>
    readonly unit: FieldRef<"InventoryProduct", 'String'>
    readonly price: FieldRef<"InventoryProduct", 'Decimal'>
    readonly taxRatePct: FieldRef<"InventoryProduct", 'Decimal'>
    readonly isActive: FieldRef<"InventoryProduct", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InventoryProduct findUnique
   */
  export type InventoryProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * Filter, which InventoryProduct to fetch.
     */
    where: InventoryProductWhereUniqueInput
  }

  /**
   * InventoryProduct findUniqueOrThrow
   */
  export type InventoryProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * Filter, which InventoryProduct to fetch.
     */
    where: InventoryProductWhereUniqueInput
  }

  /**
   * InventoryProduct findFirst
   */
  export type InventoryProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * Filter, which InventoryProduct to fetch.
     */
    where?: InventoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryProducts to fetch.
     */
    orderBy?: InventoryProductOrderByWithRelationInput | InventoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryProducts.
     */
    cursor?: InventoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryProducts.
     */
    distinct?: InventoryProductScalarFieldEnum | InventoryProductScalarFieldEnum[]
  }

  /**
   * InventoryProduct findFirstOrThrow
   */
  export type InventoryProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * Filter, which InventoryProduct to fetch.
     */
    where?: InventoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryProducts to fetch.
     */
    orderBy?: InventoryProductOrderByWithRelationInput | InventoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryProducts.
     */
    cursor?: InventoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryProducts.
     */
    distinct?: InventoryProductScalarFieldEnum | InventoryProductScalarFieldEnum[]
  }

  /**
   * InventoryProduct findMany
   */
  export type InventoryProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * Filter, which InventoryProducts to fetch.
     */
    where?: InventoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryProducts to fetch.
     */
    orderBy?: InventoryProductOrderByWithRelationInput | InventoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryProducts.
     */
    cursor?: InventoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryProducts.
     */
    skip?: number
    distinct?: InventoryProductScalarFieldEnum | InventoryProductScalarFieldEnum[]
  }

  /**
   * InventoryProduct create
   */
  export type InventoryProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryProduct.
     */
    data: XOR<InventoryProductCreateInput, InventoryProductUncheckedCreateInput>
  }

  /**
   * InventoryProduct createMany
   */
  export type InventoryProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryProducts.
     */
    data: InventoryProductCreateManyInput | InventoryProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryProduct createManyAndReturn
   */
  export type InventoryProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryProducts.
     */
    data: InventoryProductCreateManyInput | InventoryProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryProduct update
   */
  export type InventoryProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryProduct.
     */
    data: XOR<InventoryProductUpdateInput, InventoryProductUncheckedUpdateInput>
    /**
     * Choose, which InventoryProduct to update.
     */
    where: InventoryProductWhereUniqueInput
  }

  /**
   * InventoryProduct updateMany
   */
  export type InventoryProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryProducts.
     */
    data: XOR<InventoryProductUpdateManyMutationInput, InventoryProductUncheckedUpdateManyInput>
    /**
     * Filter which InventoryProducts to update
     */
    where?: InventoryProductWhereInput
    /**
     * Limit how many InventoryProducts to update.
     */
    limit?: number
  }

  /**
   * InventoryProduct updateManyAndReturn
   */
  export type InventoryProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * The data used to update InventoryProducts.
     */
    data: XOR<InventoryProductUpdateManyMutationInput, InventoryProductUncheckedUpdateManyInput>
    /**
     * Filter which InventoryProducts to update
     */
    where?: InventoryProductWhereInput
    /**
     * Limit how many InventoryProducts to update.
     */
    limit?: number
  }

  /**
   * InventoryProduct upsert
   */
  export type InventoryProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryProduct to update in case it exists.
     */
    where: InventoryProductWhereUniqueInput
    /**
     * In case the InventoryProduct found by the `where` argument doesn't exist, create a new InventoryProduct with this data.
     */
    create: XOR<InventoryProductCreateInput, InventoryProductUncheckedCreateInput>
    /**
     * In case the InventoryProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryProductUpdateInput, InventoryProductUncheckedUpdateInput>
  }

  /**
   * InventoryProduct delete
   */
  export type InventoryProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
    /**
     * Filter which InventoryProduct to delete.
     */
    where: InventoryProductWhereUniqueInput
  }

  /**
   * InventoryProduct deleteMany
   */
  export type InventoryProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryProducts to delete
     */
    where?: InventoryProductWhereInput
    /**
     * Limit how many InventoryProducts to delete.
     */
    limit?: number
  }

  /**
   * InventoryProduct.stock
   */
  export type InventoryProduct$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    cursor?: ProductStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * InventoryProduct.stockMoves
   */
  export type InventoryProduct$stockMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * InventoryProduct.lines
   */
  export type InventoryProduct$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InventoryProduct without action
   */
  export type InventoryProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryProduct
     */
    select?: InventoryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryProduct
     */
    omit?: InventoryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductStock
   */

  export type AggregateProductStock = {
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  export type ProductStockAvgAggregateOutputType = {
    onHand: number | null
  }

  export type ProductStockSumAggregateOutputType = {
    onHand: number | null
  }

  export type ProductStockMinAggregateOutputType = {
    id: string | null
    productId: string | null
    locationId: string | null
    onHand: number | null
  }

  export type ProductStockMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    locationId: string | null
    onHand: number | null
  }

  export type ProductStockCountAggregateOutputType = {
    id: number
    productId: number
    locationId: number
    onHand: number
    _all: number
  }


  export type ProductStockAvgAggregateInputType = {
    onHand?: true
  }

  export type ProductStockSumAggregateInputType = {
    onHand?: true
  }

  export type ProductStockMinAggregateInputType = {
    id?: true
    productId?: true
    locationId?: true
    onHand?: true
  }

  export type ProductStockMaxAggregateInputType = {
    id?: true
    productId?: true
    locationId?: true
    onHand?: true
  }

  export type ProductStockCountAggregateInputType = {
    id?: true
    productId?: true
    locationId?: true
    onHand?: true
    _all?: true
  }

  export type ProductStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStock to aggregate.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStocks
    **/
    _count?: true | ProductStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStockMaxAggregateInputType
  }

  export type GetProductStockAggregateType<T extends ProductStockAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStock[P]>
      : GetScalarType<T[P], AggregateProductStock[P]>
  }




  export type ProductStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithAggregationInput | ProductStockOrderByWithAggregationInput[]
    by: ProductStockScalarFieldEnum[] | ProductStockScalarFieldEnum
    having?: ProductStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStockCountAggregateInputType | true
    _avg?: ProductStockAvgAggregateInputType
    _sum?: ProductStockSumAggregateInputType
    _min?: ProductStockMinAggregateInputType
    _max?: ProductStockMaxAggregateInputType
  }

  export type ProductStockGroupByOutputType = {
    id: string
    productId: string
    locationId: string
    onHand: number
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  type GetProductStockGroupByPayload<T extends ProductStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
        }
      >
    >


  export type ProductStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    locationId?: boolean
    onHand?: boolean
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    locationId?: boolean
    onHand?: boolean
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    locationId?: boolean
    onHand?: boolean
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectScalar = {
    id?: boolean
    productId?: boolean
    locationId?: boolean
    onHand?: boolean
  }

  export type ProductStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "locationId" | "onHand", ExtArgs["result"]["productStock"]>
  export type ProductStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ProductStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ProductStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ProductStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStock"
    objects: {
      product: Prisma.$InventoryProductPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      locationId: string
      onHand: number
    }, ExtArgs["result"]["productStock"]>
    composites: {}
  }

  type ProductStockGetPayload<S extends boolean | null | undefined | ProductStockDefaultArgs> = $Result.GetResult<Prisma.$ProductStockPayload, S>

  type ProductStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductStockCountAggregateInputType | true
    }

  export interface ProductStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStock'], meta: { name: 'ProductStock' } }
    /**
     * Find zero or one ProductStock that matches the filter.
     * @param {ProductStockFindUniqueArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStockFindUniqueArgs>(args: SelectSubset<T, ProductStockFindUniqueArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductStockFindUniqueOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStockFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStockFindFirstArgs>(args?: SelectSubset<T, ProductStockFindFirstArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStockFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStocks
     * const productStocks = await prisma.productStock.findMany()
     * 
     * // Get first 10 ProductStocks
     * const productStocks = await prisma.productStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productStockWithIdOnly = await prisma.productStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductStockFindManyArgs>(args?: SelectSubset<T, ProductStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductStock.
     * @param {ProductStockCreateArgs} args - Arguments to create a ProductStock.
     * @example
     * // Create one ProductStock
     * const ProductStock = await prisma.productStock.create({
     *   data: {
     *     // ... data to create a ProductStock
     *   }
     * })
     * 
     */
    create<T extends ProductStockCreateArgs>(args: SelectSubset<T, ProductStockCreateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductStocks.
     * @param {ProductStockCreateManyArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStockCreateManyArgs>(args?: SelectSubset<T, ProductStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductStocks and returns the data saved in the database.
     * @param {ProductStockCreateManyAndReturnArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductStocks and only return the `id`
     * const productStockWithIdOnly = await prisma.productStock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductStockCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductStock.
     * @param {ProductStockDeleteArgs} args - Arguments to delete one ProductStock.
     * @example
     * // Delete one ProductStock
     * const ProductStock = await prisma.productStock.delete({
     *   where: {
     *     // ... filter to delete one ProductStock
     *   }
     * })
     * 
     */
    delete<T extends ProductStockDeleteArgs>(args: SelectSubset<T, ProductStockDeleteArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductStock.
     * @param {ProductStockUpdateArgs} args - Arguments to update one ProductStock.
     * @example
     * // Update one ProductStock
     * const productStock = await prisma.productStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStockUpdateArgs>(args: SelectSubset<T, ProductStockUpdateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductStocks.
     * @param {ProductStockDeleteManyArgs} args - Arguments to filter ProductStocks to delete.
     * @example
     * // Delete a few ProductStocks
     * const { count } = await prisma.productStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStockDeleteManyArgs>(args?: SelectSubset<T, ProductStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStocks
     * const productStock = await prisma.productStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStockUpdateManyArgs>(args: SelectSubset<T, ProductStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStocks and returns the data updated in the database.
     * @param {ProductStockUpdateManyAndReturnArgs} args - Arguments to update many ProductStocks.
     * @example
     * // Update many ProductStocks
     * const productStock = await prisma.productStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductStocks and only return the `id`
     * const productStockWithIdOnly = await prisma.productStock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductStockUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductStock.
     * @param {ProductStockUpsertArgs} args - Arguments to update or create a ProductStock.
     * @example
     * // Update or create a ProductStock
     * const productStock = await prisma.productStock.upsert({
     *   create: {
     *     // ... data to create a ProductStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStock we want to update
     *   }
     * })
     */
    upsert<T extends ProductStockUpsertArgs>(args: SelectSubset<T, ProductStockUpsertArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockCountArgs} args - Arguments to filter ProductStocks to count.
     * @example
     * // Count the number of ProductStocks
     * const count = await prisma.productStock.count({
     *   where: {
     *     // ... the filter for the ProductStocks we want to count
     *   }
     * })
    **/
    count<T extends ProductStockCountArgs>(
      args?: Subset<T, ProductStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStockAggregateArgs>(args: Subset<T, ProductStockAggregateArgs>): Prisma.PrismaPromise<GetProductStockAggregateType<T>>

    /**
     * Group by ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStockGroupByArgs['orderBy'] }
        : { orderBy?: ProductStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStock model
   */
  readonly fields: ProductStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends InventoryProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryProductDefaultArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStock model
   */
  interface ProductStockFieldRefs {
    readonly id: FieldRef<"ProductStock", 'String'>
    readonly productId: FieldRef<"ProductStock", 'String'>
    readonly locationId: FieldRef<"ProductStock", 'String'>
    readonly onHand: FieldRef<"ProductStock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductStock findUnique
   */
  export type ProductStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findUniqueOrThrow
   */
  export type ProductStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findFirst
   */
  export type ProductStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findFirstOrThrow
   */
  export type ProductStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findMany
   */
  export type ProductStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStocks to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock create
   */
  export type ProductStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStock.
     */
    data: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
  }

  /**
   * ProductStock createMany
   */
  export type ProductStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStock createManyAndReturn
   */
  export type ProductStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStock update
   */
  export type ProductStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStock.
     */
    data: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
    /**
     * Choose, which ProductStock to update.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock updateMany
   */
  export type ProductStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStocks.
     */
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyInput>
    /**
     * Filter which ProductStocks to update
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to update.
     */
    limit?: number
  }

  /**
   * ProductStock updateManyAndReturn
   */
  export type ProductStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * The data used to update ProductStocks.
     */
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyInput>
    /**
     * Filter which ProductStocks to update
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStock upsert
   */
  export type ProductStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStock to update in case it exists.
     */
    where: ProductStockWhereUniqueInput
    /**
     * In case the ProductStock found by the `where` argument doesn't exist, create a new ProductStock with this data.
     */
    create: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
    /**
     * In case the ProductStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
  }

  /**
   * ProductStock delete
   */
  export type ProductStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter which ProductStock to delete.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock deleteMany
   */
  export type ProductStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStocks to delete
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to delete.
     */
    limit?: number
  }

  /**
   * ProductStock without action
   */
  export type ProductStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    qty: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    qty: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    productId: string | null
    locationId: string | null
    qty: number | null
    reason: $Enums.StockReason | null
    reference: string | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    locationId: string | null
    qty: number | null
    reason: $Enums.StockReason | null
    reference: string | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    productId: number
    locationId: number
    qty: number
    reason: number
    reference: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    qty?: true
  }

  export type StockMovementSumAggregateInputType = {
    qty?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    productId?: true
    locationId?: true
    qty?: true
    reason?: true
    reference?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    productId?: true
    locationId?: true
    qty?: true
    reason?: true
    reference?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    productId?: true
    locationId?: true
    qty?: true
    reason?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    productId: string
    locationId: string
    qty: number
    reason: $Enums.StockReason
    reference: string | null
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    locationId?: boolean
    qty?: boolean
    reason?: boolean
    reference?: boolean
    createdAt?: boolean
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    locationId?: boolean
    qty?: boolean
    reason?: boolean
    reference?: boolean
    createdAt?: boolean
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    locationId?: boolean
    qty?: boolean
    reason?: boolean
    reference?: boolean
    createdAt?: boolean
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    id?: boolean
    productId?: boolean
    locationId?: boolean
    qty?: boolean
    reason?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type StockMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "locationId" | "qty" | "reason" | "reference" | "createdAt", ExtArgs["result"]["stockMovement"]>
  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type StockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type StockMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | InventoryProductDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      product: Prisma.$InventoryProductPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      locationId: string
      qty: number
      reason: $Enums.StockReason
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMovements and returns the data saved in the database.
     * @param {StockMovementCreateManyAndReturnArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements and returns the data updated in the database.
     * @param {StockMovementUpdateManyAndReturnArgs} args - Arguments to update many StockMovements.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, StockMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends InventoryProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryProductDefaultArgs<ExtArgs>>): Prisma__InventoryProductClient<$Result.GetResult<Prisma.$InventoryProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly productId: FieldRef<"StockMovement", 'String'>
    readonly locationId: FieldRef<"StockMovement", 'String'>
    readonly qty: FieldRef<"StockMovement", 'Int'>
    readonly reason: FieldRef<"StockMovement", 'StockReason'>
    readonly reference: FieldRef<"StockMovement", 'String'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMovement createManyAndReturn
   */
  export type StockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to update.
     */
    limit?: number
  }

  /**
   * StockMovement updateManyAndReturn
   */
  export type StockMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to delete.
     */
    limit?: number
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model LabInstrument
   */

  export type AggregateLabInstrument = {
    _count: LabInstrumentCountAggregateOutputType | null
    _min: LabInstrumentMinAggregateOutputType | null
    _max: LabInstrumentMaxAggregateOutputType | null
  }

  export type LabInstrumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    vendor: string | null
    model: string | null
    serialNo: string | null
    connectionType: $Enums.ConnectionType | null
    locationId: string | null
    isActive: boolean | null
  }

  export type LabInstrumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    vendor: string | null
    model: string | null
    serialNo: string | null
    connectionType: $Enums.ConnectionType | null
    locationId: string | null
    isActive: boolean | null
  }

  export type LabInstrumentCountAggregateOutputType = {
    id: number
    name: number
    vendor: number
    model: number
    serialNo: number
    connectionType: number
    locationId: number
    isActive: number
    _all: number
  }


  export type LabInstrumentMinAggregateInputType = {
    id?: true
    name?: true
    vendor?: true
    model?: true
    serialNo?: true
    connectionType?: true
    locationId?: true
    isActive?: true
  }

  export type LabInstrumentMaxAggregateInputType = {
    id?: true
    name?: true
    vendor?: true
    model?: true
    serialNo?: true
    connectionType?: true
    locationId?: true
    isActive?: true
  }

  export type LabInstrumentCountAggregateInputType = {
    id?: true
    name?: true
    vendor?: true
    model?: true
    serialNo?: true
    connectionType?: true
    locationId?: true
    isActive?: true
    _all?: true
  }

  export type LabInstrumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabInstrument to aggregate.
     */
    where?: LabInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabInstruments to fetch.
     */
    orderBy?: LabInstrumentOrderByWithRelationInput | LabInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabInstruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabInstruments
    **/
    _count?: true | LabInstrumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabInstrumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabInstrumentMaxAggregateInputType
  }

  export type GetLabInstrumentAggregateType<T extends LabInstrumentAggregateArgs> = {
        [P in keyof T & keyof AggregateLabInstrument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabInstrument[P]>
      : GetScalarType<T[P], AggregateLabInstrument[P]>
  }




  export type LabInstrumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabInstrumentWhereInput
    orderBy?: LabInstrumentOrderByWithAggregationInput | LabInstrumentOrderByWithAggregationInput[]
    by: LabInstrumentScalarFieldEnum[] | LabInstrumentScalarFieldEnum
    having?: LabInstrumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabInstrumentCountAggregateInputType | true
    _min?: LabInstrumentMinAggregateInputType
    _max?: LabInstrumentMaxAggregateInputType
  }

  export type LabInstrumentGroupByOutputType = {
    id: string
    name: string
    vendor: string | null
    model: string | null
    serialNo: string | null
    connectionType: $Enums.ConnectionType | null
    locationId: string | null
    isActive: boolean
    _count: LabInstrumentCountAggregateOutputType | null
    _min: LabInstrumentMinAggregateOutputType | null
    _max: LabInstrumentMaxAggregateOutputType | null
  }

  type GetLabInstrumentGroupByPayload<T extends LabInstrumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabInstrumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabInstrumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabInstrumentGroupByOutputType[P]>
            : GetScalarType<T[P], LabInstrumentGroupByOutputType[P]>
        }
      >
    >


  export type LabInstrumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vendor?: boolean
    model?: boolean
    serialNo?: boolean
    connectionType?: boolean
    locationId?: boolean
    isActive?: boolean
    location?: boolean | LabInstrument$locationArgs<ExtArgs>
    testsDefault?: boolean | LabInstrument$testsDefaultArgs<ExtArgs>
    orderTests?: boolean | LabInstrument$orderTestsArgs<ExtArgs>
    messages?: boolean | LabInstrument$messagesArgs<ExtArgs>
    _count?: boolean | LabInstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labInstrument"]>

  export type LabInstrumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vendor?: boolean
    model?: boolean
    serialNo?: boolean
    connectionType?: boolean
    locationId?: boolean
    isActive?: boolean
    location?: boolean | LabInstrument$locationArgs<ExtArgs>
  }, ExtArgs["result"]["labInstrument"]>

  export type LabInstrumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vendor?: boolean
    model?: boolean
    serialNo?: boolean
    connectionType?: boolean
    locationId?: boolean
    isActive?: boolean
    location?: boolean | LabInstrument$locationArgs<ExtArgs>
  }, ExtArgs["result"]["labInstrument"]>

  export type LabInstrumentSelectScalar = {
    id?: boolean
    name?: boolean
    vendor?: boolean
    model?: boolean
    serialNo?: boolean
    connectionType?: boolean
    locationId?: boolean
    isActive?: boolean
  }

  export type LabInstrumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "vendor" | "model" | "serialNo" | "connectionType" | "locationId" | "isActive", ExtArgs["result"]["labInstrument"]>
  export type LabInstrumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LabInstrument$locationArgs<ExtArgs>
    testsDefault?: boolean | LabInstrument$testsDefaultArgs<ExtArgs>
    orderTests?: boolean | LabInstrument$orderTestsArgs<ExtArgs>
    messages?: boolean | LabInstrument$messagesArgs<ExtArgs>
    _count?: boolean | LabInstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabInstrumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LabInstrument$locationArgs<ExtArgs>
  }
  export type LabInstrumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LabInstrument$locationArgs<ExtArgs>
  }

  export type $LabInstrumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabInstrument"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      testsDefault: Prisma.$TestCatalogPayload<ExtArgs>[]
      orderTests: Prisma.$LabOrderTestPayload<ExtArgs>[]
      messages: Prisma.$LabDeviceMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      vendor: string | null
      model: string | null
      serialNo: string | null
      connectionType: $Enums.ConnectionType | null
      locationId: string | null
      isActive: boolean
    }, ExtArgs["result"]["labInstrument"]>
    composites: {}
  }

  type LabInstrumentGetPayload<S extends boolean | null | undefined | LabInstrumentDefaultArgs> = $Result.GetResult<Prisma.$LabInstrumentPayload, S>

  type LabInstrumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabInstrumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabInstrumentCountAggregateInputType | true
    }

  export interface LabInstrumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabInstrument'], meta: { name: 'LabInstrument' } }
    /**
     * Find zero or one LabInstrument that matches the filter.
     * @param {LabInstrumentFindUniqueArgs} args - Arguments to find a LabInstrument
     * @example
     * // Get one LabInstrument
     * const labInstrument = await prisma.labInstrument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabInstrumentFindUniqueArgs>(args: SelectSubset<T, LabInstrumentFindUniqueArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabInstrument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabInstrumentFindUniqueOrThrowArgs} args - Arguments to find a LabInstrument
     * @example
     * // Get one LabInstrument
     * const labInstrument = await prisma.labInstrument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabInstrumentFindUniqueOrThrowArgs>(args: SelectSubset<T, LabInstrumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabInstrument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentFindFirstArgs} args - Arguments to find a LabInstrument
     * @example
     * // Get one LabInstrument
     * const labInstrument = await prisma.labInstrument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabInstrumentFindFirstArgs>(args?: SelectSubset<T, LabInstrumentFindFirstArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabInstrument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentFindFirstOrThrowArgs} args - Arguments to find a LabInstrument
     * @example
     * // Get one LabInstrument
     * const labInstrument = await prisma.labInstrument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabInstrumentFindFirstOrThrowArgs>(args?: SelectSubset<T, LabInstrumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabInstruments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabInstruments
     * const labInstruments = await prisma.labInstrument.findMany()
     * 
     * // Get first 10 LabInstruments
     * const labInstruments = await prisma.labInstrument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labInstrumentWithIdOnly = await prisma.labInstrument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabInstrumentFindManyArgs>(args?: SelectSubset<T, LabInstrumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabInstrument.
     * @param {LabInstrumentCreateArgs} args - Arguments to create a LabInstrument.
     * @example
     * // Create one LabInstrument
     * const LabInstrument = await prisma.labInstrument.create({
     *   data: {
     *     // ... data to create a LabInstrument
     *   }
     * })
     * 
     */
    create<T extends LabInstrumentCreateArgs>(args: SelectSubset<T, LabInstrumentCreateArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabInstruments.
     * @param {LabInstrumentCreateManyArgs} args - Arguments to create many LabInstruments.
     * @example
     * // Create many LabInstruments
     * const labInstrument = await prisma.labInstrument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabInstrumentCreateManyArgs>(args?: SelectSubset<T, LabInstrumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabInstruments and returns the data saved in the database.
     * @param {LabInstrumentCreateManyAndReturnArgs} args - Arguments to create many LabInstruments.
     * @example
     * // Create many LabInstruments
     * const labInstrument = await prisma.labInstrument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabInstruments and only return the `id`
     * const labInstrumentWithIdOnly = await prisma.labInstrument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabInstrumentCreateManyAndReturnArgs>(args?: SelectSubset<T, LabInstrumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabInstrument.
     * @param {LabInstrumentDeleteArgs} args - Arguments to delete one LabInstrument.
     * @example
     * // Delete one LabInstrument
     * const LabInstrument = await prisma.labInstrument.delete({
     *   where: {
     *     // ... filter to delete one LabInstrument
     *   }
     * })
     * 
     */
    delete<T extends LabInstrumentDeleteArgs>(args: SelectSubset<T, LabInstrumentDeleteArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabInstrument.
     * @param {LabInstrumentUpdateArgs} args - Arguments to update one LabInstrument.
     * @example
     * // Update one LabInstrument
     * const labInstrument = await prisma.labInstrument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabInstrumentUpdateArgs>(args: SelectSubset<T, LabInstrumentUpdateArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabInstruments.
     * @param {LabInstrumentDeleteManyArgs} args - Arguments to filter LabInstruments to delete.
     * @example
     * // Delete a few LabInstruments
     * const { count } = await prisma.labInstrument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabInstrumentDeleteManyArgs>(args?: SelectSubset<T, LabInstrumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabInstruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabInstruments
     * const labInstrument = await prisma.labInstrument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabInstrumentUpdateManyArgs>(args: SelectSubset<T, LabInstrumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabInstruments and returns the data updated in the database.
     * @param {LabInstrumentUpdateManyAndReturnArgs} args - Arguments to update many LabInstruments.
     * @example
     * // Update many LabInstruments
     * const labInstrument = await prisma.labInstrument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabInstruments and only return the `id`
     * const labInstrumentWithIdOnly = await prisma.labInstrument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabInstrumentUpdateManyAndReturnArgs>(args: SelectSubset<T, LabInstrumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabInstrument.
     * @param {LabInstrumentUpsertArgs} args - Arguments to update or create a LabInstrument.
     * @example
     * // Update or create a LabInstrument
     * const labInstrument = await prisma.labInstrument.upsert({
     *   create: {
     *     // ... data to create a LabInstrument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabInstrument we want to update
     *   }
     * })
     */
    upsert<T extends LabInstrumentUpsertArgs>(args: SelectSubset<T, LabInstrumentUpsertArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabInstruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentCountArgs} args - Arguments to filter LabInstruments to count.
     * @example
     * // Count the number of LabInstruments
     * const count = await prisma.labInstrument.count({
     *   where: {
     *     // ... the filter for the LabInstruments we want to count
     *   }
     * })
    **/
    count<T extends LabInstrumentCountArgs>(
      args?: Subset<T, LabInstrumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabInstrumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabInstrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabInstrumentAggregateArgs>(args: Subset<T, LabInstrumentAggregateArgs>): Prisma.PrismaPromise<GetLabInstrumentAggregateType<T>>

    /**
     * Group by LabInstrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabInstrumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabInstrumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabInstrumentGroupByArgs['orderBy'] }
        : { orderBy?: LabInstrumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabInstrumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabInstrumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabInstrument model
   */
  readonly fields: LabInstrumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabInstrument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabInstrumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LabInstrument$locationArgs<ExtArgs> = {}>(args?: Subset<T, LabInstrument$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    testsDefault<T extends LabInstrument$testsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabInstrument$testsDefaultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderTests<T extends LabInstrument$orderTestsArgs<ExtArgs> = {}>(args?: Subset<T, LabInstrument$orderTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends LabInstrument$messagesArgs<ExtArgs> = {}>(args?: Subset<T, LabInstrument$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabInstrument model
   */
  interface LabInstrumentFieldRefs {
    readonly id: FieldRef<"LabInstrument", 'String'>
    readonly name: FieldRef<"LabInstrument", 'String'>
    readonly vendor: FieldRef<"LabInstrument", 'String'>
    readonly model: FieldRef<"LabInstrument", 'String'>
    readonly serialNo: FieldRef<"LabInstrument", 'String'>
    readonly connectionType: FieldRef<"LabInstrument", 'ConnectionType'>
    readonly locationId: FieldRef<"LabInstrument", 'String'>
    readonly isActive: FieldRef<"LabInstrument", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LabInstrument findUnique
   */
  export type LabInstrumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which LabInstrument to fetch.
     */
    where: LabInstrumentWhereUniqueInput
  }

  /**
   * LabInstrument findUniqueOrThrow
   */
  export type LabInstrumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which LabInstrument to fetch.
     */
    where: LabInstrumentWhereUniqueInput
  }

  /**
   * LabInstrument findFirst
   */
  export type LabInstrumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which LabInstrument to fetch.
     */
    where?: LabInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabInstruments to fetch.
     */
    orderBy?: LabInstrumentOrderByWithRelationInput | LabInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabInstruments.
     */
    cursor?: LabInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabInstruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabInstruments.
     */
    distinct?: LabInstrumentScalarFieldEnum | LabInstrumentScalarFieldEnum[]
  }

  /**
   * LabInstrument findFirstOrThrow
   */
  export type LabInstrumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which LabInstrument to fetch.
     */
    where?: LabInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabInstruments to fetch.
     */
    orderBy?: LabInstrumentOrderByWithRelationInput | LabInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabInstruments.
     */
    cursor?: LabInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabInstruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabInstruments.
     */
    distinct?: LabInstrumentScalarFieldEnum | LabInstrumentScalarFieldEnum[]
  }

  /**
   * LabInstrument findMany
   */
  export type LabInstrumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which LabInstruments to fetch.
     */
    where?: LabInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabInstruments to fetch.
     */
    orderBy?: LabInstrumentOrderByWithRelationInput | LabInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabInstruments.
     */
    cursor?: LabInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabInstruments.
     */
    skip?: number
    distinct?: LabInstrumentScalarFieldEnum | LabInstrumentScalarFieldEnum[]
  }

  /**
   * LabInstrument create
   */
  export type LabInstrumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * The data needed to create a LabInstrument.
     */
    data: XOR<LabInstrumentCreateInput, LabInstrumentUncheckedCreateInput>
  }

  /**
   * LabInstrument createMany
   */
  export type LabInstrumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabInstruments.
     */
    data: LabInstrumentCreateManyInput | LabInstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabInstrument createManyAndReturn
   */
  export type LabInstrumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * The data used to create many LabInstruments.
     */
    data: LabInstrumentCreateManyInput | LabInstrumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabInstrument update
   */
  export type LabInstrumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * The data needed to update a LabInstrument.
     */
    data: XOR<LabInstrumentUpdateInput, LabInstrumentUncheckedUpdateInput>
    /**
     * Choose, which LabInstrument to update.
     */
    where: LabInstrumentWhereUniqueInput
  }

  /**
   * LabInstrument updateMany
   */
  export type LabInstrumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabInstruments.
     */
    data: XOR<LabInstrumentUpdateManyMutationInput, LabInstrumentUncheckedUpdateManyInput>
    /**
     * Filter which LabInstruments to update
     */
    where?: LabInstrumentWhereInput
    /**
     * Limit how many LabInstruments to update.
     */
    limit?: number
  }

  /**
   * LabInstrument updateManyAndReturn
   */
  export type LabInstrumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * The data used to update LabInstruments.
     */
    data: XOR<LabInstrumentUpdateManyMutationInput, LabInstrumentUncheckedUpdateManyInput>
    /**
     * Filter which LabInstruments to update
     */
    where?: LabInstrumentWhereInput
    /**
     * Limit how many LabInstruments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabInstrument upsert
   */
  export type LabInstrumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * The filter to search for the LabInstrument to update in case it exists.
     */
    where: LabInstrumentWhereUniqueInput
    /**
     * In case the LabInstrument found by the `where` argument doesn't exist, create a new LabInstrument with this data.
     */
    create: XOR<LabInstrumentCreateInput, LabInstrumentUncheckedCreateInput>
    /**
     * In case the LabInstrument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabInstrumentUpdateInput, LabInstrumentUncheckedUpdateInput>
  }

  /**
   * LabInstrument delete
   */
  export type LabInstrumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    /**
     * Filter which LabInstrument to delete.
     */
    where: LabInstrumentWhereUniqueInput
  }

  /**
   * LabInstrument deleteMany
   */
  export type LabInstrumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabInstruments to delete
     */
    where?: LabInstrumentWhereInput
    /**
     * Limit how many LabInstruments to delete.
     */
    limit?: number
  }

  /**
   * LabInstrument.location
   */
  export type LabInstrument$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * LabInstrument.testsDefault
   */
  export type LabInstrument$testsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    where?: TestCatalogWhereInput
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    cursor?: TestCatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCatalogScalarFieldEnum | TestCatalogScalarFieldEnum[]
  }

  /**
   * LabInstrument.orderTests
   */
  export type LabInstrument$orderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabInstrument.messages
   */
  export type LabInstrument$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    where?: LabDeviceMessageWhereInput
    orderBy?: LabDeviceMessageOrderByWithRelationInput | LabDeviceMessageOrderByWithRelationInput[]
    cursor?: LabDeviceMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabDeviceMessageScalarFieldEnum | LabDeviceMessageScalarFieldEnum[]
  }

  /**
   * LabInstrument without action
   */
  export type LabInstrumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
  }


  /**
   * Model SpecimenType
   */

  export type AggregateSpecimenType = {
    _count: SpecimenTypeCountAggregateOutputType | null
    _min: SpecimenTypeMinAggregateOutputType | null
    _max: SpecimenTypeMaxAggregateOutputType | null
  }

  export type SpecimenTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SpecimenTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SpecimenTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SpecimenTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SpecimenTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SpecimenTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SpecimenTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecimenType to aggregate.
     */
    where?: SpecimenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecimenTypes to fetch.
     */
    orderBy?: SpecimenTypeOrderByWithRelationInput | SpecimenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecimenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecimenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecimenTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecimenTypes
    **/
    _count?: true | SpecimenTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecimenTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecimenTypeMaxAggregateInputType
  }

  export type GetSpecimenTypeAggregateType<T extends SpecimenTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecimenType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecimenType[P]>
      : GetScalarType<T[P], AggregateSpecimenType[P]>
  }




  export type SpecimenTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecimenTypeWhereInput
    orderBy?: SpecimenTypeOrderByWithAggregationInput | SpecimenTypeOrderByWithAggregationInput[]
    by: SpecimenTypeScalarFieldEnum[] | SpecimenTypeScalarFieldEnum
    having?: SpecimenTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecimenTypeCountAggregateInputType | true
    _min?: SpecimenTypeMinAggregateInputType
    _max?: SpecimenTypeMaxAggregateInputType
  }

  export type SpecimenTypeGroupByOutputType = {
    id: string
    name: string
    _count: SpecimenTypeCountAggregateOutputType | null
    _min: SpecimenTypeMinAggregateOutputType | null
    _max: SpecimenTypeMaxAggregateOutputType | null
  }

  type GetSpecimenTypeGroupByPayload<T extends SpecimenTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecimenTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecimenTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecimenTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SpecimenTypeGroupByOutputType[P]>
        }
      >
    >


  export type SpecimenTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tests?: boolean | SpecimenType$testsArgs<ExtArgs>
    orders?: boolean | SpecimenType$ordersArgs<ExtArgs>
    _count?: boolean | SpecimenTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specimenType"]>

  export type SpecimenTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["specimenType"]>

  export type SpecimenTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["specimenType"]>

  export type SpecimenTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type SpecimenTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["specimenType"]>
  export type SpecimenTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | SpecimenType$testsArgs<ExtArgs>
    orders?: boolean | SpecimenType$ordersArgs<ExtArgs>
    _count?: boolean | SpecimenTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecimenTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpecimenTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpecimenTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecimenType"
    objects: {
      tests: Prisma.$TestCatalogPayload<ExtArgs>[]
      orders: Prisma.$LabOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["specimenType"]>
    composites: {}
  }

  type SpecimenTypeGetPayload<S extends boolean | null | undefined | SpecimenTypeDefaultArgs> = $Result.GetResult<Prisma.$SpecimenTypePayload, S>

  type SpecimenTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecimenTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecimenTypeCountAggregateInputType | true
    }

  export interface SpecimenTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecimenType'], meta: { name: 'SpecimenType' } }
    /**
     * Find zero or one SpecimenType that matches the filter.
     * @param {SpecimenTypeFindUniqueArgs} args - Arguments to find a SpecimenType
     * @example
     * // Get one SpecimenType
     * const specimenType = await prisma.specimenType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecimenTypeFindUniqueArgs>(args: SelectSubset<T, SpecimenTypeFindUniqueArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecimenType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecimenTypeFindUniqueOrThrowArgs} args - Arguments to find a SpecimenType
     * @example
     * // Get one SpecimenType
     * const specimenType = await prisma.specimenType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecimenTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecimenTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecimenType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeFindFirstArgs} args - Arguments to find a SpecimenType
     * @example
     * // Get one SpecimenType
     * const specimenType = await prisma.specimenType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecimenTypeFindFirstArgs>(args?: SelectSubset<T, SpecimenTypeFindFirstArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecimenType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeFindFirstOrThrowArgs} args - Arguments to find a SpecimenType
     * @example
     * // Get one SpecimenType
     * const specimenType = await prisma.specimenType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecimenTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecimenTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecimenTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecimenTypes
     * const specimenTypes = await prisma.specimenType.findMany()
     * 
     * // Get first 10 SpecimenTypes
     * const specimenTypes = await prisma.specimenType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specimenTypeWithIdOnly = await prisma.specimenType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecimenTypeFindManyArgs>(args?: SelectSubset<T, SpecimenTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecimenType.
     * @param {SpecimenTypeCreateArgs} args - Arguments to create a SpecimenType.
     * @example
     * // Create one SpecimenType
     * const SpecimenType = await prisma.specimenType.create({
     *   data: {
     *     // ... data to create a SpecimenType
     *   }
     * })
     * 
     */
    create<T extends SpecimenTypeCreateArgs>(args: SelectSubset<T, SpecimenTypeCreateArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecimenTypes.
     * @param {SpecimenTypeCreateManyArgs} args - Arguments to create many SpecimenTypes.
     * @example
     * // Create many SpecimenTypes
     * const specimenType = await prisma.specimenType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecimenTypeCreateManyArgs>(args?: SelectSubset<T, SpecimenTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecimenTypes and returns the data saved in the database.
     * @param {SpecimenTypeCreateManyAndReturnArgs} args - Arguments to create many SpecimenTypes.
     * @example
     * // Create many SpecimenTypes
     * const specimenType = await prisma.specimenType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecimenTypes and only return the `id`
     * const specimenTypeWithIdOnly = await prisma.specimenType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecimenTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecimenTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecimenType.
     * @param {SpecimenTypeDeleteArgs} args - Arguments to delete one SpecimenType.
     * @example
     * // Delete one SpecimenType
     * const SpecimenType = await prisma.specimenType.delete({
     *   where: {
     *     // ... filter to delete one SpecimenType
     *   }
     * })
     * 
     */
    delete<T extends SpecimenTypeDeleteArgs>(args: SelectSubset<T, SpecimenTypeDeleteArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecimenType.
     * @param {SpecimenTypeUpdateArgs} args - Arguments to update one SpecimenType.
     * @example
     * // Update one SpecimenType
     * const specimenType = await prisma.specimenType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecimenTypeUpdateArgs>(args: SelectSubset<T, SpecimenTypeUpdateArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecimenTypes.
     * @param {SpecimenTypeDeleteManyArgs} args - Arguments to filter SpecimenTypes to delete.
     * @example
     * // Delete a few SpecimenTypes
     * const { count } = await prisma.specimenType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecimenTypeDeleteManyArgs>(args?: SelectSubset<T, SpecimenTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecimenTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecimenTypes
     * const specimenType = await prisma.specimenType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecimenTypeUpdateManyArgs>(args: SelectSubset<T, SpecimenTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecimenTypes and returns the data updated in the database.
     * @param {SpecimenTypeUpdateManyAndReturnArgs} args - Arguments to update many SpecimenTypes.
     * @example
     * // Update many SpecimenTypes
     * const specimenType = await prisma.specimenType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecimenTypes and only return the `id`
     * const specimenTypeWithIdOnly = await prisma.specimenType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecimenTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecimenTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecimenType.
     * @param {SpecimenTypeUpsertArgs} args - Arguments to update or create a SpecimenType.
     * @example
     * // Update or create a SpecimenType
     * const specimenType = await prisma.specimenType.upsert({
     *   create: {
     *     // ... data to create a SpecimenType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecimenType we want to update
     *   }
     * })
     */
    upsert<T extends SpecimenTypeUpsertArgs>(args: SelectSubset<T, SpecimenTypeUpsertArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecimenTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeCountArgs} args - Arguments to filter SpecimenTypes to count.
     * @example
     * // Count the number of SpecimenTypes
     * const count = await prisma.specimenType.count({
     *   where: {
     *     // ... the filter for the SpecimenTypes we want to count
     *   }
     * })
    **/
    count<T extends SpecimenTypeCountArgs>(
      args?: Subset<T, SpecimenTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecimenTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecimenType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecimenTypeAggregateArgs>(args: Subset<T, SpecimenTypeAggregateArgs>): Prisma.PrismaPromise<GetSpecimenTypeAggregateType<T>>

    /**
     * Group by SpecimenType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecimenTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecimenTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecimenTypeGroupByArgs['orderBy'] }
        : { orderBy?: SpecimenTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecimenTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecimenTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecimenType model
   */
  readonly fields: SpecimenTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecimenType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecimenTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tests<T extends SpecimenType$testsArgs<ExtArgs> = {}>(args?: Subset<T, SpecimenType$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends SpecimenType$ordersArgs<ExtArgs> = {}>(args?: Subset<T, SpecimenType$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecimenType model
   */
  interface SpecimenTypeFieldRefs {
    readonly id: FieldRef<"SpecimenType", 'String'>
    readonly name: FieldRef<"SpecimenType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpecimenType findUnique
   */
  export type SpecimenTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpecimenType to fetch.
     */
    where: SpecimenTypeWhereUniqueInput
  }

  /**
   * SpecimenType findUniqueOrThrow
   */
  export type SpecimenTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpecimenType to fetch.
     */
    where: SpecimenTypeWhereUniqueInput
  }

  /**
   * SpecimenType findFirst
   */
  export type SpecimenTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpecimenType to fetch.
     */
    where?: SpecimenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecimenTypes to fetch.
     */
    orderBy?: SpecimenTypeOrderByWithRelationInput | SpecimenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecimenTypes.
     */
    cursor?: SpecimenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecimenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecimenTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecimenTypes.
     */
    distinct?: SpecimenTypeScalarFieldEnum | SpecimenTypeScalarFieldEnum[]
  }

  /**
   * SpecimenType findFirstOrThrow
   */
  export type SpecimenTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpecimenType to fetch.
     */
    where?: SpecimenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecimenTypes to fetch.
     */
    orderBy?: SpecimenTypeOrderByWithRelationInput | SpecimenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecimenTypes.
     */
    cursor?: SpecimenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecimenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecimenTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecimenTypes.
     */
    distinct?: SpecimenTypeScalarFieldEnum | SpecimenTypeScalarFieldEnum[]
  }

  /**
   * SpecimenType findMany
   */
  export type SpecimenTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * Filter, which SpecimenTypes to fetch.
     */
    where?: SpecimenTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecimenTypes to fetch.
     */
    orderBy?: SpecimenTypeOrderByWithRelationInput | SpecimenTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecimenTypes.
     */
    cursor?: SpecimenTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecimenTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecimenTypes.
     */
    skip?: number
    distinct?: SpecimenTypeScalarFieldEnum | SpecimenTypeScalarFieldEnum[]
  }

  /**
   * SpecimenType create
   */
  export type SpecimenTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecimenType.
     */
    data: XOR<SpecimenTypeCreateInput, SpecimenTypeUncheckedCreateInput>
  }

  /**
   * SpecimenType createMany
   */
  export type SpecimenTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecimenTypes.
     */
    data: SpecimenTypeCreateManyInput | SpecimenTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecimenType createManyAndReturn
   */
  export type SpecimenTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SpecimenTypes.
     */
    data: SpecimenTypeCreateManyInput | SpecimenTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecimenType update
   */
  export type SpecimenTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecimenType.
     */
    data: XOR<SpecimenTypeUpdateInput, SpecimenTypeUncheckedUpdateInput>
    /**
     * Choose, which SpecimenType to update.
     */
    where: SpecimenTypeWhereUniqueInput
  }

  /**
   * SpecimenType updateMany
   */
  export type SpecimenTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecimenTypes.
     */
    data: XOR<SpecimenTypeUpdateManyMutationInput, SpecimenTypeUncheckedUpdateManyInput>
    /**
     * Filter which SpecimenTypes to update
     */
    where?: SpecimenTypeWhereInput
    /**
     * Limit how many SpecimenTypes to update.
     */
    limit?: number
  }

  /**
   * SpecimenType updateManyAndReturn
   */
  export type SpecimenTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * The data used to update SpecimenTypes.
     */
    data: XOR<SpecimenTypeUpdateManyMutationInput, SpecimenTypeUncheckedUpdateManyInput>
    /**
     * Filter which SpecimenTypes to update
     */
    where?: SpecimenTypeWhereInput
    /**
     * Limit how many SpecimenTypes to update.
     */
    limit?: number
  }

  /**
   * SpecimenType upsert
   */
  export type SpecimenTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecimenType to update in case it exists.
     */
    where: SpecimenTypeWhereUniqueInput
    /**
     * In case the SpecimenType found by the `where` argument doesn't exist, create a new SpecimenType with this data.
     */
    create: XOR<SpecimenTypeCreateInput, SpecimenTypeUncheckedCreateInput>
    /**
     * In case the SpecimenType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecimenTypeUpdateInput, SpecimenTypeUncheckedUpdateInput>
  }

  /**
   * SpecimenType delete
   */
  export type SpecimenTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    /**
     * Filter which SpecimenType to delete.
     */
    where: SpecimenTypeWhereUniqueInput
  }

  /**
   * SpecimenType deleteMany
   */
  export type SpecimenTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecimenTypes to delete
     */
    where?: SpecimenTypeWhereInput
    /**
     * Limit how many SpecimenTypes to delete.
     */
    limit?: number
  }

  /**
   * SpecimenType.tests
   */
  export type SpecimenType$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    where?: TestCatalogWhereInput
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    cursor?: TestCatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCatalogScalarFieldEnum | TestCatalogScalarFieldEnum[]
  }

  /**
   * SpecimenType.orders
   */
  export type SpecimenType$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * SpecimenType without action
   */
  export type SpecimenTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
  }


  /**
   * Model TestCatalog
   */

  export type AggregateTestCatalog = {
    _count: TestCatalogCountAggregateOutputType | null
    _min: TestCatalogMinAggregateOutputType | null
    _max: TestCatalogMaxAggregateOutputType | null
  }

  export type TestCatalogMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    loincCode: string | null
    units: string | null
    specimenTypeId: string | null
    defaultInstrumentId: string | null
    isPanel: boolean | null
    parentPanelId: string | null
  }

  export type TestCatalogMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    loincCode: string | null
    units: string | null
    specimenTypeId: string | null
    defaultInstrumentId: string | null
    isPanel: boolean | null
    parentPanelId: string | null
  }

  export type TestCatalogCountAggregateOutputType = {
    id: number
    code: number
    name: number
    loincCode: number
    units: number
    specimenTypeId: number
    defaultInstrumentId: number
    isPanel: number
    parentPanelId: number
    _all: number
  }


  export type TestCatalogMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    loincCode?: true
    units?: true
    specimenTypeId?: true
    defaultInstrumentId?: true
    isPanel?: true
    parentPanelId?: true
  }

  export type TestCatalogMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    loincCode?: true
    units?: true
    specimenTypeId?: true
    defaultInstrumentId?: true
    isPanel?: true
    parentPanelId?: true
  }

  export type TestCatalogCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    loincCode?: true
    units?: true
    specimenTypeId?: true
    defaultInstrumentId?: true
    isPanel?: true
    parentPanelId?: true
    _all?: true
  }

  export type TestCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestCatalog to aggregate.
     */
    where?: TestCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCatalogs to fetch.
     */
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestCatalogs
    **/
    _count?: true | TestCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestCatalogMaxAggregateInputType
  }

  export type GetTestCatalogAggregateType<T extends TestCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateTestCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestCatalog[P]>
      : GetScalarType<T[P], AggregateTestCatalog[P]>
  }




  export type TestCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCatalogWhereInput
    orderBy?: TestCatalogOrderByWithAggregationInput | TestCatalogOrderByWithAggregationInput[]
    by: TestCatalogScalarFieldEnum[] | TestCatalogScalarFieldEnum
    having?: TestCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCatalogCountAggregateInputType | true
    _min?: TestCatalogMinAggregateInputType
    _max?: TestCatalogMaxAggregateInputType
  }

  export type TestCatalogGroupByOutputType = {
    id: string
    code: string
    name: string
    loincCode: string | null
    units: string | null
    specimenTypeId: string | null
    defaultInstrumentId: string | null
    isPanel: boolean
    parentPanelId: string | null
    _count: TestCatalogCountAggregateOutputType | null
    _min: TestCatalogMinAggregateOutputType | null
    _max: TestCatalogMaxAggregateOutputType | null
  }

  type GetTestCatalogGroupByPayload<T extends TestCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], TestCatalogGroupByOutputType[P]>
        }
      >
    >


  export type TestCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    loincCode?: boolean
    units?: boolean
    specimenTypeId?: boolean
    defaultInstrumentId?: boolean
    isPanel?: boolean
    parentPanelId?: boolean
    specimenType?: boolean | TestCatalog$specimenTypeArgs<ExtArgs>
    defaultInstrument?: boolean | TestCatalog$defaultInstrumentArgs<ExtArgs>
    parentPanel?: boolean | TestCatalog$parentPanelArgs<ExtArgs>
    panelMembers?: boolean | TestCatalog$panelMembersArgs<ExtArgs>
    ranges?: boolean | TestCatalog$rangesArgs<ExtArgs>
    orderTests?: boolean | TestCatalog$orderTestsArgs<ExtArgs>
    _count?: boolean | TestCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testCatalog"]>

  export type TestCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    loincCode?: boolean
    units?: boolean
    specimenTypeId?: boolean
    defaultInstrumentId?: boolean
    isPanel?: boolean
    parentPanelId?: boolean
    specimenType?: boolean | TestCatalog$specimenTypeArgs<ExtArgs>
    defaultInstrument?: boolean | TestCatalog$defaultInstrumentArgs<ExtArgs>
    parentPanel?: boolean | TestCatalog$parentPanelArgs<ExtArgs>
  }, ExtArgs["result"]["testCatalog"]>

  export type TestCatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    loincCode?: boolean
    units?: boolean
    specimenTypeId?: boolean
    defaultInstrumentId?: boolean
    isPanel?: boolean
    parentPanelId?: boolean
    specimenType?: boolean | TestCatalog$specimenTypeArgs<ExtArgs>
    defaultInstrument?: boolean | TestCatalog$defaultInstrumentArgs<ExtArgs>
    parentPanel?: boolean | TestCatalog$parentPanelArgs<ExtArgs>
  }, ExtArgs["result"]["testCatalog"]>

  export type TestCatalogSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    loincCode?: boolean
    units?: boolean
    specimenTypeId?: boolean
    defaultInstrumentId?: boolean
    isPanel?: boolean
    parentPanelId?: boolean
  }

  export type TestCatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "loincCode" | "units" | "specimenTypeId" | "defaultInstrumentId" | "isPanel" | "parentPanelId", ExtArgs["result"]["testCatalog"]>
  export type TestCatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specimenType?: boolean | TestCatalog$specimenTypeArgs<ExtArgs>
    defaultInstrument?: boolean | TestCatalog$defaultInstrumentArgs<ExtArgs>
    parentPanel?: boolean | TestCatalog$parentPanelArgs<ExtArgs>
    panelMembers?: boolean | TestCatalog$panelMembersArgs<ExtArgs>
    ranges?: boolean | TestCatalog$rangesArgs<ExtArgs>
    orderTests?: boolean | TestCatalog$orderTestsArgs<ExtArgs>
    _count?: boolean | TestCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestCatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specimenType?: boolean | TestCatalog$specimenTypeArgs<ExtArgs>
    defaultInstrument?: boolean | TestCatalog$defaultInstrumentArgs<ExtArgs>
    parentPanel?: boolean | TestCatalog$parentPanelArgs<ExtArgs>
  }
  export type TestCatalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specimenType?: boolean | TestCatalog$specimenTypeArgs<ExtArgs>
    defaultInstrument?: boolean | TestCatalog$defaultInstrumentArgs<ExtArgs>
    parentPanel?: boolean | TestCatalog$parentPanelArgs<ExtArgs>
  }

  export type $TestCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestCatalog"
    objects: {
      specimenType: Prisma.$SpecimenTypePayload<ExtArgs> | null
      defaultInstrument: Prisma.$LabInstrumentPayload<ExtArgs> | null
      parentPanel: Prisma.$TestCatalogPayload<ExtArgs> | null
      panelMembers: Prisma.$TestCatalogPayload<ExtArgs>[]
      ranges: Prisma.$ReferenceRangePayload<ExtArgs>[]
      orderTests: Prisma.$LabOrderTestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      loincCode: string | null
      units: string | null
      specimenTypeId: string | null
      defaultInstrumentId: string | null
      isPanel: boolean
      parentPanelId: string | null
    }, ExtArgs["result"]["testCatalog"]>
    composites: {}
  }

  type TestCatalogGetPayload<S extends boolean | null | undefined | TestCatalogDefaultArgs> = $Result.GetResult<Prisma.$TestCatalogPayload, S>

  type TestCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestCatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCatalogCountAggregateInputType | true
    }

  export interface TestCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestCatalog'], meta: { name: 'TestCatalog' } }
    /**
     * Find zero or one TestCatalog that matches the filter.
     * @param {TestCatalogFindUniqueArgs} args - Arguments to find a TestCatalog
     * @example
     * // Get one TestCatalog
     * const testCatalog = await prisma.testCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestCatalogFindUniqueArgs>(args: SelectSubset<T, TestCatalogFindUniqueArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestCatalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestCatalogFindUniqueOrThrowArgs} args - Arguments to find a TestCatalog
     * @example
     * // Get one TestCatalog
     * const testCatalog = await prisma.testCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, TestCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogFindFirstArgs} args - Arguments to find a TestCatalog
     * @example
     * // Get one TestCatalog
     * const testCatalog = await prisma.testCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestCatalogFindFirstArgs>(args?: SelectSubset<T, TestCatalogFindFirstArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogFindFirstOrThrowArgs} args - Arguments to find a TestCatalog
     * @example
     * // Get one TestCatalog
     * const testCatalog = await prisma.testCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, TestCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestCatalogs
     * const testCatalogs = await prisma.testCatalog.findMany()
     * 
     * // Get first 10 TestCatalogs
     * const testCatalogs = await prisma.testCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testCatalogWithIdOnly = await prisma.testCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestCatalogFindManyArgs>(args?: SelectSubset<T, TestCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestCatalog.
     * @param {TestCatalogCreateArgs} args - Arguments to create a TestCatalog.
     * @example
     * // Create one TestCatalog
     * const TestCatalog = await prisma.testCatalog.create({
     *   data: {
     *     // ... data to create a TestCatalog
     *   }
     * })
     * 
     */
    create<T extends TestCatalogCreateArgs>(args: SelectSubset<T, TestCatalogCreateArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestCatalogs.
     * @param {TestCatalogCreateManyArgs} args - Arguments to create many TestCatalogs.
     * @example
     * // Create many TestCatalogs
     * const testCatalog = await prisma.testCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCatalogCreateManyArgs>(args?: SelectSubset<T, TestCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestCatalogs and returns the data saved in the database.
     * @param {TestCatalogCreateManyAndReturnArgs} args - Arguments to create many TestCatalogs.
     * @example
     * // Create many TestCatalogs
     * const testCatalog = await prisma.testCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestCatalogs and only return the `id`
     * const testCatalogWithIdOnly = await prisma.testCatalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, TestCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestCatalog.
     * @param {TestCatalogDeleteArgs} args - Arguments to delete one TestCatalog.
     * @example
     * // Delete one TestCatalog
     * const TestCatalog = await prisma.testCatalog.delete({
     *   where: {
     *     // ... filter to delete one TestCatalog
     *   }
     * })
     * 
     */
    delete<T extends TestCatalogDeleteArgs>(args: SelectSubset<T, TestCatalogDeleteArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestCatalog.
     * @param {TestCatalogUpdateArgs} args - Arguments to update one TestCatalog.
     * @example
     * // Update one TestCatalog
     * const testCatalog = await prisma.testCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestCatalogUpdateArgs>(args: SelectSubset<T, TestCatalogUpdateArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestCatalogs.
     * @param {TestCatalogDeleteManyArgs} args - Arguments to filter TestCatalogs to delete.
     * @example
     * // Delete a few TestCatalogs
     * const { count } = await prisma.testCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestCatalogDeleteManyArgs>(args?: SelectSubset<T, TestCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestCatalogs
     * const testCatalog = await prisma.testCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestCatalogUpdateManyArgs>(args: SelectSubset<T, TestCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestCatalogs and returns the data updated in the database.
     * @param {TestCatalogUpdateManyAndReturnArgs} args - Arguments to update many TestCatalogs.
     * @example
     * // Update many TestCatalogs
     * const testCatalog = await prisma.testCatalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestCatalogs and only return the `id`
     * const testCatalogWithIdOnly = await prisma.testCatalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestCatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, TestCatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestCatalog.
     * @param {TestCatalogUpsertArgs} args - Arguments to update or create a TestCatalog.
     * @example
     * // Update or create a TestCatalog
     * const testCatalog = await prisma.testCatalog.upsert({
     *   create: {
     *     // ... data to create a TestCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestCatalog we want to update
     *   }
     * })
     */
    upsert<T extends TestCatalogUpsertArgs>(args: SelectSubset<T, TestCatalogUpsertArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogCountArgs} args - Arguments to filter TestCatalogs to count.
     * @example
     * // Count the number of TestCatalogs
     * const count = await prisma.testCatalog.count({
     *   where: {
     *     // ... the filter for the TestCatalogs we want to count
     *   }
     * })
    **/
    count<T extends TestCatalogCountArgs>(
      args?: Subset<T, TestCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestCatalogAggregateArgs>(args: Subset<T, TestCatalogAggregateArgs>): Prisma.PrismaPromise<GetTestCatalogAggregateType<T>>

    /**
     * Group by TestCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestCatalogGroupByArgs['orderBy'] }
        : { orderBy?: TestCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestCatalog model
   */
  readonly fields: TestCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specimenType<T extends TestCatalog$specimenTypeArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalog$specimenTypeArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    defaultInstrument<T extends TestCatalog$defaultInstrumentArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalog$defaultInstrumentArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentPanel<T extends TestCatalog$parentPanelArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalog$parentPanelArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    panelMembers<T extends TestCatalog$panelMembersArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalog$panelMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ranges<T extends TestCatalog$rangesArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalog$rangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderTests<T extends TestCatalog$orderTestsArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalog$orderTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestCatalog model
   */
  interface TestCatalogFieldRefs {
    readonly id: FieldRef<"TestCatalog", 'String'>
    readonly code: FieldRef<"TestCatalog", 'String'>
    readonly name: FieldRef<"TestCatalog", 'String'>
    readonly loincCode: FieldRef<"TestCatalog", 'String'>
    readonly units: FieldRef<"TestCatalog", 'String'>
    readonly specimenTypeId: FieldRef<"TestCatalog", 'String'>
    readonly defaultInstrumentId: FieldRef<"TestCatalog", 'String'>
    readonly isPanel: FieldRef<"TestCatalog", 'Boolean'>
    readonly parentPanelId: FieldRef<"TestCatalog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestCatalog findUnique
   */
  export type TestCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * Filter, which TestCatalog to fetch.
     */
    where: TestCatalogWhereUniqueInput
  }

  /**
   * TestCatalog findUniqueOrThrow
   */
  export type TestCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * Filter, which TestCatalog to fetch.
     */
    where: TestCatalogWhereUniqueInput
  }

  /**
   * TestCatalog findFirst
   */
  export type TestCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * Filter, which TestCatalog to fetch.
     */
    where?: TestCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCatalogs to fetch.
     */
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestCatalogs.
     */
    cursor?: TestCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestCatalogs.
     */
    distinct?: TestCatalogScalarFieldEnum | TestCatalogScalarFieldEnum[]
  }

  /**
   * TestCatalog findFirstOrThrow
   */
  export type TestCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * Filter, which TestCatalog to fetch.
     */
    where?: TestCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCatalogs to fetch.
     */
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestCatalogs.
     */
    cursor?: TestCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestCatalogs.
     */
    distinct?: TestCatalogScalarFieldEnum | TestCatalogScalarFieldEnum[]
  }

  /**
   * TestCatalog findMany
   */
  export type TestCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * Filter, which TestCatalogs to fetch.
     */
    where?: TestCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCatalogs to fetch.
     */
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestCatalogs.
     */
    cursor?: TestCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCatalogs.
     */
    skip?: number
    distinct?: TestCatalogScalarFieldEnum | TestCatalogScalarFieldEnum[]
  }

  /**
   * TestCatalog create
   */
  export type TestCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a TestCatalog.
     */
    data: XOR<TestCatalogCreateInput, TestCatalogUncheckedCreateInput>
  }

  /**
   * TestCatalog createMany
   */
  export type TestCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestCatalogs.
     */
    data: TestCatalogCreateManyInput | TestCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestCatalog createManyAndReturn
   */
  export type TestCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * The data used to create many TestCatalogs.
     */
    data: TestCatalogCreateManyInput | TestCatalogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestCatalog update
   */
  export type TestCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a TestCatalog.
     */
    data: XOR<TestCatalogUpdateInput, TestCatalogUncheckedUpdateInput>
    /**
     * Choose, which TestCatalog to update.
     */
    where: TestCatalogWhereUniqueInput
  }

  /**
   * TestCatalog updateMany
   */
  export type TestCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestCatalogs.
     */
    data: XOR<TestCatalogUpdateManyMutationInput, TestCatalogUncheckedUpdateManyInput>
    /**
     * Filter which TestCatalogs to update
     */
    where?: TestCatalogWhereInput
    /**
     * Limit how many TestCatalogs to update.
     */
    limit?: number
  }

  /**
   * TestCatalog updateManyAndReturn
   */
  export type TestCatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * The data used to update TestCatalogs.
     */
    data: XOR<TestCatalogUpdateManyMutationInput, TestCatalogUncheckedUpdateManyInput>
    /**
     * Filter which TestCatalogs to update
     */
    where?: TestCatalogWhereInput
    /**
     * Limit how many TestCatalogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestCatalog upsert
   */
  export type TestCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the TestCatalog to update in case it exists.
     */
    where: TestCatalogWhereUniqueInput
    /**
     * In case the TestCatalog found by the `where` argument doesn't exist, create a new TestCatalog with this data.
     */
    create: XOR<TestCatalogCreateInput, TestCatalogUncheckedCreateInput>
    /**
     * In case the TestCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestCatalogUpdateInput, TestCatalogUncheckedUpdateInput>
  }

  /**
   * TestCatalog delete
   */
  export type TestCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    /**
     * Filter which TestCatalog to delete.
     */
    where: TestCatalogWhereUniqueInput
  }

  /**
   * TestCatalog deleteMany
   */
  export type TestCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestCatalogs to delete
     */
    where?: TestCatalogWhereInput
    /**
     * Limit how many TestCatalogs to delete.
     */
    limit?: number
  }

  /**
   * TestCatalog.specimenType
   */
  export type TestCatalog$specimenTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    where?: SpecimenTypeWhereInput
  }

  /**
   * TestCatalog.defaultInstrument
   */
  export type TestCatalog$defaultInstrumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    where?: LabInstrumentWhereInput
  }

  /**
   * TestCatalog.parentPanel
   */
  export type TestCatalog$parentPanelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    where?: TestCatalogWhereInput
  }

  /**
   * TestCatalog.panelMembers
   */
  export type TestCatalog$panelMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
    where?: TestCatalogWhereInput
    orderBy?: TestCatalogOrderByWithRelationInput | TestCatalogOrderByWithRelationInput[]
    cursor?: TestCatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCatalogScalarFieldEnum | TestCatalogScalarFieldEnum[]
  }

  /**
   * TestCatalog.ranges
   */
  export type TestCatalog$rangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    where?: ReferenceRangeWhereInput
    orderBy?: ReferenceRangeOrderByWithRelationInput | ReferenceRangeOrderByWithRelationInput[]
    cursor?: ReferenceRangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceRangeScalarFieldEnum | ReferenceRangeScalarFieldEnum[]
  }

  /**
   * TestCatalog.orderTests
   */
  export type TestCatalog$orderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * TestCatalog without action
   */
  export type TestCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCatalog
     */
    select?: TestCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCatalog
     */
    omit?: TestCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCatalogInclude<ExtArgs> | null
  }


  /**
   * Model ReferenceRange
   */

  export type AggregateReferenceRange = {
    _count: ReferenceRangeCountAggregateOutputType | null
    _avg: ReferenceRangeAvgAggregateOutputType | null
    _sum: ReferenceRangeSumAggregateOutputType | null
    _min: ReferenceRangeMinAggregateOutputType | null
    _max: ReferenceRangeMaxAggregateOutputType | null
  }

  export type ReferenceRangeAvgAggregateOutputType = {
    ageMinYears: Decimal | null
    ageMaxYears: Decimal | null
    lowValue: Decimal | null
    highValue: Decimal | null
  }

  export type ReferenceRangeSumAggregateOutputType = {
    ageMinYears: Decimal | null
    ageMaxYears: Decimal | null
    lowValue: Decimal | null
    highValue: Decimal | null
  }

  export type ReferenceRangeMinAggregateOutputType = {
    id: string | null
    testId: string | null
    sex: $Enums.Sex | null
    ageMinYears: Decimal | null
    ageMaxYears: Decimal | null
    lowValue: Decimal | null
    highValue: Decimal | null
    notes: string | null
  }

  export type ReferenceRangeMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    sex: $Enums.Sex | null
    ageMinYears: Decimal | null
    ageMaxYears: Decimal | null
    lowValue: Decimal | null
    highValue: Decimal | null
    notes: string | null
  }

  export type ReferenceRangeCountAggregateOutputType = {
    id: number
    testId: number
    sex: number
    ageMinYears: number
    ageMaxYears: number
    lowValue: number
    highValue: number
    notes: number
    _all: number
  }


  export type ReferenceRangeAvgAggregateInputType = {
    ageMinYears?: true
    ageMaxYears?: true
    lowValue?: true
    highValue?: true
  }

  export type ReferenceRangeSumAggregateInputType = {
    ageMinYears?: true
    ageMaxYears?: true
    lowValue?: true
    highValue?: true
  }

  export type ReferenceRangeMinAggregateInputType = {
    id?: true
    testId?: true
    sex?: true
    ageMinYears?: true
    ageMaxYears?: true
    lowValue?: true
    highValue?: true
    notes?: true
  }

  export type ReferenceRangeMaxAggregateInputType = {
    id?: true
    testId?: true
    sex?: true
    ageMinYears?: true
    ageMaxYears?: true
    lowValue?: true
    highValue?: true
    notes?: true
  }

  export type ReferenceRangeCountAggregateInputType = {
    id?: true
    testId?: true
    sex?: true
    ageMinYears?: true
    ageMaxYears?: true
    lowValue?: true
    highValue?: true
    notes?: true
    _all?: true
  }

  export type ReferenceRangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceRange to aggregate.
     */
    where?: ReferenceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceRanges to fetch.
     */
    orderBy?: ReferenceRangeOrderByWithRelationInput | ReferenceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceRanges
    **/
    _count?: true | ReferenceRangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceRangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceRangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceRangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceRangeMaxAggregateInputType
  }

  export type GetReferenceRangeAggregateType<T extends ReferenceRangeAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceRange[P]>
      : GetScalarType<T[P], AggregateReferenceRange[P]>
  }




  export type ReferenceRangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceRangeWhereInput
    orderBy?: ReferenceRangeOrderByWithAggregationInput | ReferenceRangeOrderByWithAggregationInput[]
    by: ReferenceRangeScalarFieldEnum[] | ReferenceRangeScalarFieldEnum
    having?: ReferenceRangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceRangeCountAggregateInputType | true
    _avg?: ReferenceRangeAvgAggregateInputType
    _sum?: ReferenceRangeSumAggregateInputType
    _min?: ReferenceRangeMinAggregateInputType
    _max?: ReferenceRangeMaxAggregateInputType
  }

  export type ReferenceRangeGroupByOutputType = {
    id: string
    testId: string
    sex: $Enums.Sex | null
    ageMinYears: Decimal | null
    ageMaxYears: Decimal | null
    lowValue: Decimal | null
    highValue: Decimal | null
    notes: string | null
    _count: ReferenceRangeCountAggregateOutputType | null
    _avg: ReferenceRangeAvgAggregateOutputType | null
    _sum: ReferenceRangeSumAggregateOutputType | null
    _min: ReferenceRangeMinAggregateOutputType | null
    _max: ReferenceRangeMaxAggregateOutputType | null
  }

  type GetReferenceRangeGroupByPayload<T extends ReferenceRangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceRangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceRangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceRangeGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceRangeGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceRangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    sex?: boolean
    ageMinYears?: boolean
    ageMaxYears?: boolean
    lowValue?: boolean
    highValue?: boolean
    notes?: boolean
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceRange"]>

  export type ReferenceRangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    sex?: boolean
    ageMinYears?: boolean
    ageMaxYears?: boolean
    lowValue?: boolean
    highValue?: boolean
    notes?: boolean
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceRange"]>

  export type ReferenceRangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    sex?: boolean
    ageMinYears?: boolean
    ageMaxYears?: boolean
    lowValue?: boolean
    highValue?: boolean
    notes?: boolean
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceRange"]>

  export type ReferenceRangeSelectScalar = {
    id?: boolean
    testId?: boolean
    sex?: boolean
    ageMinYears?: boolean
    ageMaxYears?: boolean
    lowValue?: boolean
    highValue?: boolean
    notes?: boolean
  }

  export type ReferenceRangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "sex" | "ageMinYears" | "ageMaxYears" | "lowValue" | "highValue" | "notes", ExtArgs["result"]["referenceRange"]>
  export type ReferenceRangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
  }
  export type ReferenceRangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
  }
  export type ReferenceRangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
  }

  export type $ReferenceRangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferenceRange"
    objects: {
      test: Prisma.$TestCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      sex: $Enums.Sex | null
      ageMinYears: Prisma.Decimal | null
      ageMaxYears: Prisma.Decimal | null
      lowValue: Prisma.Decimal | null
      highValue: Prisma.Decimal | null
      notes: string | null
    }, ExtArgs["result"]["referenceRange"]>
    composites: {}
  }

  type ReferenceRangeGetPayload<S extends boolean | null | undefined | ReferenceRangeDefaultArgs> = $Result.GetResult<Prisma.$ReferenceRangePayload, S>

  type ReferenceRangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferenceRangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferenceRangeCountAggregateInputType | true
    }

  export interface ReferenceRangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferenceRange'], meta: { name: 'ReferenceRange' } }
    /**
     * Find zero or one ReferenceRange that matches the filter.
     * @param {ReferenceRangeFindUniqueArgs} args - Arguments to find a ReferenceRange
     * @example
     * // Get one ReferenceRange
     * const referenceRange = await prisma.referenceRange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceRangeFindUniqueArgs>(args: SelectSubset<T, ReferenceRangeFindUniqueArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferenceRange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferenceRangeFindUniqueOrThrowArgs} args - Arguments to find a ReferenceRange
     * @example
     * // Get one ReferenceRange
     * const referenceRange = await prisma.referenceRange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceRangeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceRangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceRange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeFindFirstArgs} args - Arguments to find a ReferenceRange
     * @example
     * // Get one ReferenceRange
     * const referenceRange = await prisma.referenceRange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceRangeFindFirstArgs>(args?: SelectSubset<T, ReferenceRangeFindFirstArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceRange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeFindFirstOrThrowArgs} args - Arguments to find a ReferenceRange
     * @example
     * // Get one ReferenceRange
     * const referenceRange = await prisma.referenceRange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceRangeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceRangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferenceRanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceRanges
     * const referenceRanges = await prisma.referenceRange.findMany()
     * 
     * // Get first 10 ReferenceRanges
     * const referenceRanges = await prisma.referenceRange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceRangeWithIdOnly = await prisma.referenceRange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferenceRangeFindManyArgs>(args?: SelectSubset<T, ReferenceRangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferenceRange.
     * @param {ReferenceRangeCreateArgs} args - Arguments to create a ReferenceRange.
     * @example
     * // Create one ReferenceRange
     * const ReferenceRange = await prisma.referenceRange.create({
     *   data: {
     *     // ... data to create a ReferenceRange
     *   }
     * })
     * 
     */
    create<T extends ReferenceRangeCreateArgs>(args: SelectSubset<T, ReferenceRangeCreateArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferenceRanges.
     * @param {ReferenceRangeCreateManyArgs} args - Arguments to create many ReferenceRanges.
     * @example
     * // Create many ReferenceRanges
     * const referenceRange = await prisma.referenceRange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceRangeCreateManyArgs>(args?: SelectSubset<T, ReferenceRangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferenceRanges and returns the data saved in the database.
     * @param {ReferenceRangeCreateManyAndReturnArgs} args - Arguments to create many ReferenceRanges.
     * @example
     * // Create many ReferenceRanges
     * const referenceRange = await prisma.referenceRange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferenceRanges and only return the `id`
     * const referenceRangeWithIdOnly = await prisma.referenceRange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferenceRangeCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferenceRangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReferenceRange.
     * @param {ReferenceRangeDeleteArgs} args - Arguments to delete one ReferenceRange.
     * @example
     * // Delete one ReferenceRange
     * const ReferenceRange = await prisma.referenceRange.delete({
     *   where: {
     *     // ... filter to delete one ReferenceRange
     *   }
     * })
     * 
     */
    delete<T extends ReferenceRangeDeleteArgs>(args: SelectSubset<T, ReferenceRangeDeleteArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferenceRange.
     * @param {ReferenceRangeUpdateArgs} args - Arguments to update one ReferenceRange.
     * @example
     * // Update one ReferenceRange
     * const referenceRange = await prisma.referenceRange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceRangeUpdateArgs>(args: SelectSubset<T, ReferenceRangeUpdateArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferenceRanges.
     * @param {ReferenceRangeDeleteManyArgs} args - Arguments to filter ReferenceRanges to delete.
     * @example
     * // Delete a few ReferenceRanges
     * const { count } = await prisma.referenceRange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceRangeDeleteManyArgs>(args?: SelectSubset<T, ReferenceRangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceRanges
     * const referenceRange = await prisma.referenceRange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceRangeUpdateManyArgs>(args: SelectSubset<T, ReferenceRangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceRanges and returns the data updated in the database.
     * @param {ReferenceRangeUpdateManyAndReturnArgs} args - Arguments to update many ReferenceRanges.
     * @example
     * // Update many ReferenceRanges
     * const referenceRange = await prisma.referenceRange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReferenceRanges and only return the `id`
     * const referenceRangeWithIdOnly = await prisma.referenceRange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferenceRangeUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferenceRangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReferenceRange.
     * @param {ReferenceRangeUpsertArgs} args - Arguments to update or create a ReferenceRange.
     * @example
     * // Update or create a ReferenceRange
     * const referenceRange = await prisma.referenceRange.upsert({
     *   create: {
     *     // ... data to create a ReferenceRange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceRange we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceRangeUpsertArgs>(args: SelectSubset<T, ReferenceRangeUpsertArgs<ExtArgs>>): Prisma__ReferenceRangeClient<$Result.GetResult<Prisma.$ReferenceRangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferenceRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeCountArgs} args - Arguments to filter ReferenceRanges to count.
     * @example
     * // Count the number of ReferenceRanges
     * const count = await prisma.referenceRange.count({
     *   where: {
     *     // ... the filter for the ReferenceRanges we want to count
     *   }
     * })
    **/
    count<T extends ReferenceRangeCountArgs>(
      args?: Subset<T, ReferenceRangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceRangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceRangeAggregateArgs>(args: Subset<T, ReferenceRangeAggregateArgs>): Prisma.PrismaPromise<GetReferenceRangeAggregateType<T>>

    /**
     * Group by ReferenceRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceRangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceRangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceRangeGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceRangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceRangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceRangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferenceRange model
   */
  readonly fields: ReferenceRangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceRange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceRangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends TestCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalogDefaultArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferenceRange model
   */
  interface ReferenceRangeFieldRefs {
    readonly id: FieldRef<"ReferenceRange", 'String'>
    readonly testId: FieldRef<"ReferenceRange", 'String'>
    readonly sex: FieldRef<"ReferenceRange", 'Sex'>
    readonly ageMinYears: FieldRef<"ReferenceRange", 'Decimal'>
    readonly ageMaxYears: FieldRef<"ReferenceRange", 'Decimal'>
    readonly lowValue: FieldRef<"ReferenceRange", 'Decimal'>
    readonly highValue: FieldRef<"ReferenceRange", 'Decimal'>
    readonly notes: FieldRef<"ReferenceRange", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReferenceRange findUnique
   */
  export type ReferenceRangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceRange to fetch.
     */
    where: ReferenceRangeWhereUniqueInput
  }

  /**
   * ReferenceRange findUniqueOrThrow
   */
  export type ReferenceRangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceRange to fetch.
     */
    where: ReferenceRangeWhereUniqueInput
  }

  /**
   * ReferenceRange findFirst
   */
  export type ReferenceRangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceRange to fetch.
     */
    where?: ReferenceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceRanges to fetch.
     */
    orderBy?: ReferenceRangeOrderByWithRelationInput | ReferenceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceRanges.
     */
    cursor?: ReferenceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceRanges.
     */
    distinct?: ReferenceRangeScalarFieldEnum | ReferenceRangeScalarFieldEnum[]
  }

  /**
   * ReferenceRange findFirstOrThrow
   */
  export type ReferenceRangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceRange to fetch.
     */
    where?: ReferenceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceRanges to fetch.
     */
    orderBy?: ReferenceRangeOrderByWithRelationInput | ReferenceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceRanges.
     */
    cursor?: ReferenceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceRanges.
     */
    distinct?: ReferenceRangeScalarFieldEnum | ReferenceRangeScalarFieldEnum[]
  }

  /**
   * ReferenceRange findMany
   */
  export type ReferenceRangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceRanges to fetch.
     */
    where?: ReferenceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceRanges to fetch.
     */
    orderBy?: ReferenceRangeOrderByWithRelationInput | ReferenceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceRanges.
     */
    cursor?: ReferenceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceRanges.
     */
    skip?: number
    distinct?: ReferenceRangeScalarFieldEnum | ReferenceRangeScalarFieldEnum[]
  }

  /**
   * ReferenceRange create
   */
  export type ReferenceRangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferenceRange.
     */
    data: XOR<ReferenceRangeCreateInput, ReferenceRangeUncheckedCreateInput>
  }

  /**
   * ReferenceRange createMany
   */
  export type ReferenceRangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferenceRanges.
     */
    data: ReferenceRangeCreateManyInput | ReferenceRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferenceRange createManyAndReturn
   */
  export type ReferenceRangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * The data used to create many ReferenceRanges.
     */
    data: ReferenceRangeCreateManyInput | ReferenceRangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferenceRange update
   */
  export type ReferenceRangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferenceRange.
     */
    data: XOR<ReferenceRangeUpdateInput, ReferenceRangeUncheckedUpdateInput>
    /**
     * Choose, which ReferenceRange to update.
     */
    where: ReferenceRangeWhereUniqueInput
  }

  /**
   * ReferenceRange updateMany
   */
  export type ReferenceRangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferenceRanges.
     */
    data: XOR<ReferenceRangeUpdateManyMutationInput, ReferenceRangeUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceRanges to update
     */
    where?: ReferenceRangeWhereInput
    /**
     * Limit how many ReferenceRanges to update.
     */
    limit?: number
  }

  /**
   * ReferenceRange updateManyAndReturn
   */
  export type ReferenceRangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * The data used to update ReferenceRanges.
     */
    data: XOR<ReferenceRangeUpdateManyMutationInput, ReferenceRangeUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceRanges to update
     */
    where?: ReferenceRangeWhereInput
    /**
     * Limit how many ReferenceRanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferenceRange upsert
   */
  export type ReferenceRangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferenceRange to update in case it exists.
     */
    where: ReferenceRangeWhereUniqueInput
    /**
     * In case the ReferenceRange found by the `where` argument doesn't exist, create a new ReferenceRange with this data.
     */
    create: XOR<ReferenceRangeCreateInput, ReferenceRangeUncheckedCreateInput>
    /**
     * In case the ReferenceRange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceRangeUpdateInput, ReferenceRangeUncheckedUpdateInput>
  }

  /**
   * ReferenceRange delete
   */
  export type ReferenceRangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
    /**
     * Filter which ReferenceRange to delete.
     */
    where: ReferenceRangeWhereUniqueInput
  }

  /**
   * ReferenceRange deleteMany
   */
  export type ReferenceRangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceRanges to delete
     */
    where?: ReferenceRangeWhereInput
    /**
     * Limit how many ReferenceRanges to delete.
     */
    limit?: number
  }

  /**
   * ReferenceRange without action
   */
  export type ReferenceRangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceRange
     */
    select?: ReferenceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceRange
     */
    omit?: ReferenceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceRangeInclude<ExtArgs> | null
  }


  /**
   * Model LabOrder
   */

  export type AggregateLabOrder = {
    _count: LabOrderCountAggregateOutputType | null
    _min: LabOrderMinAggregateOutputType | null
    _max: LabOrderMaxAggregateOutputType | null
  }

  export type LabOrderMinAggregateOutputType = {
    id: string | null
    accessionNo: string | null
    patientId: string | null
    orderingProviderId: string | null
    invoiceId: string | null
    preclinicId: string | null
    specimenTypeId: string | null
    collectionTime: Date | null
    collectedById: string | null
    priority: $Enums.Priority | null
    status: $Enums.LabOrderStatus | null
    notes: string | null
    requestContextId: string | null
  }

  export type LabOrderMaxAggregateOutputType = {
    id: string | null
    accessionNo: string | null
    patientId: string | null
    orderingProviderId: string | null
    invoiceId: string | null
    preclinicId: string | null
    specimenTypeId: string | null
    collectionTime: Date | null
    collectedById: string | null
    priority: $Enums.Priority | null
    status: $Enums.LabOrderStatus | null
    notes: string | null
    requestContextId: string | null
  }

  export type LabOrderCountAggregateOutputType = {
    id: number
    accessionNo: number
    patientId: number
    orderingProviderId: number
    invoiceId: number
    preclinicId: number
    specimenTypeId: number
    collectionTime: number
    collectedById: number
    priority: number
    status: number
    notes: number
    requestContextId: number
    _all: number
  }


  export type LabOrderMinAggregateInputType = {
    id?: true
    accessionNo?: true
    patientId?: true
    orderingProviderId?: true
    invoiceId?: true
    preclinicId?: true
    specimenTypeId?: true
    collectionTime?: true
    collectedById?: true
    priority?: true
    status?: true
    notes?: true
    requestContextId?: true
  }

  export type LabOrderMaxAggregateInputType = {
    id?: true
    accessionNo?: true
    patientId?: true
    orderingProviderId?: true
    invoiceId?: true
    preclinicId?: true
    specimenTypeId?: true
    collectionTime?: true
    collectedById?: true
    priority?: true
    status?: true
    notes?: true
    requestContextId?: true
  }

  export type LabOrderCountAggregateInputType = {
    id?: true
    accessionNo?: true
    patientId?: true
    orderingProviderId?: true
    invoiceId?: true
    preclinicId?: true
    specimenTypeId?: true
    collectionTime?: true
    collectedById?: true
    priority?: true
    status?: true
    notes?: true
    requestContextId?: true
    _all?: true
  }

  export type LabOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrder to aggregate.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabOrders
    **/
    _count?: true | LabOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabOrderMaxAggregateInputType
  }

  export type GetLabOrderAggregateType<T extends LabOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateLabOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabOrder[P]>
      : GetScalarType<T[P], AggregateLabOrder[P]>
  }




  export type LabOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithAggregationInput | LabOrderOrderByWithAggregationInput[]
    by: LabOrderScalarFieldEnum[] | LabOrderScalarFieldEnum
    having?: LabOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabOrderCountAggregateInputType | true
    _min?: LabOrderMinAggregateInputType
    _max?: LabOrderMaxAggregateInputType
  }

  export type LabOrderGroupByOutputType = {
    id: string
    accessionNo: string
    patientId: string
    orderingProviderId: string | null
    invoiceId: string | null
    preclinicId: string | null
    specimenTypeId: string | null
    collectionTime: Date | null
    collectedById: string | null
    priority: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes: string | null
    requestContextId: string
    _count: LabOrderCountAggregateOutputType | null
    _min: LabOrderMinAggregateOutputType | null
    _max: LabOrderMaxAggregateOutputType | null
  }

  type GetLabOrderGroupByPayload<T extends LabOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabOrderGroupByOutputType[P]>
            : GetScalarType<T[P], LabOrderGroupByOutputType[P]>
        }
      >
    >


  export type LabOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessionNo?: boolean
    patientId?: boolean
    orderingProviderId?: boolean
    invoiceId?: boolean
    preclinicId?: boolean
    specimenTypeId?: boolean
    collectionTime?: boolean
    collectedById?: boolean
    priority?: boolean
    status?: boolean
    notes?: boolean
    requestContextId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    orderingProvider?: boolean | LabOrder$orderingProviderArgs<ExtArgs>
    invoice?: boolean | LabOrder$invoiceArgs<ExtArgs>
    preclinic?: boolean | LabOrder$preclinicArgs<ExtArgs>
    specimenType?: boolean | LabOrder$specimenTypeArgs<ExtArgs>
    collectedBy?: boolean | LabOrder$collectedByArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
    tests?: boolean | LabOrder$testsArgs<ExtArgs>
    messages?: boolean | LabOrder$messagesArgs<ExtArgs>
    _count?: boolean | LabOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrder"]>

  export type LabOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessionNo?: boolean
    patientId?: boolean
    orderingProviderId?: boolean
    invoiceId?: boolean
    preclinicId?: boolean
    specimenTypeId?: boolean
    collectionTime?: boolean
    collectedById?: boolean
    priority?: boolean
    status?: boolean
    notes?: boolean
    requestContextId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    orderingProvider?: boolean | LabOrder$orderingProviderArgs<ExtArgs>
    invoice?: boolean | LabOrder$invoiceArgs<ExtArgs>
    preclinic?: boolean | LabOrder$preclinicArgs<ExtArgs>
    specimenType?: boolean | LabOrder$specimenTypeArgs<ExtArgs>
    collectedBy?: boolean | LabOrder$collectedByArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrder"]>

  export type LabOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessionNo?: boolean
    patientId?: boolean
    orderingProviderId?: boolean
    invoiceId?: boolean
    preclinicId?: boolean
    specimenTypeId?: boolean
    collectionTime?: boolean
    collectedById?: boolean
    priority?: boolean
    status?: boolean
    notes?: boolean
    requestContextId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    orderingProvider?: boolean | LabOrder$orderingProviderArgs<ExtArgs>
    invoice?: boolean | LabOrder$invoiceArgs<ExtArgs>
    preclinic?: boolean | LabOrder$preclinicArgs<ExtArgs>
    specimenType?: boolean | LabOrder$specimenTypeArgs<ExtArgs>
    collectedBy?: boolean | LabOrder$collectedByArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrder"]>

  export type LabOrderSelectScalar = {
    id?: boolean
    accessionNo?: boolean
    patientId?: boolean
    orderingProviderId?: boolean
    invoiceId?: boolean
    preclinicId?: boolean
    specimenTypeId?: boolean
    collectionTime?: boolean
    collectedById?: boolean
    priority?: boolean
    status?: boolean
    notes?: boolean
    requestContextId?: boolean
  }

  export type LabOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accessionNo" | "patientId" | "orderingProviderId" | "invoiceId" | "preclinicId" | "specimenTypeId" | "collectionTime" | "collectedById" | "priority" | "status" | "notes" | "requestContextId", ExtArgs["result"]["labOrder"]>
  export type LabOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    orderingProvider?: boolean | LabOrder$orderingProviderArgs<ExtArgs>
    invoice?: boolean | LabOrder$invoiceArgs<ExtArgs>
    preclinic?: boolean | LabOrder$preclinicArgs<ExtArgs>
    specimenType?: boolean | LabOrder$specimenTypeArgs<ExtArgs>
    collectedBy?: boolean | LabOrder$collectedByArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
    tests?: boolean | LabOrder$testsArgs<ExtArgs>
    messages?: boolean | LabOrder$messagesArgs<ExtArgs>
    _count?: boolean | LabOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    orderingProvider?: boolean | LabOrder$orderingProviderArgs<ExtArgs>
    invoice?: boolean | LabOrder$invoiceArgs<ExtArgs>
    preclinic?: boolean | LabOrder$preclinicArgs<ExtArgs>
    specimenType?: boolean | LabOrder$specimenTypeArgs<ExtArgs>
    collectedBy?: boolean | LabOrder$collectedByArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type LabOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    orderingProvider?: boolean | LabOrder$orderingProviderArgs<ExtArgs>
    invoice?: boolean | LabOrder$invoiceArgs<ExtArgs>
    preclinic?: boolean | LabOrder$preclinicArgs<ExtArgs>
    specimenType?: boolean | LabOrder$specimenTypeArgs<ExtArgs>
    collectedBy?: boolean | LabOrder$collectedByArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $LabOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabOrder"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      orderingProvider: Prisma.$UserPayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      preclinic: Prisma.$PreclinicPayload<ExtArgs> | null
      specimenType: Prisma.$SpecimenTypePayload<ExtArgs> | null
      collectedBy: Prisma.$UserPayload<ExtArgs> | null
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
      tests: Prisma.$LabOrderTestPayload<ExtArgs>[]
      messages: Prisma.$LabDeviceMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accessionNo: string
      patientId: string
      orderingProviderId: string | null
      invoiceId: string | null
      preclinicId: string | null
      specimenTypeId: string | null
      collectionTime: Date | null
      collectedById: string | null
      priority: $Enums.Priority | null
      status: $Enums.LabOrderStatus
      notes: string | null
      requestContextId: string
    }, ExtArgs["result"]["labOrder"]>
    composites: {}
  }

  type LabOrderGetPayload<S extends boolean | null | undefined | LabOrderDefaultArgs> = $Result.GetResult<Prisma.$LabOrderPayload, S>

  type LabOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabOrderCountAggregateInputType | true
    }

  export interface LabOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabOrder'], meta: { name: 'LabOrder' } }
    /**
     * Find zero or one LabOrder that matches the filter.
     * @param {LabOrderFindUniqueArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabOrderFindUniqueArgs>(args: SelectSubset<T, LabOrderFindUniqueArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabOrderFindUniqueOrThrowArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, LabOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderFindFirstArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabOrderFindFirstArgs>(args?: SelectSubset<T, LabOrderFindFirstArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderFindFirstOrThrowArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, LabOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabOrders
     * const labOrders = await prisma.labOrder.findMany()
     * 
     * // Get first 10 LabOrders
     * const labOrders = await prisma.labOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labOrderWithIdOnly = await prisma.labOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabOrderFindManyArgs>(args?: SelectSubset<T, LabOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabOrder.
     * @param {LabOrderCreateArgs} args - Arguments to create a LabOrder.
     * @example
     * // Create one LabOrder
     * const LabOrder = await prisma.labOrder.create({
     *   data: {
     *     // ... data to create a LabOrder
     *   }
     * })
     * 
     */
    create<T extends LabOrderCreateArgs>(args: SelectSubset<T, LabOrderCreateArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabOrders.
     * @param {LabOrderCreateManyArgs} args - Arguments to create many LabOrders.
     * @example
     * // Create many LabOrders
     * const labOrder = await prisma.labOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabOrderCreateManyArgs>(args?: SelectSubset<T, LabOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabOrders and returns the data saved in the database.
     * @param {LabOrderCreateManyAndReturnArgs} args - Arguments to create many LabOrders.
     * @example
     * // Create many LabOrders
     * const labOrder = await prisma.labOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabOrders and only return the `id`
     * const labOrderWithIdOnly = await prisma.labOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, LabOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabOrder.
     * @param {LabOrderDeleteArgs} args - Arguments to delete one LabOrder.
     * @example
     * // Delete one LabOrder
     * const LabOrder = await prisma.labOrder.delete({
     *   where: {
     *     // ... filter to delete one LabOrder
     *   }
     * })
     * 
     */
    delete<T extends LabOrderDeleteArgs>(args: SelectSubset<T, LabOrderDeleteArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabOrder.
     * @param {LabOrderUpdateArgs} args - Arguments to update one LabOrder.
     * @example
     * // Update one LabOrder
     * const labOrder = await prisma.labOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabOrderUpdateArgs>(args: SelectSubset<T, LabOrderUpdateArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabOrders.
     * @param {LabOrderDeleteManyArgs} args - Arguments to filter LabOrders to delete.
     * @example
     * // Delete a few LabOrders
     * const { count } = await prisma.labOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabOrderDeleteManyArgs>(args?: SelectSubset<T, LabOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabOrders
     * const labOrder = await prisma.labOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabOrderUpdateManyArgs>(args: SelectSubset<T, LabOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrders and returns the data updated in the database.
     * @param {LabOrderUpdateManyAndReturnArgs} args - Arguments to update many LabOrders.
     * @example
     * // Update many LabOrders
     * const labOrder = await prisma.labOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabOrders and only return the `id`
     * const labOrderWithIdOnly = await prisma.labOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, LabOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabOrder.
     * @param {LabOrderUpsertArgs} args - Arguments to update or create a LabOrder.
     * @example
     * // Update or create a LabOrder
     * const labOrder = await prisma.labOrder.upsert({
     *   create: {
     *     // ... data to create a LabOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabOrder we want to update
     *   }
     * })
     */
    upsert<T extends LabOrderUpsertArgs>(args: SelectSubset<T, LabOrderUpsertArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderCountArgs} args - Arguments to filter LabOrders to count.
     * @example
     * // Count the number of LabOrders
     * const count = await prisma.labOrder.count({
     *   where: {
     *     // ... the filter for the LabOrders we want to count
     *   }
     * })
    **/
    count<T extends LabOrderCountArgs>(
      args?: Subset<T, LabOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabOrderAggregateArgs>(args: Subset<T, LabOrderAggregateArgs>): Prisma.PrismaPromise<GetLabOrderAggregateType<T>>

    /**
     * Group by LabOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabOrderGroupByArgs['orderBy'] }
        : { orderBy?: LabOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabOrder model
   */
  readonly fields: LabOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderingProvider<T extends LabOrder$orderingProviderArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$orderingProviderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends LabOrder$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preclinic<T extends LabOrder$preclinicArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$preclinicArgs<ExtArgs>>): Prisma__PreclinicClient<$Result.GetResult<Prisma.$PreclinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    specimenType<T extends LabOrder$specimenTypeArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$specimenTypeArgs<ExtArgs>>): Prisma__SpecimenTypeClient<$Result.GetResult<Prisma.$SpecimenTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    collectedBy<T extends LabOrder$collectedByArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$collectedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tests<T extends LabOrder$testsArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends LabOrder$messagesArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabOrder model
   */
  interface LabOrderFieldRefs {
    readonly id: FieldRef<"LabOrder", 'String'>
    readonly accessionNo: FieldRef<"LabOrder", 'String'>
    readonly patientId: FieldRef<"LabOrder", 'String'>
    readonly orderingProviderId: FieldRef<"LabOrder", 'String'>
    readonly invoiceId: FieldRef<"LabOrder", 'String'>
    readonly preclinicId: FieldRef<"LabOrder", 'String'>
    readonly specimenTypeId: FieldRef<"LabOrder", 'String'>
    readonly collectionTime: FieldRef<"LabOrder", 'DateTime'>
    readonly collectedById: FieldRef<"LabOrder", 'String'>
    readonly priority: FieldRef<"LabOrder", 'Priority'>
    readonly status: FieldRef<"LabOrder", 'LabOrderStatus'>
    readonly notes: FieldRef<"LabOrder", 'String'>
    readonly requestContextId: FieldRef<"LabOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabOrder findUnique
   */
  export type LabOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder findUniqueOrThrow
   */
  export type LabOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder findFirst
   */
  export type LabOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrders.
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrders.
     */
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * LabOrder findFirstOrThrow
   */
  export type LabOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrders.
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrders.
     */
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * LabOrder findMany
   */
  export type LabOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrders to fetch.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabOrders.
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * LabOrder create
   */
  export type LabOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a LabOrder.
     */
    data: XOR<LabOrderCreateInput, LabOrderUncheckedCreateInput>
  }

  /**
   * LabOrder createMany
   */
  export type LabOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabOrders.
     */
    data: LabOrderCreateManyInput | LabOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabOrder createManyAndReturn
   */
  export type LabOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * The data used to create many LabOrders.
     */
    data: LabOrderCreateManyInput | LabOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrder update
   */
  export type LabOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a LabOrder.
     */
    data: XOR<LabOrderUpdateInput, LabOrderUncheckedUpdateInput>
    /**
     * Choose, which LabOrder to update.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder updateMany
   */
  export type LabOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabOrders.
     */
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyInput>
    /**
     * Filter which LabOrders to update
     */
    where?: LabOrderWhereInput
    /**
     * Limit how many LabOrders to update.
     */
    limit?: number
  }

  /**
   * LabOrder updateManyAndReturn
   */
  export type LabOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * The data used to update LabOrders.
     */
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyInput>
    /**
     * Filter which LabOrders to update
     */
    where?: LabOrderWhereInput
    /**
     * Limit how many LabOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrder upsert
   */
  export type LabOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the LabOrder to update in case it exists.
     */
    where: LabOrderWhereUniqueInput
    /**
     * In case the LabOrder found by the `where` argument doesn't exist, create a new LabOrder with this data.
     */
    create: XOR<LabOrderCreateInput, LabOrderUncheckedCreateInput>
    /**
     * In case the LabOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabOrderUpdateInput, LabOrderUncheckedUpdateInput>
  }

  /**
   * LabOrder delete
   */
  export type LabOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter which LabOrder to delete.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder deleteMany
   */
  export type LabOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrders to delete
     */
    where?: LabOrderWhereInput
    /**
     * Limit how many LabOrders to delete.
     */
    limit?: number
  }

  /**
   * LabOrder.orderingProvider
   */
  export type LabOrder$orderingProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LabOrder.invoice
   */
  export type LabOrder$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * LabOrder.preclinic
   */
  export type LabOrder$preclinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preclinic
     */
    select?: PreclinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preclinic
     */
    omit?: PreclinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreclinicInclude<ExtArgs> | null
    where?: PreclinicWhereInput
  }

  /**
   * LabOrder.specimenType
   */
  export type LabOrder$specimenTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecimenType
     */
    select?: SpecimenTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecimenType
     */
    omit?: SpecimenTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecimenTypeInclude<ExtArgs> | null
    where?: SpecimenTypeWhereInput
  }

  /**
   * LabOrder.collectedBy
   */
  export type LabOrder$collectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LabOrder.tests
   */
  export type LabOrder$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrder.messages
   */
  export type LabOrder$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    where?: LabDeviceMessageWhereInput
    orderBy?: LabDeviceMessageOrderByWithRelationInput | LabDeviceMessageOrderByWithRelationInput[]
    cursor?: LabDeviceMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabDeviceMessageScalarFieldEnum | LabDeviceMessageScalarFieldEnum[]
  }

  /**
   * LabOrder without action
   */
  export type LabOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
  }


  /**
   * Model LabOrderTest
   */

  export type AggregateLabOrderTest = {
    _count: LabOrderTestCountAggregateOutputType | null
    _avg: LabOrderTestAvgAggregateOutputType | null
    _sum: LabOrderTestSumAggregateOutputType | null
    _min: LabOrderTestMinAggregateOutputType | null
    _max: LabOrderTestMaxAggregateOutputType | null
  }

  export type LabOrderTestAvgAggregateOutputType = {
    resultValue: Decimal | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
  }

  export type LabOrderTestSumAggregateOutputType = {
    resultValue: Decimal | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
  }

  export type LabOrderTestMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    testId: string | null
    status: $Enums.LabOrderTestStatus | null
    instrumentId: string | null
    analyteCodeInstrument: string | null
    resultValue: Decimal | null
    resultText: string | null
    units: string | null
    flagAbnormal: $Enums.AbnormalFlag | null
    outOfRange: $Enums.OutOfRangeFlag | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    completedAt: Date | null
    resultNotes: string | null
    requestContextId: string | null
  }

  export type LabOrderTestMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    testId: string | null
    status: $Enums.LabOrderTestStatus | null
    instrumentId: string | null
    analyteCodeInstrument: string | null
    resultValue: Decimal | null
    resultText: string | null
    units: string | null
    flagAbnormal: $Enums.AbnormalFlag | null
    outOfRange: $Enums.OutOfRangeFlag | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    completedAt: Date | null
    resultNotes: string | null
    requestContextId: string | null
  }

  export type LabOrderTestCountAggregateOutputType = {
    id: number
    orderId: number
    testId: number
    status: number
    instrumentId: number
    analyteCodeInstrument: number
    resultValue: number
    resultText: number
    units: number
    flagAbnormal: number
    outOfRange: number
    referenceLow: number
    referenceHigh: number
    completedAt: number
    resultNotes: number
    requestContextId: number
    _all: number
  }


  export type LabOrderTestAvgAggregateInputType = {
    resultValue?: true
    referenceLow?: true
    referenceHigh?: true
  }

  export type LabOrderTestSumAggregateInputType = {
    resultValue?: true
    referenceLow?: true
    referenceHigh?: true
  }

  export type LabOrderTestMinAggregateInputType = {
    id?: true
    orderId?: true
    testId?: true
    status?: true
    instrumentId?: true
    analyteCodeInstrument?: true
    resultValue?: true
    resultText?: true
    units?: true
    flagAbnormal?: true
    outOfRange?: true
    referenceLow?: true
    referenceHigh?: true
    completedAt?: true
    resultNotes?: true
    requestContextId?: true
  }

  export type LabOrderTestMaxAggregateInputType = {
    id?: true
    orderId?: true
    testId?: true
    status?: true
    instrumentId?: true
    analyteCodeInstrument?: true
    resultValue?: true
    resultText?: true
    units?: true
    flagAbnormal?: true
    outOfRange?: true
    referenceLow?: true
    referenceHigh?: true
    completedAt?: true
    resultNotes?: true
    requestContextId?: true
  }

  export type LabOrderTestCountAggregateInputType = {
    id?: true
    orderId?: true
    testId?: true
    status?: true
    instrumentId?: true
    analyteCodeInstrument?: true
    resultValue?: true
    resultText?: true
    units?: true
    flagAbnormal?: true
    outOfRange?: true
    referenceLow?: true
    referenceHigh?: true
    completedAt?: true
    resultNotes?: true
    requestContextId?: true
    _all?: true
  }

  export type LabOrderTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrderTest to aggregate.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabOrderTests
    **/
    _count?: true | LabOrderTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabOrderTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabOrderTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabOrderTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabOrderTestMaxAggregateInputType
  }

  export type GetLabOrderTestAggregateType<T extends LabOrderTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLabOrderTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabOrderTest[P]>
      : GetScalarType<T[P], AggregateLabOrderTest[P]>
  }




  export type LabOrderTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithAggregationInput | LabOrderTestOrderByWithAggregationInput[]
    by: LabOrderTestScalarFieldEnum[] | LabOrderTestScalarFieldEnum
    having?: LabOrderTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabOrderTestCountAggregateInputType | true
    _avg?: LabOrderTestAvgAggregateInputType
    _sum?: LabOrderTestSumAggregateInputType
    _min?: LabOrderTestMinAggregateInputType
    _max?: LabOrderTestMaxAggregateInputType
  }

  export type LabOrderTestGroupByOutputType = {
    id: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId: string | null
    analyteCodeInstrument: string | null
    resultValue: Decimal | null
    resultText: string | null
    units: string | null
    flagAbnormal: $Enums.AbnormalFlag | null
    outOfRange: $Enums.OutOfRangeFlag | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    completedAt: Date | null
    resultNotes: string | null
    requestContextId: string
    _count: LabOrderTestCountAggregateOutputType | null
    _avg: LabOrderTestAvgAggregateOutputType | null
    _sum: LabOrderTestSumAggregateOutputType | null
    _min: LabOrderTestMinAggregateOutputType | null
    _max: LabOrderTestMaxAggregateOutputType | null
  }

  type GetLabOrderTestGroupByPayload<T extends LabOrderTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabOrderTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabOrderTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabOrderTestGroupByOutputType[P]>
            : GetScalarType<T[P], LabOrderTestGroupByOutputType[P]>
        }
      >
    >


  export type LabOrderTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    instrumentId?: boolean
    analyteCodeInstrument?: boolean
    resultValue?: boolean
    resultText?: boolean
    units?: boolean
    flagAbnormal?: boolean
    outOfRange?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    completedAt?: boolean
    resultNotes?: boolean
    requestContextId?: boolean
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
    instrument?: boolean | LabOrderTest$instrumentArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrderTest"]>

  export type LabOrderTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    instrumentId?: boolean
    analyteCodeInstrument?: boolean
    resultValue?: boolean
    resultText?: boolean
    units?: boolean
    flagAbnormal?: boolean
    outOfRange?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    completedAt?: boolean
    resultNotes?: boolean
    requestContextId?: boolean
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
    instrument?: boolean | LabOrderTest$instrumentArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrderTest"]>

  export type LabOrderTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    instrumentId?: boolean
    analyteCodeInstrument?: boolean
    resultValue?: boolean
    resultText?: boolean
    units?: boolean
    flagAbnormal?: boolean
    outOfRange?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    completedAt?: boolean
    resultNotes?: boolean
    requestContextId?: boolean
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
    instrument?: boolean | LabOrderTest$instrumentArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrderTest"]>

  export type LabOrderTestSelectScalar = {
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    instrumentId?: boolean
    analyteCodeInstrument?: boolean
    resultValue?: boolean
    resultText?: boolean
    units?: boolean
    flagAbnormal?: boolean
    outOfRange?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    completedAt?: boolean
    resultNotes?: boolean
    requestContextId?: boolean
  }

  export type LabOrderTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "testId" | "status" | "instrumentId" | "analyteCodeInstrument" | "resultValue" | "resultText" | "units" | "flagAbnormal" | "outOfRange" | "referenceLow" | "referenceHigh" | "completedAt" | "resultNotes" | "requestContextId", ExtArgs["result"]["labOrderTest"]>
  export type LabOrderTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
    instrument?: boolean | LabOrderTest$instrumentArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type LabOrderTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
    instrument?: boolean | LabOrderTest$instrumentArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type LabOrderTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
    test?: boolean | TestCatalogDefaultArgs<ExtArgs>
    instrument?: boolean | LabOrderTest$instrumentArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $LabOrderTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabOrderTest"
    objects: {
      order: Prisma.$LabOrderPayload<ExtArgs>
      test: Prisma.$TestCatalogPayload<ExtArgs>
      instrument: Prisma.$LabInstrumentPayload<ExtArgs> | null
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      testId: string
      status: $Enums.LabOrderTestStatus
      instrumentId: string | null
      analyteCodeInstrument: string | null
      resultValue: Prisma.Decimal | null
      resultText: string | null
      units: string | null
      flagAbnormal: $Enums.AbnormalFlag | null
      outOfRange: $Enums.OutOfRangeFlag | null
      referenceLow: Prisma.Decimal | null
      referenceHigh: Prisma.Decimal | null
      completedAt: Date | null
      resultNotes: string | null
      requestContextId: string
    }, ExtArgs["result"]["labOrderTest"]>
    composites: {}
  }

  type LabOrderTestGetPayload<S extends boolean | null | undefined | LabOrderTestDefaultArgs> = $Result.GetResult<Prisma.$LabOrderTestPayload, S>

  type LabOrderTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabOrderTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabOrderTestCountAggregateInputType | true
    }

  export interface LabOrderTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabOrderTest'], meta: { name: 'LabOrderTest' } }
    /**
     * Find zero or one LabOrderTest that matches the filter.
     * @param {LabOrderTestFindUniqueArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabOrderTestFindUniqueArgs>(args: SelectSubset<T, LabOrderTestFindUniqueArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabOrderTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabOrderTestFindUniqueOrThrowArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabOrderTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LabOrderTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrderTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestFindFirstArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabOrderTestFindFirstArgs>(args?: SelectSubset<T, LabOrderTestFindFirstArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrderTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestFindFirstOrThrowArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabOrderTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LabOrderTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabOrderTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabOrderTests
     * const labOrderTests = await prisma.labOrderTest.findMany()
     * 
     * // Get first 10 LabOrderTests
     * const labOrderTests = await prisma.labOrderTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labOrderTestWithIdOnly = await prisma.labOrderTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabOrderTestFindManyArgs>(args?: SelectSubset<T, LabOrderTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabOrderTest.
     * @param {LabOrderTestCreateArgs} args - Arguments to create a LabOrderTest.
     * @example
     * // Create one LabOrderTest
     * const LabOrderTest = await prisma.labOrderTest.create({
     *   data: {
     *     // ... data to create a LabOrderTest
     *   }
     * })
     * 
     */
    create<T extends LabOrderTestCreateArgs>(args: SelectSubset<T, LabOrderTestCreateArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabOrderTests.
     * @param {LabOrderTestCreateManyArgs} args - Arguments to create many LabOrderTests.
     * @example
     * // Create many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabOrderTestCreateManyArgs>(args?: SelectSubset<T, LabOrderTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabOrderTests and returns the data saved in the database.
     * @param {LabOrderTestCreateManyAndReturnArgs} args - Arguments to create many LabOrderTests.
     * @example
     * // Create many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabOrderTests and only return the `id`
     * const labOrderTestWithIdOnly = await prisma.labOrderTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabOrderTestCreateManyAndReturnArgs>(args?: SelectSubset<T, LabOrderTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabOrderTest.
     * @param {LabOrderTestDeleteArgs} args - Arguments to delete one LabOrderTest.
     * @example
     * // Delete one LabOrderTest
     * const LabOrderTest = await prisma.labOrderTest.delete({
     *   where: {
     *     // ... filter to delete one LabOrderTest
     *   }
     * })
     * 
     */
    delete<T extends LabOrderTestDeleteArgs>(args: SelectSubset<T, LabOrderTestDeleteArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabOrderTest.
     * @param {LabOrderTestUpdateArgs} args - Arguments to update one LabOrderTest.
     * @example
     * // Update one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabOrderTestUpdateArgs>(args: SelectSubset<T, LabOrderTestUpdateArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabOrderTests.
     * @param {LabOrderTestDeleteManyArgs} args - Arguments to filter LabOrderTests to delete.
     * @example
     * // Delete a few LabOrderTests
     * const { count } = await prisma.labOrderTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabOrderTestDeleteManyArgs>(args?: SelectSubset<T, LabOrderTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrderTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabOrderTestUpdateManyArgs>(args: SelectSubset<T, LabOrderTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrderTests and returns the data updated in the database.
     * @param {LabOrderTestUpdateManyAndReturnArgs} args - Arguments to update many LabOrderTests.
     * @example
     * // Update many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabOrderTests and only return the `id`
     * const labOrderTestWithIdOnly = await prisma.labOrderTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabOrderTestUpdateManyAndReturnArgs>(args: SelectSubset<T, LabOrderTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabOrderTest.
     * @param {LabOrderTestUpsertArgs} args - Arguments to update or create a LabOrderTest.
     * @example
     * // Update or create a LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.upsert({
     *   create: {
     *     // ... data to create a LabOrderTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabOrderTest we want to update
     *   }
     * })
     */
    upsert<T extends LabOrderTestUpsertArgs>(args: SelectSubset<T, LabOrderTestUpsertArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabOrderTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestCountArgs} args - Arguments to filter LabOrderTests to count.
     * @example
     * // Count the number of LabOrderTests
     * const count = await prisma.labOrderTest.count({
     *   where: {
     *     // ... the filter for the LabOrderTests we want to count
     *   }
     * })
    **/
    count<T extends LabOrderTestCountArgs>(
      args?: Subset<T, LabOrderTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabOrderTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabOrderTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabOrderTestAggregateArgs>(args: Subset<T, LabOrderTestAggregateArgs>): Prisma.PrismaPromise<GetLabOrderTestAggregateType<T>>

    /**
     * Group by LabOrderTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabOrderTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabOrderTestGroupByArgs['orderBy'] }
        : { orderBy?: LabOrderTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabOrderTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabOrderTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabOrderTest model
   */
  readonly fields: LabOrderTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabOrderTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabOrderTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends LabOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabOrderDefaultArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test<T extends TestCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestCatalogDefaultArgs<ExtArgs>>): Prisma__TestCatalogClient<$Result.GetResult<Prisma.$TestCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instrument<T extends LabOrderTest$instrumentArgs<ExtArgs> = {}>(args?: Subset<T, LabOrderTest$instrumentArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabOrderTest model
   */
  interface LabOrderTestFieldRefs {
    readonly id: FieldRef<"LabOrderTest", 'String'>
    readonly orderId: FieldRef<"LabOrderTest", 'String'>
    readonly testId: FieldRef<"LabOrderTest", 'String'>
    readonly status: FieldRef<"LabOrderTest", 'LabOrderTestStatus'>
    readonly instrumentId: FieldRef<"LabOrderTest", 'String'>
    readonly analyteCodeInstrument: FieldRef<"LabOrderTest", 'String'>
    readonly resultValue: FieldRef<"LabOrderTest", 'Decimal'>
    readonly resultText: FieldRef<"LabOrderTest", 'String'>
    readonly units: FieldRef<"LabOrderTest", 'String'>
    readonly flagAbnormal: FieldRef<"LabOrderTest", 'AbnormalFlag'>
    readonly outOfRange: FieldRef<"LabOrderTest", 'OutOfRangeFlag'>
    readonly referenceLow: FieldRef<"LabOrderTest", 'Decimal'>
    readonly referenceHigh: FieldRef<"LabOrderTest", 'Decimal'>
    readonly completedAt: FieldRef<"LabOrderTest", 'DateTime'>
    readonly resultNotes: FieldRef<"LabOrderTest", 'String'>
    readonly requestContextId: FieldRef<"LabOrderTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabOrderTest findUnique
   */
  export type LabOrderTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest findUniqueOrThrow
   */
  export type LabOrderTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest findFirst
   */
  export type LabOrderTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrderTests.
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrderTests.
     */
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrderTest findFirstOrThrow
   */
  export type LabOrderTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrderTests.
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrderTests.
     */
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrderTest findMany
   */
  export type LabOrderTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTests to fetch.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabOrderTests.
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrderTest create
   */
  export type LabOrderTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LabOrderTest.
     */
    data: XOR<LabOrderTestCreateInput, LabOrderTestUncheckedCreateInput>
  }

  /**
   * LabOrderTest createMany
   */
  export type LabOrderTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabOrderTests.
     */
    data: LabOrderTestCreateManyInput | LabOrderTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabOrderTest createManyAndReturn
   */
  export type LabOrderTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * The data used to create many LabOrderTests.
     */
    data: LabOrderTestCreateManyInput | LabOrderTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrderTest update
   */
  export type LabOrderTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LabOrderTest.
     */
    data: XOR<LabOrderTestUpdateInput, LabOrderTestUncheckedUpdateInput>
    /**
     * Choose, which LabOrderTest to update.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest updateMany
   */
  export type LabOrderTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabOrderTests.
     */
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyInput>
    /**
     * Filter which LabOrderTests to update
     */
    where?: LabOrderTestWhereInput
    /**
     * Limit how many LabOrderTests to update.
     */
    limit?: number
  }

  /**
   * LabOrderTest updateManyAndReturn
   */
  export type LabOrderTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * The data used to update LabOrderTests.
     */
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyInput>
    /**
     * Filter which LabOrderTests to update
     */
    where?: LabOrderTestWhereInput
    /**
     * Limit how many LabOrderTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrderTest upsert
   */
  export type LabOrderTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LabOrderTest to update in case it exists.
     */
    where: LabOrderTestWhereUniqueInput
    /**
     * In case the LabOrderTest found by the `where` argument doesn't exist, create a new LabOrderTest with this data.
     */
    create: XOR<LabOrderTestCreateInput, LabOrderTestUncheckedCreateInput>
    /**
     * In case the LabOrderTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabOrderTestUpdateInput, LabOrderTestUncheckedUpdateInput>
  }

  /**
   * LabOrderTest delete
   */
  export type LabOrderTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter which LabOrderTest to delete.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest deleteMany
   */
  export type LabOrderTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrderTests to delete
     */
    where?: LabOrderTestWhereInput
    /**
     * Limit how many LabOrderTests to delete.
     */
    limit?: number
  }

  /**
   * LabOrderTest.instrument
   */
  export type LabOrderTest$instrumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabInstrument
     */
    select?: LabInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabInstrument
     */
    omit?: LabInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInstrumentInclude<ExtArgs> | null
    where?: LabInstrumentWhereInput
  }

  /**
   * LabOrderTest without action
   */
  export type LabOrderTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
  }


  /**
   * Model LabDeviceMessage
   */

  export type AggregateLabDeviceMessage = {
    _count: LabDeviceMessageCountAggregateOutputType | null
    _min: LabDeviceMessageMinAggregateOutputType | null
    _max: LabDeviceMessageMaxAggregateOutputType | null
  }

  export type LabDeviceMessageMinAggregateOutputType = {
    id: string | null
    instrumentId: string | null
    orderId: string | null
    receivedAt: Date | null
    protocol: $Enums.ProtocolKind | null
    rawContent: string | null
    parsedOk: boolean | null
  }

  export type LabDeviceMessageMaxAggregateOutputType = {
    id: string | null
    instrumentId: string | null
    orderId: string | null
    receivedAt: Date | null
    protocol: $Enums.ProtocolKind | null
    rawContent: string | null
    parsedOk: boolean | null
  }

  export type LabDeviceMessageCountAggregateOutputType = {
    id: number
    instrumentId: number
    orderId: number
    receivedAt: number
    protocol: number
    rawContent: number
    parsedOk: number
    _all: number
  }


  export type LabDeviceMessageMinAggregateInputType = {
    id?: true
    instrumentId?: true
    orderId?: true
    receivedAt?: true
    protocol?: true
    rawContent?: true
    parsedOk?: true
  }

  export type LabDeviceMessageMaxAggregateInputType = {
    id?: true
    instrumentId?: true
    orderId?: true
    receivedAt?: true
    protocol?: true
    rawContent?: true
    parsedOk?: true
  }

  export type LabDeviceMessageCountAggregateInputType = {
    id?: true
    instrumentId?: true
    orderId?: true
    receivedAt?: true
    protocol?: true
    rawContent?: true
    parsedOk?: true
    _all?: true
  }

  export type LabDeviceMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabDeviceMessage to aggregate.
     */
    where?: LabDeviceMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabDeviceMessages to fetch.
     */
    orderBy?: LabDeviceMessageOrderByWithRelationInput | LabDeviceMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabDeviceMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabDeviceMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabDeviceMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabDeviceMessages
    **/
    _count?: true | LabDeviceMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabDeviceMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabDeviceMessageMaxAggregateInputType
  }

  export type GetLabDeviceMessageAggregateType<T extends LabDeviceMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateLabDeviceMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabDeviceMessage[P]>
      : GetScalarType<T[P], AggregateLabDeviceMessage[P]>
  }




  export type LabDeviceMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabDeviceMessageWhereInput
    orderBy?: LabDeviceMessageOrderByWithAggregationInput | LabDeviceMessageOrderByWithAggregationInput[]
    by: LabDeviceMessageScalarFieldEnum[] | LabDeviceMessageScalarFieldEnum
    having?: LabDeviceMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabDeviceMessageCountAggregateInputType | true
    _min?: LabDeviceMessageMinAggregateInputType
    _max?: LabDeviceMessageMaxAggregateInputType
  }

  export type LabDeviceMessageGroupByOutputType = {
    id: string
    instrumentId: string
    orderId: string | null
    receivedAt: Date
    protocol: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk: boolean
    _count: LabDeviceMessageCountAggregateOutputType | null
    _min: LabDeviceMessageMinAggregateOutputType | null
    _max: LabDeviceMessageMaxAggregateOutputType | null
  }

  type GetLabDeviceMessageGroupByPayload<T extends LabDeviceMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabDeviceMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabDeviceMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabDeviceMessageGroupByOutputType[P]>
            : GetScalarType<T[P], LabDeviceMessageGroupByOutputType[P]>
        }
      >
    >


  export type LabDeviceMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrumentId?: boolean
    orderId?: boolean
    receivedAt?: boolean
    protocol?: boolean
    rawContent?: boolean
    parsedOk?: boolean
    instrument?: boolean | LabInstrumentDefaultArgs<ExtArgs>
    order?: boolean | LabDeviceMessage$orderArgs<ExtArgs>
  }, ExtArgs["result"]["labDeviceMessage"]>

  export type LabDeviceMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrumentId?: boolean
    orderId?: boolean
    receivedAt?: boolean
    protocol?: boolean
    rawContent?: boolean
    parsedOk?: boolean
    instrument?: boolean | LabInstrumentDefaultArgs<ExtArgs>
    order?: boolean | LabDeviceMessage$orderArgs<ExtArgs>
  }, ExtArgs["result"]["labDeviceMessage"]>

  export type LabDeviceMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrumentId?: boolean
    orderId?: boolean
    receivedAt?: boolean
    protocol?: boolean
    rawContent?: boolean
    parsedOk?: boolean
    instrument?: boolean | LabInstrumentDefaultArgs<ExtArgs>
    order?: boolean | LabDeviceMessage$orderArgs<ExtArgs>
  }, ExtArgs["result"]["labDeviceMessage"]>

  export type LabDeviceMessageSelectScalar = {
    id?: boolean
    instrumentId?: boolean
    orderId?: boolean
    receivedAt?: boolean
    protocol?: boolean
    rawContent?: boolean
    parsedOk?: boolean
  }

  export type LabDeviceMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instrumentId" | "orderId" | "receivedAt" | "protocol" | "rawContent" | "parsedOk", ExtArgs["result"]["labDeviceMessage"]>
  export type LabDeviceMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instrument?: boolean | LabInstrumentDefaultArgs<ExtArgs>
    order?: boolean | LabDeviceMessage$orderArgs<ExtArgs>
  }
  export type LabDeviceMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instrument?: boolean | LabInstrumentDefaultArgs<ExtArgs>
    order?: boolean | LabDeviceMessage$orderArgs<ExtArgs>
  }
  export type LabDeviceMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instrument?: boolean | LabInstrumentDefaultArgs<ExtArgs>
    order?: boolean | LabDeviceMessage$orderArgs<ExtArgs>
  }

  export type $LabDeviceMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabDeviceMessage"
    objects: {
      instrument: Prisma.$LabInstrumentPayload<ExtArgs>
      order: Prisma.$LabOrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instrumentId: string
      orderId: string | null
      receivedAt: Date
      protocol: $Enums.ProtocolKind | null
      rawContent: string
      parsedOk: boolean
    }, ExtArgs["result"]["labDeviceMessage"]>
    composites: {}
  }

  type LabDeviceMessageGetPayload<S extends boolean | null | undefined | LabDeviceMessageDefaultArgs> = $Result.GetResult<Prisma.$LabDeviceMessagePayload, S>

  type LabDeviceMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabDeviceMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabDeviceMessageCountAggregateInputType | true
    }

  export interface LabDeviceMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabDeviceMessage'], meta: { name: 'LabDeviceMessage' } }
    /**
     * Find zero or one LabDeviceMessage that matches the filter.
     * @param {LabDeviceMessageFindUniqueArgs} args - Arguments to find a LabDeviceMessage
     * @example
     * // Get one LabDeviceMessage
     * const labDeviceMessage = await prisma.labDeviceMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabDeviceMessageFindUniqueArgs>(args: SelectSubset<T, LabDeviceMessageFindUniqueArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabDeviceMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabDeviceMessageFindUniqueOrThrowArgs} args - Arguments to find a LabDeviceMessage
     * @example
     * // Get one LabDeviceMessage
     * const labDeviceMessage = await prisma.labDeviceMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabDeviceMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, LabDeviceMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabDeviceMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageFindFirstArgs} args - Arguments to find a LabDeviceMessage
     * @example
     * // Get one LabDeviceMessage
     * const labDeviceMessage = await prisma.labDeviceMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabDeviceMessageFindFirstArgs>(args?: SelectSubset<T, LabDeviceMessageFindFirstArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabDeviceMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageFindFirstOrThrowArgs} args - Arguments to find a LabDeviceMessage
     * @example
     * // Get one LabDeviceMessage
     * const labDeviceMessage = await prisma.labDeviceMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabDeviceMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, LabDeviceMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabDeviceMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabDeviceMessages
     * const labDeviceMessages = await prisma.labDeviceMessage.findMany()
     * 
     * // Get first 10 LabDeviceMessages
     * const labDeviceMessages = await prisma.labDeviceMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labDeviceMessageWithIdOnly = await prisma.labDeviceMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabDeviceMessageFindManyArgs>(args?: SelectSubset<T, LabDeviceMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabDeviceMessage.
     * @param {LabDeviceMessageCreateArgs} args - Arguments to create a LabDeviceMessage.
     * @example
     * // Create one LabDeviceMessage
     * const LabDeviceMessage = await prisma.labDeviceMessage.create({
     *   data: {
     *     // ... data to create a LabDeviceMessage
     *   }
     * })
     * 
     */
    create<T extends LabDeviceMessageCreateArgs>(args: SelectSubset<T, LabDeviceMessageCreateArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabDeviceMessages.
     * @param {LabDeviceMessageCreateManyArgs} args - Arguments to create many LabDeviceMessages.
     * @example
     * // Create many LabDeviceMessages
     * const labDeviceMessage = await prisma.labDeviceMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabDeviceMessageCreateManyArgs>(args?: SelectSubset<T, LabDeviceMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabDeviceMessages and returns the data saved in the database.
     * @param {LabDeviceMessageCreateManyAndReturnArgs} args - Arguments to create many LabDeviceMessages.
     * @example
     * // Create many LabDeviceMessages
     * const labDeviceMessage = await prisma.labDeviceMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabDeviceMessages and only return the `id`
     * const labDeviceMessageWithIdOnly = await prisma.labDeviceMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabDeviceMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, LabDeviceMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabDeviceMessage.
     * @param {LabDeviceMessageDeleteArgs} args - Arguments to delete one LabDeviceMessage.
     * @example
     * // Delete one LabDeviceMessage
     * const LabDeviceMessage = await prisma.labDeviceMessage.delete({
     *   where: {
     *     // ... filter to delete one LabDeviceMessage
     *   }
     * })
     * 
     */
    delete<T extends LabDeviceMessageDeleteArgs>(args: SelectSubset<T, LabDeviceMessageDeleteArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabDeviceMessage.
     * @param {LabDeviceMessageUpdateArgs} args - Arguments to update one LabDeviceMessage.
     * @example
     * // Update one LabDeviceMessage
     * const labDeviceMessage = await prisma.labDeviceMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabDeviceMessageUpdateArgs>(args: SelectSubset<T, LabDeviceMessageUpdateArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabDeviceMessages.
     * @param {LabDeviceMessageDeleteManyArgs} args - Arguments to filter LabDeviceMessages to delete.
     * @example
     * // Delete a few LabDeviceMessages
     * const { count } = await prisma.labDeviceMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabDeviceMessageDeleteManyArgs>(args?: SelectSubset<T, LabDeviceMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabDeviceMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabDeviceMessages
     * const labDeviceMessage = await prisma.labDeviceMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabDeviceMessageUpdateManyArgs>(args: SelectSubset<T, LabDeviceMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabDeviceMessages and returns the data updated in the database.
     * @param {LabDeviceMessageUpdateManyAndReturnArgs} args - Arguments to update many LabDeviceMessages.
     * @example
     * // Update many LabDeviceMessages
     * const labDeviceMessage = await prisma.labDeviceMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabDeviceMessages and only return the `id`
     * const labDeviceMessageWithIdOnly = await prisma.labDeviceMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabDeviceMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, LabDeviceMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabDeviceMessage.
     * @param {LabDeviceMessageUpsertArgs} args - Arguments to update or create a LabDeviceMessage.
     * @example
     * // Update or create a LabDeviceMessage
     * const labDeviceMessage = await prisma.labDeviceMessage.upsert({
     *   create: {
     *     // ... data to create a LabDeviceMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabDeviceMessage we want to update
     *   }
     * })
     */
    upsert<T extends LabDeviceMessageUpsertArgs>(args: SelectSubset<T, LabDeviceMessageUpsertArgs<ExtArgs>>): Prisma__LabDeviceMessageClient<$Result.GetResult<Prisma.$LabDeviceMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabDeviceMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageCountArgs} args - Arguments to filter LabDeviceMessages to count.
     * @example
     * // Count the number of LabDeviceMessages
     * const count = await prisma.labDeviceMessage.count({
     *   where: {
     *     // ... the filter for the LabDeviceMessages we want to count
     *   }
     * })
    **/
    count<T extends LabDeviceMessageCountArgs>(
      args?: Subset<T, LabDeviceMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabDeviceMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabDeviceMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabDeviceMessageAggregateArgs>(args: Subset<T, LabDeviceMessageAggregateArgs>): Prisma.PrismaPromise<GetLabDeviceMessageAggregateType<T>>

    /**
     * Group by LabDeviceMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabDeviceMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabDeviceMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabDeviceMessageGroupByArgs['orderBy'] }
        : { orderBy?: LabDeviceMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabDeviceMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabDeviceMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabDeviceMessage model
   */
  readonly fields: LabDeviceMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabDeviceMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabDeviceMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instrument<T extends LabInstrumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabInstrumentDefaultArgs<ExtArgs>>): Prisma__LabInstrumentClient<$Result.GetResult<Prisma.$LabInstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends LabDeviceMessage$orderArgs<ExtArgs> = {}>(args?: Subset<T, LabDeviceMessage$orderArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabDeviceMessage model
   */
  interface LabDeviceMessageFieldRefs {
    readonly id: FieldRef<"LabDeviceMessage", 'String'>
    readonly instrumentId: FieldRef<"LabDeviceMessage", 'String'>
    readonly orderId: FieldRef<"LabDeviceMessage", 'String'>
    readonly receivedAt: FieldRef<"LabDeviceMessage", 'DateTime'>
    readonly protocol: FieldRef<"LabDeviceMessage", 'ProtocolKind'>
    readonly rawContent: FieldRef<"LabDeviceMessage", 'String'>
    readonly parsedOk: FieldRef<"LabDeviceMessage", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LabDeviceMessage findUnique
   */
  export type LabDeviceMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * Filter, which LabDeviceMessage to fetch.
     */
    where: LabDeviceMessageWhereUniqueInput
  }

  /**
   * LabDeviceMessage findUniqueOrThrow
   */
  export type LabDeviceMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * Filter, which LabDeviceMessage to fetch.
     */
    where: LabDeviceMessageWhereUniqueInput
  }

  /**
   * LabDeviceMessage findFirst
   */
  export type LabDeviceMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * Filter, which LabDeviceMessage to fetch.
     */
    where?: LabDeviceMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabDeviceMessages to fetch.
     */
    orderBy?: LabDeviceMessageOrderByWithRelationInput | LabDeviceMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabDeviceMessages.
     */
    cursor?: LabDeviceMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabDeviceMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabDeviceMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabDeviceMessages.
     */
    distinct?: LabDeviceMessageScalarFieldEnum | LabDeviceMessageScalarFieldEnum[]
  }

  /**
   * LabDeviceMessage findFirstOrThrow
   */
  export type LabDeviceMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * Filter, which LabDeviceMessage to fetch.
     */
    where?: LabDeviceMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabDeviceMessages to fetch.
     */
    orderBy?: LabDeviceMessageOrderByWithRelationInput | LabDeviceMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabDeviceMessages.
     */
    cursor?: LabDeviceMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabDeviceMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabDeviceMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabDeviceMessages.
     */
    distinct?: LabDeviceMessageScalarFieldEnum | LabDeviceMessageScalarFieldEnum[]
  }

  /**
   * LabDeviceMessage findMany
   */
  export type LabDeviceMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * Filter, which LabDeviceMessages to fetch.
     */
    where?: LabDeviceMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabDeviceMessages to fetch.
     */
    orderBy?: LabDeviceMessageOrderByWithRelationInput | LabDeviceMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabDeviceMessages.
     */
    cursor?: LabDeviceMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabDeviceMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabDeviceMessages.
     */
    skip?: number
    distinct?: LabDeviceMessageScalarFieldEnum | LabDeviceMessageScalarFieldEnum[]
  }

  /**
   * LabDeviceMessage create
   */
  export type LabDeviceMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a LabDeviceMessage.
     */
    data: XOR<LabDeviceMessageCreateInput, LabDeviceMessageUncheckedCreateInput>
  }

  /**
   * LabDeviceMessage createMany
   */
  export type LabDeviceMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabDeviceMessages.
     */
    data: LabDeviceMessageCreateManyInput | LabDeviceMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabDeviceMessage createManyAndReturn
   */
  export type LabDeviceMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * The data used to create many LabDeviceMessages.
     */
    data: LabDeviceMessageCreateManyInput | LabDeviceMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabDeviceMessage update
   */
  export type LabDeviceMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a LabDeviceMessage.
     */
    data: XOR<LabDeviceMessageUpdateInput, LabDeviceMessageUncheckedUpdateInput>
    /**
     * Choose, which LabDeviceMessage to update.
     */
    where: LabDeviceMessageWhereUniqueInput
  }

  /**
   * LabDeviceMessage updateMany
   */
  export type LabDeviceMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabDeviceMessages.
     */
    data: XOR<LabDeviceMessageUpdateManyMutationInput, LabDeviceMessageUncheckedUpdateManyInput>
    /**
     * Filter which LabDeviceMessages to update
     */
    where?: LabDeviceMessageWhereInput
    /**
     * Limit how many LabDeviceMessages to update.
     */
    limit?: number
  }

  /**
   * LabDeviceMessage updateManyAndReturn
   */
  export type LabDeviceMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * The data used to update LabDeviceMessages.
     */
    data: XOR<LabDeviceMessageUpdateManyMutationInput, LabDeviceMessageUncheckedUpdateManyInput>
    /**
     * Filter which LabDeviceMessages to update
     */
    where?: LabDeviceMessageWhereInput
    /**
     * Limit how many LabDeviceMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabDeviceMessage upsert
   */
  export type LabDeviceMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the LabDeviceMessage to update in case it exists.
     */
    where: LabDeviceMessageWhereUniqueInput
    /**
     * In case the LabDeviceMessage found by the `where` argument doesn't exist, create a new LabDeviceMessage with this data.
     */
    create: XOR<LabDeviceMessageCreateInput, LabDeviceMessageUncheckedCreateInput>
    /**
     * In case the LabDeviceMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabDeviceMessageUpdateInput, LabDeviceMessageUncheckedUpdateInput>
  }

  /**
   * LabDeviceMessage delete
   */
  export type LabDeviceMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
    /**
     * Filter which LabDeviceMessage to delete.
     */
    where: LabDeviceMessageWhereUniqueInput
  }

  /**
   * LabDeviceMessage deleteMany
   */
  export type LabDeviceMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabDeviceMessages to delete
     */
    where?: LabDeviceMessageWhereInput
    /**
     * Limit how many LabDeviceMessages to delete.
     */
    limit?: number
  }

  /**
   * LabDeviceMessage.order
   */
  export type LabDeviceMessage$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
  }

  /**
   * LabDeviceMessage without action
   */
  export type LabDeviceMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabDeviceMessage
     */
    select?: LabDeviceMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabDeviceMessage
     */
    omit?: LabDeviceMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabDeviceMessageInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    actorId: string | null
    requestContextId: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    actorId: string | null
    requestContextId: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    entity: number
    entityId: number
    action: number
    actorId: number
    requestContextId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    action?: true
    actorId?: true
    requestContextId?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    action?: true
    actorId?: true
    requestContextId?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    action?: true
    actorId?: true
    requestContextId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    entity: string
    entityId: string
    action: string
    actorId: string
    requestContextId: string
    metadata: JsonValue | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    requestContextId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    requestContextId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    requestContextId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    requestContextId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity" | "entityId" | "action" | "actorId" | "requestContextId" | "metadata" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
    requestContext?: boolean | RequestContextDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs>
      requestContext: Prisma.$RequestContextPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity: string
      entityId: string
      action: string
      actorId: string
      requestContextId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestContext<T extends RequestContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestContextDefaultArgs<ExtArgs>>): Prisma__RequestContextClient<$Result.GetResult<Prisma.$RequestContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly entity: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly actorId: FieldRef<"ActivityLog", 'String'>
    readonly requestContextId: FieldRef<"ActivityLog", 'String'>
    readonly metadata: FieldRef<"ActivityLog", 'Json'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BootstrapScalarFieldEnum: {
    id: 'id',
    txt: 'txt'
  };

  export type BootstrapScalarFieldEnum = (typeof BootstrapScalarFieldEnum)[keyof typeof BootstrapScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const CashRegisterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    locationId: 'locationId'
  };

  export type CashRegisterScalarFieldEnum = (typeof CashRegisterScalarFieldEnum)[keyof typeof CashRegisterScalarFieldEnum]


  export const PosTerminalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    provider: 'provider',
    merchantId: 'merchantId',
    locationId: 'locationId'
  };

  export type PosTerminalScalarFieldEnum = (typeof PosTerminalScalarFieldEnum)[keyof typeof PosTerminalScalarFieldEnum]


  export const WorkstationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    locationId: 'locationId',
    type: 'type',
    macAddress: 'macAddress',
    allowedIpCidr: 'allowedIpCidr',
    isActive: 'isActive'
  };

  export type WorkstationScalarFieldEnum = (typeof WorkstationScalarFieldEnum)[keyof typeof WorkstationScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    mrn: 'mrn',
    nationalId: 'nationalId',
    firstName: 'firstName',
    lastName: 'lastName',
    dob: 'dob',
    sex: 'sex',
    maritalStatus: 'maritalStatus',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    region: 'region',
    country: 'country',
    bloodType: 'bloodType',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AuthSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    workstationId: 'workstationId',
    geoCountry: 'geoCountry',
    geoRegion: 'geoRegion',
    geoCity: 'geoCity',
    geoLat: 'geoLat',
    geoLon: 'geoLon',
    mfaPassed: 'mfaPassed'
  };

  export type AuthSessionScalarFieldEnum = (typeof AuthSessionScalarFieldEnum)[keyof typeof AuthSessionScalarFieldEnum]


  export const RequestContextScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    occurredAt: 'occurredAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    workstationId: 'workstationId',
    geoCountry: 'geoCountry',
    geoRegion: 'geoRegion',
    geoCity: 'geoCity',
    geoLat: 'geoLat',
    geoLon: 'geoLon'
  };

  export type RequestContextScalarFieldEnum = (typeof RequestContextScalarFieldEnum)[keyof typeof RequestContextScalarFieldEnum]


  export const PreclinicScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    visitDate: 'visitDate',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    heartRate: 'heartRate',
    respRate: 'respRate',
    temperatureC: 'temperatureC',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    bmi: 'bmi',
    chiefComplaint: 'chiefComplaint',
    currentMedications: 'currentMedications',
    diabetes: 'diabetes',
    hypertension: 'hypertension',
    otherConditions: 'otherConditions',
    allergiesReported: 'allergiesReported',
    recordedById: 'recordedById',
    requestContextId: 'requestContextId'
  };

  export type PreclinicScalarFieldEnum = (typeof PreclinicScalarFieldEnum)[keyof typeof PreclinicScalarFieldEnum]


  export const AllergyScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    substance: 'substance',
    reaction: 'reaction',
    severity: 'severity',
    recordedAt: 'recordedAt',
    recordedById: 'recordedById'
  };

  export type AllergyScalarFieldEnum = (typeof AllergyScalarFieldEnum)[keyof typeof AllergyScalarFieldEnum]


  export const ProblemScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    condition: 'condition',
    status: 'status',
    diagnosedAt: 'diagnosedAt',
    resolvedAt: 'resolvedAt',
    recordedById: 'recordedById'
  };

  export type ProblemScalarFieldEnum = (typeof ProblemScalarFieldEnum)[keyof typeof ProblemScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    drugName: 'drugName',
    dose: 'dose',
    frequency: 'frequency',
    route: 'route',
    startedAt: 'startedAt',
    stoppedAt: 'stoppedAt',
    prescribedById: 'prescribedById'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    categoryId: 'categoryId',
    price: 'price',
    taxRatePct: 'taxRatePct',
    commissionPct: 'commissionPct',
    requiresProvider: 'requiresProvider'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    specialty: 'specialty',
    defaultCommissionPct: 'defaultCommissionPct',
    isActive: 'isActive'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    patientId: 'patientId',
    preclinicId: 'preclinicId',
    status: 'status',
    invoiceAt: 'invoiceAt',
    locationId: 'locationId',
    cashierId: 'cashierId',
    registerId: 'registerId',
    requestContextId: 'requestContextId',
    subtotal: 'subtotal',
    discountTotal: 'discountTotal',
    taxTotal: 'taxTotal',
    total: 'total'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    lineNo: 'lineNo',
    itemType: 'itemType',
    serviceId: 'serviceId',
    productId: 'productId',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    discountPct: 'discountPct',
    taxRatePct: 'taxRatePct',
    lineTotal: 'lineTotal',
    providerId: 'providerId'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const ProviderCommissionScalarFieldEnum: {
    id: 'id',
    invoiceLineId: 'invoiceLineId',
    providerId: 'providerId',
    baseAmount: 'baseAmount',
    ratePct: 'ratePct',
    commissionAmount: 'commissionAmount',
    isPaid: 'isPaid'
  };

  export type ProviderCommissionScalarFieldEnum = (typeof ProviderCommissionScalarFieldEnum)[keyof typeof ProviderCommissionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    method: 'method',
    transferStatus: 'transferStatus',
    amount: 'amount',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    reference: 'reference',
    posTerminalId: 'posTerminalId',
    createdById: 'createdById',
    requestContextId: 'requestContextId',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CashSessionScalarFieldEnum: {
    id: 'id',
    registerId: 'registerId',
    openedById: 'openedById',
    openedAt: 'openedAt',
    openingFloat: 'openingFloat',
    closedById: 'closedById',
    closedAt: 'closedAt',
    declaredTotal: 'declaredTotal',
    systemTotal: 'systemTotal',
    variance: 'variance'
  };

  export type CashSessionScalarFieldEnum = (typeof CashSessionScalarFieldEnum)[keyof typeof CashSessionScalarFieldEnum]


  export const CashMovementScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    type: 'type',
    amount: 'amount',
    reference: 'reference',
    createdById: 'createdById',
    requestContextId: 'requestContextId',
    createdAt: 'createdAt'
  };

  export type CashMovementScalarFieldEnum = (typeof CashMovementScalarFieldEnum)[keyof typeof CashMovementScalarFieldEnum]


  export const InventoryProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    unit: 'unit',
    price: 'price',
    taxRatePct: 'taxRatePct',
    isActive: 'isActive'
  };

  export type InventoryProductScalarFieldEnum = (typeof InventoryProductScalarFieldEnum)[keyof typeof InventoryProductScalarFieldEnum]


  export const ProductStockScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    locationId: 'locationId',
    onHand: 'onHand'
  };

  export type ProductStockScalarFieldEnum = (typeof ProductStockScalarFieldEnum)[keyof typeof ProductStockScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    locationId: 'locationId',
    qty: 'qty',
    reason: 'reason',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const LabInstrumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    vendor: 'vendor',
    model: 'model',
    serialNo: 'serialNo',
    connectionType: 'connectionType',
    locationId: 'locationId',
    isActive: 'isActive'
  };

  export type LabInstrumentScalarFieldEnum = (typeof LabInstrumentScalarFieldEnum)[keyof typeof LabInstrumentScalarFieldEnum]


  export const SpecimenTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SpecimenTypeScalarFieldEnum = (typeof SpecimenTypeScalarFieldEnum)[keyof typeof SpecimenTypeScalarFieldEnum]


  export const TestCatalogScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    loincCode: 'loincCode',
    units: 'units',
    specimenTypeId: 'specimenTypeId',
    defaultInstrumentId: 'defaultInstrumentId',
    isPanel: 'isPanel',
    parentPanelId: 'parentPanelId'
  };

  export type TestCatalogScalarFieldEnum = (typeof TestCatalogScalarFieldEnum)[keyof typeof TestCatalogScalarFieldEnum]


  export const ReferenceRangeScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    sex: 'sex',
    ageMinYears: 'ageMinYears',
    ageMaxYears: 'ageMaxYears',
    lowValue: 'lowValue',
    highValue: 'highValue',
    notes: 'notes'
  };

  export type ReferenceRangeScalarFieldEnum = (typeof ReferenceRangeScalarFieldEnum)[keyof typeof ReferenceRangeScalarFieldEnum]


  export const LabOrderScalarFieldEnum: {
    id: 'id',
    accessionNo: 'accessionNo',
    patientId: 'patientId',
    orderingProviderId: 'orderingProviderId',
    invoiceId: 'invoiceId',
    preclinicId: 'preclinicId',
    specimenTypeId: 'specimenTypeId',
    collectionTime: 'collectionTime',
    collectedById: 'collectedById',
    priority: 'priority',
    status: 'status',
    notes: 'notes',
    requestContextId: 'requestContextId'
  };

  export type LabOrderScalarFieldEnum = (typeof LabOrderScalarFieldEnum)[keyof typeof LabOrderScalarFieldEnum]


  export const LabOrderTestScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    testId: 'testId',
    status: 'status',
    instrumentId: 'instrumentId',
    analyteCodeInstrument: 'analyteCodeInstrument',
    resultValue: 'resultValue',
    resultText: 'resultText',
    units: 'units',
    flagAbnormal: 'flagAbnormal',
    outOfRange: 'outOfRange',
    referenceLow: 'referenceLow',
    referenceHigh: 'referenceHigh',
    completedAt: 'completedAt',
    resultNotes: 'resultNotes',
    requestContextId: 'requestContextId'
  };

  export type LabOrderTestScalarFieldEnum = (typeof LabOrderTestScalarFieldEnum)[keyof typeof LabOrderTestScalarFieldEnum]


  export const LabDeviceMessageScalarFieldEnum: {
    id: 'id',
    instrumentId: 'instrumentId',
    orderId: 'orderId',
    receivedAt: 'receivedAt',
    protocol: 'protocol',
    rawContent: 'rawContent',
    parsedOk: 'parsedOk'
  };

  export type LabDeviceMessageScalarFieldEnum = (typeof LabDeviceMessageScalarFieldEnum)[keyof typeof LabDeviceMessageScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action',
    actorId: 'actorId',
    requestContextId: 'requestContextId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'WorkstationType'
   */
  export type EnumWorkstationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkstationType'>
    


  /**
   * Reference to a field of type 'WorkstationType[]'
   */
  export type ListEnumWorkstationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkstationType[]'>
    


  /**
   * Reference to a field of type 'Sex'
   */
  export type EnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex'>
    


  /**
   * Reference to a field of type 'Sex[]'
   */
  export type ListEnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AllergySeverity'
   */
  export type EnumAllergySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllergySeverity'>
    


  /**
   * Reference to a field of type 'AllergySeverity[]'
   */
  export type ListEnumAllergySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllergySeverity[]'>
    


  /**
   * Reference to a field of type 'ProblemStatus'
   */
  export type EnumProblemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProblemStatus'>
    


  /**
   * Reference to a field of type 'ProblemStatus[]'
   */
  export type ListEnumProblemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProblemStatus[]'>
    


  /**
   * Reference to a field of type 'Route'
   */
  export type EnumRouteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Route'>
    


  /**
   * Reference to a field of type 'Route[]'
   */
  export type ListEnumRouteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Route[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'CashMovementType'
   */
  export type EnumCashMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashMovementType'>
    


  /**
   * Reference to a field of type 'CashMovementType[]'
   */
  export type ListEnumCashMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashMovementType[]'>
    


  /**
   * Reference to a field of type 'StockReason'
   */
  export type EnumStockReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockReason'>
    


  /**
   * Reference to a field of type 'StockReason[]'
   */
  export type ListEnumStockReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockReason[]'>
    


  /**
   * Reference to a field of type 'ConnectionType'
   */
  export type EnumConnectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionType'>
    


  /**
   * Reference to a field of type 'ConnectionType[]'
   */
  export type ListEnumConnectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'LabOrderStatus'
   */
  export type EnumLabOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabOrderStatus'>
    


  /**
   * Reference to a field of type 'LabOrderStatus[]'
   */
  export type ListEnumLabOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabOrderStatus[]'>
    


  /**
   * Reference to a field of type 'LabOrderTestStatus'
   */
  export type EnumLabOrderTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabOrderTestStatus'>
    


  /**
   * Reference to a field of type 'LabOrderTestStatus[]'
   */
  export type ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabOrderTestStatus[]'>
    


  /**
   * Reference to a field of type 'AbnormalFlag'
   */
  export type EnumAbnormalFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbnormalFlag'>
    


  /**
   * Reference to a field of type 'AbnormalFlag[]'
   */
  export type ListEnumAbnormalFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbnormalFlag[]'>
    


  /**
   * Reference to a field of type 'OutOfRangeFlag'
   */
  export type EnumOutOfRangeFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutOfRangeFlag'>
    


  /**
   * Reference to a field of type 'OutOfRangeFlag[]'
   */
  export type ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutOfRangeFlag[]'>
    


  /**
   * Reference to a field of type 'ProtocolKind'
   */
  export type EnumProtocolKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProtocolKind'>
    


  /**
   * Reference to a field of type 'ProtocolKind[]'
   */
  export type ListEnumProtocolKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProtocolKind[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type bootstrapWhereInput = {
    AND?: bootstrapWhereInput | bootstrapWhereInput[]
    OR?: bootstrapWhereInput[]
    NOT?: bootstrapWhereInput | bootstrapWhereInput[]
    id?: UuidFilter<"bootstrap"> | string
    txt?: StringFilter<"bootstrap"> | string
  }

  export type bootstrapOrderByWithRelationInput = {
    id?: SortOrder
    txt?: SortOrder
  }

  export type bootstrapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bootstrapWhereInput | bootstrapWhereInput[]
    OR?: bootstrapWhereInput[]
    NOT?: bootstrapWhereInput | bootstrapWhereInput[]
    txt?: StringFilter<"bootstrap"> | string
  }, "id">

  export type bootstrapOrderByWithAggregationInput = {
    id?: SortOrder
    txt?: SortOrder
    _count?: bootstrapCountOrderByAggregateInput
    _max?: bootstrapMaxOrderByAggregateInput
    _min?: bootstrapMinOrderByAggregateInput
  }

  export type bootstrapScalarWhereWithAggregatesInput = {
    AND?: bootstrapScalarWhereWithAggregatesInput | bootstrapScalarWhereWithAggregatesInput[]
    OR?: bootstrapScalarWhereWithAggregatesInput[]
    NOT?: bootstrapScalarWhereWithAggregatesInput | bootstrapScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bootstrap"> | string
    txt?: StringWithAggregatesFilter<"bootstrap"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    username?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roles?: UserRoleListRelationFilter
    sessions?: AuthSessionListRelationFilter
    patientsCreated?: PatientListRelationFilter
    preclinics?: PreclinicListRelationFilter
    problemsRecorded?: ProblemListRelationFilter
    allergiesRecorded?: AllergyListRelationFilter
    medicationsRx?: MedicationListRelationFilter
    invoicesCashier?: InvoiceListRelationFilter
    paymentsCreated?: PaymentListRelationFilter
    cashSessionsOpen?: CashSessionListRelationFilter
    cashSessionsClose?: CashSessionListRelationFilter
    cashMovements?: CashMovementListRelationFilter
    labOrdersOrdered?: LabOrderListRelationFilter
    labOrdersCollected?: LabOrderListRelationFilter
    activity?: ActivityLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
    sessions?: AuthSessionOrderByRelationAggregateInput
    patientsCreated?: PatientOrderByRelationAggregateInput
    preclinics?: PreclinicOrderByRelationAggregateInput
    problemsRecorded?: ProblemOrderByRelationAggregateInput
    allergiesRecorded?: AllergyOrderByRelationAggregateInput
    medicationsRx?: MedicationOrderByRelationAggregateInput
    invoicesCashier?: InvoiceOrderByRelationAggregateInput
    paymentsCreated?: PaymentOrderByRelationAggregateInput
    cashSessionsOpen?: CashSessionOrderByRelationAggregateInput
    cashSessionsClose?: CashSessionOrderByRelationAggregateInput
    cashMovements?: CashMovementOrderByRelationAggregateInput
    labOrdersOrdered?: LabOrderOrderByRelationAggregateInput
    labOrdersCollected?: LabOrderOrderByRelationAggregateInput
    activity?: ActivityLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roles?: UserRoleListRelationFilter
    sessions?: AuthSessionListRelationFilter
    patientsCreated?: PatientListRelationFilter
    preclinics?: PreclinicListRelationFilter
    problemsRecorded?: ProblemListRelationFilter
    allergiesRecorded?: AllergyListRelationFilter
    medicationsRx?: MedicationListRelationFilter
    invoicesCashier?: InvoiceListRelationFilter
    paymentsCreated?: PaymentListRelationFilter
    cashSessionsOpen?: CashSessionListRelationFilter
    cashSessionsClose?: CashSessionListRelationFilter
    cashMovements?: CashMovementListRelationFilter
    labOrdersOrdered?: LabOrderListRelationFilter
    labOrdersCollected?: LabOrderListRelationFilter
    activity?: ActivityLogListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserRole"> | string
    roleId?: UuidWithAggregatesFilter<"UserRole"> | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: UuidFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    registers?: CashRegisterListRelationFilter
    posTerminals?: PosTerminalListRelationFilter
    workstations?: WorkstationListRelationFilter
    productStock?: ProductStockListRelationFilter
    stockMoves?: StockMovementListRelationFilter
    labInstruments?: LabInstrumentListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    registers?: CashRegisterOrderByRelationAggregateInput
    posTerminals?: PosTerminalOrderByRelationAggregateInput
    workstations?: WorkstationOrderByRelationAggregateInput
    productStock?: ProductStockOrderByRelationAggregateInput
    stockMoves?: StockMovementOrderByRelationAggregateInput
    labInstruments?: LabInstrumentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    address?: StringNullableFilter<"Location"> | string | null
    registers?: CashRegisterListRelationFilter
    posTerminals?: PosTerminalListRelationFilter
    workstations?: WorkstationListRelationFilter
    productStock?: ProductStockListRelationFilter
    stockMoves?: StockMovementListRelationFilter
    labInstruments?: LabInstrumentListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "name">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
  }

  export type CashRegisterWhereInput = {
    AND?: CashRegisterWhereInput | CashRegisterWhereInput[]
    OR?: CashRegisterWhereInput[]
    NOT?: CashRegisterWhereInput | CashRegisterWhereInput[]
    id?: UuidFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    locationId?: UuidFilter<"CashRegister"> | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    sessions?: CashSessionListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type CashRegisterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    location?: LocationOrderByWithRelationInput
    sessions?: CashSessionOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type CashRegisterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CashRegisterWhereInput | CashRegisterWhereInput[]
    OR?: CashRegisterWhereInput[]
    NOT?: CashRegisterWhereInput | CashRegisterWhereInput[]
    locationId?: UuidFilter<"CashRegister"> | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    sessions?: CashSessionListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "name">

  export type CashRegisterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    _count?: CashRegisterCountOrderByAggregateInput
    _max?: CashRegisterMaxOrderByAggregateInput
    _min?: CashRegisterMinOrderByAggregateInput
  }

  export type CashRegisterScalarWhereWithAggregatesInput = {
    AND?: CashRegisterScalarWhereWithAggregatesInput | CashRegisterScalarWhereWithAggregatesInput[]
    OR?: CashRegisterScalarWhereWithAggregatesInput[]
    NOT?: CashRegisterScalarWhereWithAggregatesInput | CashRegisterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CashRegister"> | string
    name?: StringWithAggregatesFilter<"CashRegister"> | string
    locationId?: UuidWithAggregatesFilter<"CashRegister"> | string
  }

  export type PosTerminalWhereInput = {
    AND?: PosTerminalWhereInput | PosTerminalWhereInput[]
    OR?: PosTerminalWhereInput[]
    NOT?: PosTerminalWhereInput | PosTerminalWhereInput[]
    id?: UuidFilter<"PosTerminal"> | string
    name?: StringFilter<"PosTerminal"> | string
    provider?: StringFilter<"PosTerminal"> | string
    merchantId?: StringNullableFilter<"PosTerminal"> | string | null
    locationId?: UuidFilter<"PosTerminal"> | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type PosTerminalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    merchantId?: SortOrderInput | SortOrder
    locationId?: SortOrder
    location?: LocationOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type PosTerminalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PosTerminalWhereInput | PosTerminalWhereInput[]
    OR?: PosTerminalWhereInput[]
    NOT?: PosTerminalWhereInput | PosTerminalWhereInput[]
    provider?: StringFilter<"PosTerminal"> | string
    merchantId?: StringNullableFilter<"PosTerminal"> | string | null
    locationId?: UuidFilter<"PosTerminal"> | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "name">

  export type PosTerminalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    merchantId?: SortOrderInput | SortOrder
    locationId?: SortOrder
    _count?: PosTerminalCountOrderByAggregateInput
    _max?: PosTerminalMaxOrderByAggregateInput
    _min?: PosTerminalMinOrderByAggregateInput
  }

  export type PosTerminalScalarWhereWithAggregatesInput = {
    AND?: PosTerminalScalarWhereWithAggregatesInput | PosTerminalScalarWhereWithAggregatesInput[]
    OR?: PosTerminalScalarWhereWithAggregatesInput[]
    NOT?: PosTerminalScalarWhereWithAggregatesInput | PosTerminalScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosTerminal"> | string
    name?: StringWithAggregatesFilter<"PosTerminal"> | string
    provider?: StringWithAggregatesFilter<"PosTerminal"> | string
    merchantId?: StringNullableWithAggregatesFilter<"PosTerminal"> | string | null
    locationId?: UuidWithAggregatesFilter<"PosTerminal"> | string
  }

  export type WorkstationWhereInput = {
    AND?: WorkstationWhereInput | WorkstationWhereInput[]
    OR?: WorkstationWhereInput[]
    NOT?: WorkstationWhereInput | WorkstationWhereInput[]
    id?: UuidFilter<"Workstation"> | string
    name?: StringFilter<"Workstation"> | string
    locationId?: UuidFilter<"Workstation"> | string
    type?: EnumWorkstationTypeFilter<"Workstation"> | $Enums.WorkstationType
    macAddress?: StringNullableFilter<"Workstation"> | string | null
    allowedIpCidr?: StringNullableFilter<"Workstation"> | string | null
    isActive?: BoolFilter<"Workstation"> | boolean
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    sessions?: AuthSessionListRelationFilter
    contexts?: RequestContextListRelationFilter
  }

  export type WorkstationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    macAddress?: SortOrderInput | SortOrder
    allowedIpCidr?: SortOrderInput | SortOrder
    isActive?: SortOrder
    location?: LocationOrderByWithRelationInput
    sessions?: AuthSessionOrderByRelationAggregateInput
    contexts?: RequestContextOrderByRelationAggregateInput
  }

  export type WorkstationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WorkstationWhereInput | WorkstationWhereInput[]
    OR?: WorkstationWhereInput[]
    NOT?: WorkstationWhereInput | WorkstationWhereInput[]
    locationId?: UuidFilter<"Workstation"> | string
    type?: EnumWorkstationTypeFilter<"Workstation"> | $Enums.WorkstationType
    macAddress?: StringNullableFilter<"Workstation"> | string | null
    allowedIpCidr?: StringNullableFilter<"Workstation"> | string | null
    isActive?: BoolFilter<"Workstation"> | boolean
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    sessions?: AuthSessionListRelationFilter
    contexts?: RequestContextListRelationFilter
  }, "id" | "name">

  export type WorkstationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    macAddress?: SortOrderInput | SortOrder
    allowedIpCidr?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: WorkstationCountOrderByAggregateInput
    _max?: WorkstationMaxOrderByAggregateInput
    _min?: WorkstationMinOrderByAggregateInput
  }

  export type WorkstationScalarWhereWithAggregatesInput = {
    AND?: WorkstationScalarWhereWithAggregatesInput | WorkstationScalarWhereWithAggregatesInput[]
    OR?: WorkstationScalarWhereWithAggregatesInput[]
    NOT?: WorkstationScalarWhereWithAggregatesInput | WorkstationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Workstation"> | string
    name?: StringWithAggregatesFilter<"Workstation"> | string
    locationId?: UuidWithAggregatesFilter<"Workstation"> | string
    type?: EnumWorkstationTypeWithAggregatesFilter<"Workstation"> | $Enums.WorkstationType
    macAddress?: StringNullableWithAggregatesFilter<"Workstation"> | string | null
    allowedIpCidr?: StringNullableWithAggregatesFilter<"Workstation"> | string | null
    isActive?: BoolWithAggregatesFilter<"Workstation"> | boolean
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: UuidFilter<"Patient"> | string
    mrn?: StringFilter<"Patient"> | string
    nationalId?: StringNullableFilter<"Patient"> | string | null
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    sex?: EnumSexNullableFilter<"Patient"> | $Enums.Sex | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    region?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    createdById?: UuidNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    preclinics?: PreclinicListRelationFilter
    allergies?: AllergyListRelationFilter
    problems?: ProblemListRelationFilter
    medications?: MedicationListRelationFilter
    invoices?: InvoiceListRelationFilter
    labOrders?: LabOrderListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    mrn?: SortOrder
    nationalId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    preclinics?: PreclinicOrderByRelationAggregateInput
    allergies?: AllergyOrderByRelationAggregateInput
    problems?: ProblemOrderByRelationAggregateInput
    medications?: MedicationOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    labOrders?: LabOrderOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mrn?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    nationalId?: StringNullableFilter<"Patient"> | string | null
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    sex?: EnumSexNullableFilter<"Patient"> | $Enums.Sex | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    region?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    createdById?: UuidNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    preclinics?: PreclinicListRelationFilter
    allergies?: AllergyListRelationFilter
    problems?: ProblemListRelationFilter
    medications?: MedicationListRelationFilter
    invoices?: InvoiceListRelationFilter
    labOrders?: LabOrderListRelationFilter
  }, "id" | "mrn">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    mrn?: SortOrder
    nationalId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Patient"> | string
    mrn?: StringWithAggregatesFilter<"Patient"> | string
    nationalId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    firstName?: StringWithAggregatesFilter<"Patient"> | string
    lastName?: StringWithAggregatesFilter<"Patient"> | string
    dob?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    sex?: EnumSexNullableWithAggregatesFilter<"Patient"> | $Enums.Sex | null
    maritalStatus?: EnumMaritalStatusNullableWithAggregatesFilter<"Patient"> | $Enums.MaritalStatus | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    city?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    region?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    country?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    bloodType?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdById?: UuidNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AuthSessionWhereInput = {
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    id?: UuidFilter<"AuthSession"> | string
    userId?: UuidFilter<"AuthSession"> | string
    startedAt?: DateTimeFilter<"AuthSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"AuthSession"> | Date | string | null
    ipAddress?: StringFilter<"AuthSession"> | string
    userAgent?: StringFilter<"AuthSession"> | string
    deviceFingerprint?: StringNullableFilter<"AuthSession"> | string | null
    workstationId?: UuidNullableFilter<"AuthSession"> | string | null
    geoCountry?: StringNullableFilter<"AuthSession"> | string | null
    geoRegion?: StringNullableFilter<"AuthSession"> | string | null
    geoCity?: StringNullableFilter<"AuthSession"> | string | null
    geoLat?: DecimalNullableFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFilter<"AuthSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workstation?: XOR<WorkstationNullableScalarRelationFilter, WorkstationWhereInput> | null
    contexts?: RequestContextListRelationFilter
  }

  export type AuthSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    workstationId?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoLat?: SortOrderInput | SortOrder
    geoLon?: SortOrderInput | SortOrder
    mfaPassed?: SortOrder
    user?: UserOrderByWithRelationInput
    workstation?: WorkstationOrderByWithRelationInput
    contexts?: RequestContextOrderByRelationAggregateInput
  }

  export type AuthSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    userId?: UuidFilter<"AuthSession"> | string
    startedAt?: DateTimeFilter<"AuthSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"AuthSession"> | Date | string | null
    ipAddress?: StringFilter<"AuthSession"> | string
    userAgent?: StringFilter<"AuthSession"> | string
    deviceFingerprint?: StringNullableFilter<"AuthSession"> | string | null
    workstationId?: UuidNullableFilter<"AuthSession"> | string | null
    geoCountry?: StringNullableFilter<"AuthSession"> | string | null
    geoRegion?: StringNullableFilter<"AuthSession"> | string | null
    geoCity?: StringNullableFilter<"AuthSession"> | string | null
    geoLat?: DecimalNullableFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFilter<"AuthSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workstation?: XOR<WorkstationNullableScalarRelationFilter, WorkstationWhereInput> | null
    contexts?: RequestContextListRelationFilter
  }, "id">

  export type AuthSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    workstationId?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoLat?: SortOrderInput | SortOrder
    geoLon?: SortOrderInput | SortOrder
    mfaPassed?: SortOrder
    _count?: AuthSessionCountOrderByAggregateInput
    _avg?: AuthSessionAvgOrderByAggregateInput
    _max?: AuthSessionMaxOrderByAggregateInput
    _min?: AuthSessionMinOrderByAggregateInput
    _sum?: AuthSessionSumOrderByAggregateInput
  }

  export type AuthSessionScalarWhereWithAggregatesInput = {
    AND?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    OR?: AuthSessionScalarWhereWithAggregatesInput[]
    NOT?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuthSession"> | string
    userId?: UuidWithAggregatesFilter<"AuthSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"AuthSession"> | Date | string | null
    ipAddress?: StringWithAggregatesFilter<"AuthSession"> | string
    userAgent?: StringWithAggregatesFilter<"AuthSession"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    workstationId?: UuidNullableWithAggregatesFilter<"AuthSession"> | string | null
    geoCountry?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    geoRegion?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    geoCity?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    geoLat?: DecimalNullableWithAggregatesFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableWithAggregatesFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolWithAggregatesFilter<"AuthSession"> | boolean
  }

  export type RequestContextWhereInput = {
    AND?: RequestContextWhereInput | RequestContextWhereInput[]
    OR?: RequestContextWhereInput[]
    NOT?: RequestContextWhereInput | RequestContextWhereInput[]
    id?: UuidFilter<"RequestContext"> | string
    sessionId?: UuidFilter<"RequestContext"> | string
    occurredAt?: DateTimeFilter<"RequestContext"> | Date | string
    ipAddress?: StringFilter<"RequestContext"> | string
    userAgent?: StringFilter<"RequestContext"> | string
    deviceFingerprint?: StringNullableFilter<"RequestContext"> | string | null
    workstationId?: UuidNullableFilter<"RequestContext"> | string | null
    geoCountry?: StringNullableFilter<"RequestContext"> | string | null
    geoRegion?: StringNullableFilter<"RequestContext"> | string | null
    geoCity?: StringNullableFilter<"RequestContext"> | string | null
    geoLat?: DecimalNullableFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
    session?: XOR<AuthSessionScalarRelationFilter, AuthSessionWhereInput>
    workstation?: XOR<WorkstationNullableScalarRelationFilter, WorkstationWhereInput> | null
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    cashMoves?: CashMovementListRelationFilter
    preclinics?: PreclinicListRelationFilter
    labOrders?: LabOrderListRelationFilter
    labOrderTests?: LabOrderTestListRelationFilter
    activities?: ActivityLogListRelationFilter
  }

  export type RequestContextOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    occurredAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    workstationId?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoLat?: SortOrderInput | SortOrder
    geoLon?: SortOrderInput | SortOrder
    session?: AuthSessionOrderByWithRelationInput
    workstation?: WorkstationOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    cashMoves?: CashMovementOrderByRelationAggregateInput
    preclinics?: PreclinicOrderByRelationAggregateInput
    labOrders?: LabOrderOrderByRelationAggregateInput
    labOrderTests?: LabOrderTestOrderByRelationAggregateInput
    activities?: ActivityLogOrderByRelationAggregateInput
  }

  export type RequestContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestContextWhereInput | RequestContextWhereInput[]
    OR?: RequestContextWhereInput[]
    NOT?: RequestContextWhereInput | RequestContextWhereInput[]
    sessionId?: UuidFilter<"RequestContext"> | string
    occurredAt?: DateTimeFilter<"RequestContext"> | Date | string
    ipAddress?: StringFilter<"RequestContext"> | string
    userAgent?: StringFilter<"RequestContext"> | string
    deviceFingerprint?: StringNullableFilter<"RequestContext"> | string | null
    workstationId?: UuidNullableFilter<"RequestContext"> | string | null
    geoCountry?: StringNullableFilter<"RequestContext"> | string | null
    geoRegion?: StringNullableFilter<"RequestContext"> | string | null
    geoCity?: StringNullableFilter<"RequestContext"> | string | null
    geoLat?: DecimalNullableFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
    session?: XOR<AuthSessionScalarRelationFilter, AuthSessionWhereInput>
    workstation?: XOR<WorkstationNullableScalarRelationFilter, WorkstationWhereInput> | null
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    cashMoves?: CashMovementListRelationFilter
    preclinics?: PreclinicListRelationFilter
    labOrders?: LabOrderListRelationFilter
    labOrderTests?: LabOrderTestListRelationFilter
    activities?: ActivityLogListRelationFilter
  }, "id">

  export type RequestContextOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    occurredAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    workstationId?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoLat?: SortOrderInput | SortOrder
    geoLon?: SortOrderInput | SortOrder
    _count?: RequestContextCountOrderByAggregateInput
    _avg?: RequestContextAvgOrderByAggregateInput
    _max?: RequestContextMaxOrderByAggregateInput
    _min?: RequestContextMinOrderByAggregateInput
    _sum?: RequestContextSumOrderByAggregateInput
  }

  export type RequestContextScalarWhereWithAggregatesInput = {
    AND?: RequestContextScalarWhereWithAggregatesInput | RequestContextScalarWhereWithAggregatesInput[]
    OR?: RequestContextScalarWhereWithAggregatesInput[]
    NOT?: RequestContextScalarWhereWithAggregatesInput | RequestContextScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RequestContext"> | string
    sessionId?: UuidWithAggregatesFilter<"RequestContext"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"RequestContext"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"RequestContext"> | string
    userAgent?: StringWithAggregatesFilter<"RequestContext"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"RequestContext"> | string | null
    workstationId?: UuidNullableWithAggregatesFilter<"RequestContext"> | string | null
    geoCountry?: StringNullableWithAggregatesFilter<"RequestContext"> | string | null
    geoRegion?: StringNullableWithAggregatesFilter<"RequestContext"> | string | null
    geoCity?: StringNullableWithAggregatesFilter<"RequestContext"> | string | null
    geoLat?: DecimalNullableWithAggregatesFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableWithAggregatesFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PreclinicWhereInput = {
    AND?: PreclinicWhereInput | PreclinicWhereInput[]
    OR?: PreclinicWhereInput[]
    NOT?: PreclinicWhereInput | PreclinicWhereInput[]
    id?: UuidFilter<"Preclinic"> | string
    patientId?: UuidFilter<"Preclinic"> | string
    visitDate?: DateTimeFilter<"Preclinic"> | Date | string
    bloodPressureSystolic?: IntNullableFilter<"Preclinic"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"Preclinic"> | number | null
    heartRate?: IntNullableFilter<"Preclinic"> | number | null
    respRate?: IntNullableFilter<"Preclinic"> | number | null
    temperatureC?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    weightKg?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    bmi?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: StringNullableFilter<"Preclinic"> | string | null
    currentMedications?: StringNullableFilter<"Preclinic"> | string | null
    diabetes?: BoolNullableFilter<"Preclinic"> | boolean | null
    hypertension?: BoolNullableFilter<"Preclinic"> | boolean | null
    otherConditions?: StringNullableFilter<"Preclinic"> | string | null
    allergiesReported?: StringNullableFilter<"Preclinic"> | string | null
    recordedById?: UuidFilter<"Preclinic"> | string
    requestContextId?: UuidFilter<"Preclinic"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    labOrders?: LabOrderListRelationFilter
    recordedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type PreclinicOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitDate?: SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    respRate?: SortOrderInput | SortOrder
    temperatureC?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    currentMedications?: SortOrderInput | SortOrder
    diabetes?: SortOrderInput | SortOrder
    hypertension?: SortOrderInput | SortOrder
    otherConditions?: SortOrderInput | SortOrder
    allergiesReported?: SortOrderInput | SortOrder
    recordedById?: SortOrder
    requestContextId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    labOrders?: LabOrderOrderByRelationAggregateInput
    recordedBy?: UserOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type PreclinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreclinicWhereInput | PreclinicWhereInput[]
    OR?: PreclinicWhereInput[]
    NOT?: PreclinicWhereInput | PreclinicWhereInput[]
    patientId?: UuidFilter<"Preclinic"> | string
    visitDate?: DateTimeFilter<"Preclinic"> | Date | string
    bloodPressureSystolic?: IntNullableFilter<"Preclinic"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"Preclinic"> | number | null
    heartRate?: IntNullableFilter<"Preclinic"> | number | null
    respRate?: IntNullableFilter<"Preclinic"> | number | null
    temperatureC?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    weightKg?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    bmi?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: StringNullableFilter<"Preclinic"> | string | null
    currentMedications?: StringNullableFilter<"Preclinic"> | string | null
    diabetes?: BoolNullableFilter<"Preclinic"> | boolean | null
    hypertension?: BoolNullableFilter<"Preclinic"> | boolean | null
    otherConditions?: StringNullableFilter<"Preclinic"> | string | null
    allergiesReported?: StringNullableFilter<"Preclinic"> | string | null
    recordedById?: UuidFilter<"Preclinic"> | string
    requestContextId?: UuidFilter<"Preclinic"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    labOrders?: LabOrderListRelationFilter
    recordedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type PreclinicOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitDate?: SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    respRate?: SortOrderInput | SortOrder
    temperatureC?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    currentMedications?: SortOrderInput | SortOrder
    diabetes?: SortOrderInput | SortOrder
    hypertension?: SortOrderInput | SortOrder
    otherConditions?: SortOrderInput | SortOrder
    allergiesReported?: SortOrderInput | SortOrder
    recordedById?: SortOrder
    requestContextId?: SortOrder
    _count?: PreclinicCountOrderByAggregateInput
    _avg?: PreclinicAvgOrderByAggregateInput
    _max?: PreclinicMaxOrderByAggregateInput
    _min?: PreclinicMinOrderByAggregateInput
    _sum?: PreclinicSumOrderByAggregateInput
  }

  export type PreclinicScalarWhereWithAggregatesInput = {
    AND?: PreclinicScalarWhereWithAggregatesInput | PreclinicScalarWhereWithAggregatesInput[]
    OR?: PreclinicScalarWhereWithAggregatesInput[]
    NOT?: PreclinicScalarWhereWithAggregatesInput | PreclinicScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Preclinic"> | string
    patientId?: UuidWithAggregatesFilter<"Preclinic"> | string
    visitDate?: DateTimeWithAggregatesFilter<"Preclinic"> | Date | string
    bloodPressureSystolic?: IntNullableWithAggregatesFilter<"Preclinic"> | number | null
    bloodPressureDiastolic?: IntNullableWithAggregatesFilter<"Preclinic"> | number | null
    heartRate?: IntNullableWithAggregatesFilter<"Preclinic"> | number | null
    respRate?: IntNullableWithAggregatesFilter<"Preclinic"> | number | null
    temperatureC?: DecimalNullableWithAggregatesFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    weightKg?: DecimalNullableWithAggregatesFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableWithAggregatesFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    bmi?: DecimalNullableWithAggregatesFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: StringNullableWithAggregatesFilter<"Preclinic"> | string | null
    currentMedications?: StringNullableWithAggregatesFilter<"Preclinic"> | string | null
    diabetes?: BoolNullableWithAggregatesFilter<"Preclinic"> | boolean | null
    hypertension?: BoolNullableWithAggregatesFilter<"Preclinic"> | boolean | null
    otherConditions?: StringNullableWithAggregatesFilter<"Preclinic"> | string | null
    allergiesReported?: StringNullableWithAggregatesFilter<"Preclinic"> | string | null
    recordedById?: UuidWithAggregatesFilter<"Preclinic"> | string
    requestContextId?: UuidWithAggregatesFilter<"Preclinic"> | string
  }

  export type AllergyWhereInput = {
    AND?: AllergyWhereInput | AllergyWhereInput[]
    OR?: AllergyWhereInput[]
    NOT?: AllergyWhereInput | AllergyWhereInput[]
    id?: UuidFilter<"Allergy"> | string
    patientId?: UuidFilter<"Allergy"> | string
    substance?: StringFilter<"Allergy"> | string
    reaction?: StringNullableFilter<"Allergy"> | string | null
    severity?: EnumAllergySeverityNullableFilter<"Allergy"> | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFilter<"Allergy"> | Date | string
    recordedById?: UuidNullableFilter<"Allergy"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AllergyOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    reaction?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
  }

  export type AllergyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllergyWhereInput | AllergyWhereInput[]
    OR?: AllergyWhereInput[]
    NOT?: AllergyWhereInput | AllergyWhereInput[]
    patientId?: UuidFilter<"Allergy"> | string
    substance?: StringFilter<"Allergy"> | string
    reaction?: StringNullableFilter<"Allergy"> | string | null
    severity?: EnumAllergySeverityNullableFilter<"Allergy"> | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFilter<"Allergy"> | Date | string
    recordedById?: UuidNullableFilter<"Allergy"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AllergyOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    reaction?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrderInput | SortOrder
    _count?: AllergyCountOrderByAggregateInput
    _max?: AllergyMaxOrderByAggregateInput
    _min?: AllergyMinOrderByAggregateInput
  }

  export type AllergyScalarWhereWithAggregatesInput = {
    AND?: AllergyScalarWhereWithAggregatesInput | AllergyScalarWhereWithAggregatesInput[]
    OR?: AllergyScalarWhereWithAggregatesInput[]
    NOT?: AllergyScalarWhereWithAggregatesInput | AllergyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Allergy"> | string
    patientId?: UuidWithAggregatesFilter<"Allergy"> | string
    substance?: StringWithAggregatesFilter<"Allergy"> | string
    reaction?: StringNullableWithAggregatesFilter<"Allergy"> | string | null
    severity?: EnumAllergySeverityNullableWithAggregatesFilter<"Allergy"> | $Enums.AllergySeverity | null
    recordedAt?: DateTimeWithAggregatesFilter<"Allergy"> | Date | string
    recordedById?: UuidNullableWithAggregatesFilter<"Allergy"> | string | null
  }

  export type ProblemWhereInput = {
    AND?: ProblemWhereInput | ProblemWhereInput[]
    OR?: ProblemWhereInput[]
    NOT?: ProblemWhereInput | ProblemWhereInput[]
    id?: UuidFilter<"Problem"> | string
    patientId?: UuidFilter<"Problem"> | string
    condition?: StringFilter<"Problem"> | string
    status?: EnumProblemStatusFilter<"Problem"> | $Enums.ProblemStatus
    diagnosedAt?: DateTimeNullableFilter<"Problem"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Problem"> | Date | string | null
    recordedById?: UuidNullableFilter<"Problem"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProblemOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    diagnosedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
  }

  export type ProblemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProblemWhereInput | ProblemWhereInput[]
    OR?: ProblemWhereInput[]
    NOT?: ProblemWhereInput | ProblemWhereInput[]
    patientId?: UuidFilter<"Problem"> | string
    condition?: StringFilter<"Problem"> | string
    status?: EnumProblemStatusFilter<"Problem"> | $Enums.ProblemStatus
    diagnosedAt?: DateTimeNullableFilter<"Problem"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Problem"> | Date | string | null
    recordedById?: UuidNullableFilter<"Problem"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProblemOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    diagnosedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    _count?: ProblemCountOrderByAggregateInput
    _max?: ProblemMaxOrderByAggregateInput
    _min?: ProblemMinOrderByAggregateInput
  }

  export type ProblemScalarWhereWithAggregatesInput = {
    AND?: ProblemScalarWhereWithAggregatesInput | ProblemScalarWhereWithAggregatesInput[]
    OR?: ProblemScalarWhereWithAggregatesInput[]
    NOT?: ProblemScalarWhereWithAggregatesInput | ProblemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Problem"> | string
    patientId?: UuidWithAggregatesFilter<"Problem"> | string
    condition?: StringWithAggregatesFilter<"Problem"> | string
    status?: EnumProblemStatusWithAggregatesFilter<"Problem"> | $Enums.ProblemStatus
    diagnosedAt?: DateTimeNullableWithAggregatesFilter<"Problem"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Problem"> | Date | string | null
    recordedById?: UuidNullableWithAggregatesFilter<"Problem"> | string | null
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: UuidFilter<"Medication"> | string
    patientId?: UuidFilter<"Medication"> | string
    drugName?: StringFilter<"Medication"> | string
    dose?: StringNullableFilter<"Medication"> | string | null
    frequency?: StringNullableFilter<"Medication"> | string | null
    route?: EnumRouteNullableFilter<"Medication"> | $Enums.Route | null
    startedAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    stoppedAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    prescribedById?: UuidNullableFilter<"Medication"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    prescribedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    drugName?: SortOrder
    dose?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    route?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    stoppedAt?: SortOrderInput | SortOrder
    prescribedById?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    prescribedBy?: UserOrderByWithRelationInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    patientId?: UuidFilter<"Medication"> | string
    drugName?: StringFilter<"Medication"> | string
    dose?: StringNullableFilter<"Medication"> | string | null
    frequency?: StringNullableFilter<"Medication"> | string | null
    route?: EnumRouteNullableFilter<"Medication"> | $Enums.Route | null
    startedAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    stoppedAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    prescribedById?: UuidNullableFilter<"Medication"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    prescribedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    drugName?: SortOrder
    dose?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    route?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    stoppedAt?: SortOrderInput | SortOrder
    prescribedById?: SortOrderInput | SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Medication"> | string
    patientId?: UuidWithAggregatesFilter<"Medication"> | string
    drugName?: StringWithAggregatesFilter<"Medication"> | string
    dose?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    frequency?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    route?: EnumRouteNullableWithAggregatesFilter<"Medication"> | $Enums.Route | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Medication"> | Date | string | null
    stoppedAt?: DateTimeNullableWithAggregatesFilter<"Medication"> | Date | string | null
    prescribedById?: UuidNullableWithAggregatesFilter<"Medication"> | string | null
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: UuidFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    services?: ServiceListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    name?: StringFilter<"ServiceCategory"> | string
    services?: ServiceListRelationFilter
  }, "id">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: UuidFilter<"Service"> | string
    code?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    categoryId?: UuidFilter<"Service"> | string
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    commissionPct?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFilter<"Service"> | boolean
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    lines?: InvoiceLineListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrderInput | SortOrder
    requiresProvider?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    lines?: InvoiceLineOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    categoryId?: UuidFilter<"Service"> | string
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    commissionPct?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFilter<"Service"> | boolean
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    lines?: InvoiceLineListRelationFilter
  }, "id" | "code">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrderInput | SortOrder
    requiresProvider?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Service"> | string
    code?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    categoryId?: UuidWithAggregatesFilter<"Service"> | string
    price?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    commissionPct?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolWithAggregatesFilter<"Service"> | boolean
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: UuidFilter<"Provider"> | string
    fullName?: StringFilter<"Provider"> | string
    specialty?: StringNullableFilter<"Provider"> | string | null
    defaultCommissionPct?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Provider"> | boolean
    lines?: InvoiceLineListRelationFilter
    commissions?: ProviderCommissionListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    specialty?: SortOrderInput | SortOrder
    defaultCommissionPct?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lines?: InvoiceLineOrderByRelationAggregateInput
    commissions?: ProviderCommissionOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fullName?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    specialty?: StringNullableFilter<"Provider"> | string | null
    defaultCommissionPct?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Provider"> | boolean
    lines?: InvoiceLineListRelationFilter
    commissions?: ProviderCommissionListRelationFilter
  }, "id" | "fullName">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    specialty?: SortOrderInput | SortOrder
    defaultCommissionPct?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _avg?: ProviderAvgOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
    _sum?: ProviderSumOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Provider"> | string
    fullName?: StringWithAggregatesFilter<"Provider"> | string
    specialty?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    defaultCommissionPct?: DecimalNullableWithAggregatesFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Provider"> | boolean
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    invoiceNo?: StringFilter<"Invoice"> | string
    patientId?: UuidNullableFilter<"Invoice"> | string | null
    preclinicId?: UuidNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFilter<"Invoice"> | Date | string
    locationId?: UuidFilter<"Invoice"> | string
    cashierId?: UuidFilter<"Invoice"> | string
    registerId?: UuidNullableFilter<"Invoice"> | string | null
    requestContextId?: UuidFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    preclinic?: XOR<PreclinicNullableScalarRelationFilter, PreclinicWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    cashier?: XOR<UserScalarRelationFilter, UserWhereInput>
    register?: XOR<CashRegisterNullableScalarRelationFilter, CashRegisterWhereInput> | null
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
    lines?: InvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
    labOrders?: LabOrderListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    patientId?: SortOrderInput | SortOrder
    preclinicId?: SortOrderInput | SortOrder
    status?: SortOrder
    invoiceAt?: SortOrder
    locationId?: SortOrder
    cashierId?: SortOrder
    registerId?: SortOrderInput | SortOrder
    requestContextId?: SortOrder
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
    patient?: PatientOrderByWithRelationInput
    preclinic?: PreclinicOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    cashier?: UserOrderByWithRelationInput
    register?: CashRegisterOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
    lines?: InvoiceLineOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    labOrders?: LabOrderOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNo_locationId?: InvoiceInvoiceNoLocationIdCompoundUniqueInput
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceNo?: StringFilter<"Invoice"> | string
    patientId?: UuidNullableFilter<"Invoice"> | string | null
    preclinicId?: UuidNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFilter<"Invoice"> | Date | string
    locationId?: UuidFilter<"Invoice"> | string
    cashierId?: UuidFilter<"Invoice"> | string
    registerId?: UuidNullableFilter<"Invoice"> | string | null
    requestContextId?: UuidFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    preclinic?: XOR<PreclinicNullableScalarRelationFilter, PreclinicWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    cashier?: XOR<UserScalarRelationFilter, UserWhereInput>
    register?: XOR<CashRegisterNullableScalarRelationFilter, CashRegisterWhereInput> | null
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
    lines?: InvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
    labOrders?: LabOrderListRelationFilter
  }, "id" | "invoiceNo_locationId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    patientId?: SortOrderInput | SortOrder
    preclinicId?: SortOrderInput | SortOrder
    status?: SortOrder
    invoiceAt?: SortOrder
    locationId?: SortOrder
    cashierId?: SortOrder
    registerId?: SortOrderInput | SortOrder
    requestContextId?: SortOrder
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    invoiceNo?: StringWithAggregatesFilter<"Invoice"> | string
    patientId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    preclinicId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    locationId?: UuidWithAggregatesFilter<"Invoice"> | string
    cashierId?: UuidWithAggregatesFilter<"Invoice"> | string
    registerId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    requestContextId?: UuidWithAggregatesFilter<"Invoice"> | string
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    id?: UuidFilter<"InvoiceLine"> | string
    invoiceId?: UuidFilter<"InvoiceLine"> | string
    lineNo?: IntFilter<"InvoiceLine"> | number
    itemType?: EnumItemTypeFilter<"InvoiceLine"> | $Enums.ItemType
    serviceId?: UuidNullableFilter<"InvoiceLine"> | string | null
    productId?: UuidNullableFilter<"InvoiceLine"> | string | null
    description?: StringFilter<"InvoiceLine"> | string
    qty?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    providerId?: UuidNullableFilter<"InvoiceLine"> | string | null
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    product?: XOR<InventoryProductNullableScalarRelationFilter, InventoryProductWhereInput> | null
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
    commission?: XOR<ProviderCommissionNullableScalarRelationFilter, ProviderCommissionWhereInput> | null
  }

  export type InvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNo?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
    providerId?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    product?: InventoryProductOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
    commission?: ProviderCommissionOrderByWithRelationInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: UuidFilter<"InvoiceLine"> | string
    lineNo?: IntFilter<"InvoiceLine"> | number
    itemType?: EnumItemTypeFilter<"InvoiceLine"> | $Enums.ItemType
    serviceId?: UuidNullableFilter<"InvoiceLine"> | string | null
    productId?: UuidNullableFilter<"InvoiceLine"> | string | null
    description?: StringFilter<"InvoiceLine"> | string
    qty?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    providerId?: UuidNullableFilter<"InvoiceLine"> | string | null
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    product?: XOR<InventoryProductNullableScalarRelationFilter, InventoryProductWhereInput> | null
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
    commission?: XOR<ProviderCommissionNullableScalarRelationFilter, ProviderCommissionWhereInput> | null
  }, "id">

  export type InvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNo?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
    providerId?: SortOrderInput | SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceLine"> | string
    invoiceId?: UuidWithAggregatesFilter<"InvoiceLine"> | string
    lineNo?: IntWithAggregatesFilter<"InvoiceLine"> | number
    itemType?: EnumItemTypeWithAggregatesFilter<"InvoiceLine"> | $Enums.ItemType
    serviceId?: UuidNullableWithAggregatesFilter<"InvoiceLine"> | string | null
    productId?: UuidNullableWithAggregatesFilter<"InvoiceLine"> | string | null
    description?: StringWithAggregatesFilter<"InvoiceLine"> | string
    qty?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    providerId?: UuidNullableWithAggregatesFilter<"InvoiceLine"> | string | null
  }

  export type ProviderCommissionWhereInput = {
    AND?: ProviderCommissionWhereInput | ProviderCommissionWhereInput[]
    OR?: ProviderCommissionWhereInput[]
    NOT?: ProviderCommissionWhereInput | ProviderCommissionWhereInput[]
    id?: UuidFilter<"ProviderCommission"> | string
    invoiceLineId?: UuidFilter<"ProviderCommission"> | string
    providerId?: UuidFilter<"ProviderCommission"> | string
    baseAmount?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"ProviderCommission"> | boolean
    invoiceLine?: XOR<InvoiceLineScalarRelationFilter, InvoiceLineWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type ProviderCommissionOrderByWithRelationInput = {
    id?: SortOrder
    invoiceLineId?: SortOrder
    providerId?: SortOrder
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
    isPaid?: SortOrder
    invoiceLine?: InvoiceLineOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type ProviderCommissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceLineId?: string
    AND?: ProviderCommissionWhereInput | ProviderCommissionWhereInput[]
    OR?: ProviderCommissionWhereInput[]
    NOT?: ProviderCommissionWhereInput | ProviderCommissionWhereInput[]
    providerId?: UuidFilter<"ProviderCommission"> | string
    baseAmount?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"ProviderCommission"> | boolean
    invoiceLine?: XOR<InvoiceLineScalarRelationFilter, InvoiceLineWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id" | "invoiceLineId">

  export type ProviderCommissionOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceLineId?: SortOrder
    providerId?: SortOrder
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
    isPaid?: SortOrder
    _count?: ProviderCommissionCountOrderByAggregateInput
    _avg?: ProviderCommissionAvgOrderByAggregateInput
    _max?: ProviderCommissionMaxOrderByAggregateInput
    _min?: ProviderCommissionMinOrderByAggregateInput
    _sum?: ProviderCommissionSumOrderByAggregateInput
  }

  export type ProviderCommissionScalarWhereWithAggregatesInput = {
    AND?: ProviderCommissionScalarWhereWithAggregatesInput | ProviderCommissionScalarWhereWithAggregatesInput[]
    OR?: ProviderCommissionScalarWhereWithAggregatesInput[]
    NOT?: ProviderCommissionScalarWhereWithAggregatesInput | ProviderCommissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProviderCommission"> | string
    invoiceLineId?: UuidWithAggregatesFilter<"ProviderCommission"> | string
    providerId?: UuidWithAggregatesFilter<"ProviderCommission"> | string
    baseAmount?: DecimalWithAggregatesFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalWithAggregatesFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalWithAggregatesFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolWithAggregatesFilter<"ProviderCommission"> | boolean
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transferStatus?: EnumTransferStatusNullableFilter<"Payment"> | $Enums.TransferStatus | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    exchangeRate?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    posTerminalId?: UuidNullableFilter<"Payment"> | string | null
    createdById?: UuidFilter<"Payment"> | string
    requestContextId?: UuidFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    posTerminal?: XOR<PosTerminalNullableScalarRelationFilter, PosTerminalWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    transferStatus?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    posTerminalId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    posTerminal?: PosTerminalOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: UuidFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transferStatus?: EnumTransferStatusNullableFilter<"Payment"> | $Enums.TransferStatus | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    exchangeRate?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    posTerminalId?: UuidNullableFilter<"Payment"> | string | null
    createdById?: UuidFilter<"Payment"> | string
    requestContextId?: UuidFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    posTerminal?: XOR<PosTerminalNullableScalarRelationFilter, PosTerminalWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    transferStatus?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    posTerminalId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    invoiceId?: UuidWithAggregatesFilter<"Payment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    transferStatus?: EnumTransferStatusNullableWithAggregatesFilter<"Payment"> | $Enums.TransferStatus | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    exchangeRate?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    posTerminalId?: UuidNullableWithAggregatesFilter<"Payment"> | string | null
    createdById?: UuidWithAggregatesFilter<"Payment"> | string
    requestContextId?: UuidWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type CashSessionWhereInput = {
    AND?: CashSessionWhereInput | CashSessionWhereInput[]
    OR?: CashSessionWhereInput[]
    NOT?: CashSessionWhereInput | CashSessionWhereInput[]
    id?: UuidFilter<"CashSession"> | string
    registerId?: UuidFilter<"CashSession"> | string
    openedById?: UuidFilter<"CashSession"> | string
    openedAt?: DateTimeFilter<"CashSession"> | Date | string
    openingFloat?: DecimalFilter<"CashSession"> | Decimal | DecimalJsLike | number | string
    closedById?: UuidNullableFilter<"CashSession"> | string | null
    closedAt?: DateTimeNullableFilter<"CashSession"> | Date | string | null
    declaredTotal?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    systemTotal?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    register?: XOR<CashRegisterScalarRelationFilter, CashRegisterWhereInput>
    openedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    closedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    movements?: CashMovementListRelationFilter
  }

  export type CashSessionOrderByWithRelationInput = {
    id?: SortOrder
    registerId?: SortOrder
    openedById?: SortOrder
    openedAt?: SortOrder
    openingFloat?: SortOrder
    closedById?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    declaredTotal?: SortOrderInput | SortOrder
    systemTotal?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    register?: CashRegisterOrderByWithRelationInput
    openedBy?: UserOrderByWithRelationInput
    closedBy?: UserOrderByWithRelationInput
    movements?: CashMovementOrderByRelationAggregateInput
  }

  export type CashSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashSessionWhereInput | CashSessionWhereInput[]
    OR?: CashSessionWhereInput[]
    NOT?: CashSessionWhereInput | CashSessionWhereInput[]
    registerId?: UuidFilter<"CashSession"> | string
    openedById?: UuidFilter<"CashSession"> | string
    openedAt?: DateTimeFilter<"CashSession"> | Date | string
    openingFloat?: DecimalFilter<"CashSession"> | Decimal | DecimalJsLike | number | string
    closedById?: UuidNullableFilter<"CashSession"> | string | null
    closedAt?: DateTimeNullableFilter<"CashSession"> | Date | string | null
    declaredTotal?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    systemTotal?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    register?: XOR<CashRegisterScalarRelationFilter, CashRegisterWhereInput>
    openedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    closedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    movements?: CashMovementListRelationFilter
  }, "id">

  export type CashSessionOrderByWithAggregationInput = {
    id?: SortOrder
    registerId?: SortOrder
    openedById?: SortOrder
    openedAt?: SortOrder
    openingFloat?: SortOrder
    closedById?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    declaredTotal?: SortOrderInput | SortOrder
    systemTotal?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    _count?: CashSessionCountOrderByAggregateInput
    _avg?: CashSessionAvgOrderByAggregateInput
    _max?: CashSessionMaxOrderByAggregateInput
    _min?: CashSessionMinOrderByAggregateInput
    _sum?: CashSessionSumOrderByAggregateInput
  }

  export type CashSessionScalarWhereWithAggregatesInput = {
    AND?: CashSessionScalarWhereWithAggregatesInput | CashSessionScalarWhereWithAggregatesInput[]
    OR?: CashSessionScalarWhereWithAggregatesInput[]
    NOT?: CashSessionScalarWhereWithAggregatesInput | CashSessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CashSession"> | string
    registerId?: UuidWithAggregatesFilter<"CashSession"> | string
    openedById?: UuidWithAggregatesFilter<"CashSession"> | string
    openedAt?: DateTimeWithAggregatesFilter<"CashSession"> | Date | string
    openingFloat?: DecimalWithAggregatesFilter<"CashSession"> | Decimal | DecimalJsLike | number | string
    closedById?: UuidNullableWithAggregatesFilter<"CashSession"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"CashSession"> | Date | string | null
    declaredTotal?: DecimalNullableWithAggregatesFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    systemTotal?: DecimalNullableWithAggregatesFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableWithAggregatesFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CashMovementWhereInput = {
    AND?: CashMovementWhereInput | CashMovementWhereInput[]
    OR?: CashMovementWhereInput[]
    NOT?: CashMovementWhereInput | CashMovementWhereInput[]
    id?: UuidFilter<"CashMovement"> | string
    sessionId?: UuidFilter<"CashMovement"> | string
    type?: EnumCashMovementTypeFilter<"CashMovement"> | $Enums.CashMovementType
    amount?: DecimalFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"CashMovement"> | string | null
    createdById?: UuidFilter<"CashMovement"> | string
    requestContextId?: UuidFilter<"CashMovement"> | string
    createdAt?: DateTimeFilter<"CashMovement"> | Date | string
    session?: XOR<CashSessionScalarRelationFilter, CashSessionWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }

  export type CashMovementOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
    session?: CashSessionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
  }

  export type CashMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashMovementWhereInput | CashMovementWhereInput[]
    OR?: CashMovementWhereInput[]
    NOT?: CashMovementWhereInput | CashMovementWhereInput[]
    sessionId?: UuidFilter<"CashMovement"> | string
    type?: EnumCashMovementTypeFilter<"CashMovement"> | $Enums.CashMovementType
    amount?: DecimalFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"CashMovement"> | string | null
    createdById?: UuidFilter<"CashMovement"> | string
    requestContextId?: UuidFilter<"CashMovement"> | string
    createdAt?: DateTimeFilter<"CashMovement"> | Date | string
    session?: XOR<CashSessionScalarRelationFilter, CashSessionWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }, "id">

  export type CashMovementOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
    _count?: CashMovementCountOrderByAggregateInput
    _avg?: CashMovementAvgOrderByAggregateInput
    _max?: CashMovementMaxOrderByAggregateInput
    _min?: CashMovementMinOrderByAggregateInput
    _sum?: CashMovementSumOrderByAggregateInput
  }

  export type CashMovementScalarWhereWithAggregatesInput = {
    AND?: CashMovementScalarWhereWithAggregatesInput | CashMovementScalarWhereWithAggregatesInput[]
    OR?: CashMovementScalarWhereWithAggregatesInput[]
    NOT?: CashMovementScalarWhereWithAggregatesInput | CashMovementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CashMovement"> | string
    sessionId?: UuidWithAggregatesFilter<"CashMovement"> | string
    type?: EnumCashMovementTypeWithAggregatesFilter<"CashMovement"> | $Enums.CashMovementType
    amount?: DecimalWithAggregatesFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"CashMovement"> | string | null
    createdById?: UuidWithAggregatesFilter<"CashMovement"> | string
    requestContextId?: UuidWithAggregatesFilter<"CashMovement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CashMovement"> | Date | string
  }

  export type InventoryProductWhereInput = {
    AND?: InventoryProductWhereInput | InventoryProductWhereInput[]
    OR?: InventoryProductWhereInput[]
    NOT?: InventoryProductWhereInput | InventoryProductWhereInput[]
    id?: UuidFilter<"InventoryProduct"> | string
    sku?: StringFilter<"InventoryProduct"> | string
    name?: StringFilter<"InventoryProduct"> | string
    unit?: StringNullableFilter<"InventoryProduct"> | string | null
    price?: DecimalFilter<"InventoryProduct"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"InventoryProduct"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"InventoryProduct"> | boolean
    stock?: ProductStockListRelationFilter
    stockMoves?: StockMovementListRelationFilter
    lines?: InvoiceLineListRelationFilter
  }

  export type InventoryProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    isActive?: SortOrder
    stock?: ProductStockOrderByRelationAggregateInput
    stockMoves?: StockMovementOrderByRelationAggregateInput
    lines?: InvoiceLineOrderByRelationAggregateInput
  }

  export type InventoryProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: InventoryProductWhereInput | InventoryProductWhereInput[]
    OR?: InventoryProductWhereInput[]
    NOT?: InventoryProductWhereInput | InventoryProductWhereInput[]
    name?: StringFilter<"InventoryProduct"> | string
    unit?: StringNullableFilter<"InventoryProduct"> | string | null
    price?: DecimalFilter<"InventoryProduct"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"InventoryProduct"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"InventoryProduct"> | boolean
    stock?: ProductStockListRelationFilter
    stockMoves?: StockMovementListRelationFilter
    lines?: InvoiceLineListRelationFilter
  }, "id" | "sku">

  export type InventoryProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    isActive?: SortOrder
    _count?: InventoryProductCountOrderByAggregateInput
    _avg?: InventoryProductAvgOrderByAggregateInput
    _max?: InventoryProductMaxOrderByAggregateInput
    _min?: InventoryProductMinOrderByAggregateInput
    _sum?: InventoryProductSumOrderByAggregateInput
  }

  export type InventoryProductScalarWhereWithAggregatesInput = {
    AND?: InventoryProductScalarWhereWithAggregatesInput | InventoryProductScalarWhereWithAggregatesInput[]
    OR?: InventoryProductScalarWhereWithAggregatesInput[]
    NOT?: InventoryProductScalarWhereWithAggregatesInput | InventoryProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InventoryProduct"> | string
    sku?: StringWithAggregatesFilter<"InventoryProduct"> | string
    name?: StringWithAggregatesFilter<"InventoryProduct"> | string
    unit?: StringNullableWithAggregatesFilter<"InventoryProduct"> | string | null
    price?: DecimalWithAggregatesFilter<"InventoryProduct"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalWithAggregatesFilter<"InventoryProduct"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"InventoryProduct"> | boolean
  }

  export type ProductStockWhereInput = {
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    id?: UuidFilter<"ProductStock"> | string
    productId?: UuidFilter<"ProductStock"> | string
    locationId?: UuidFilter<"ProductStock"> | string
    onHand?: IntFilter<"ProductStock"> | number
    product?: XOR<InventoryProductScalarRelationFilter, InventoryProductWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type ProductStockOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    product?: InventoryProductOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type ProductStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_locationId?: ProductStockProductIdLocationIdCompoundUniqueInput
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    productId?: UuidFilter<"ProductStock"> | string
    locationId?: UuidFilter<"ProductStock"> | string
    onHand?: IntFilter<"ProductStock"> | number
    product?: XOR<InventoryProductScalarRelationFilter, InventoryProductWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "productId_locationId">

  export type ProductStockOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    _count?: ProductStockCountOrderByAggregateInput
    _avg?: ProductStockAvgOrderByAggregateInput
    _max?: ProductStockMaxOrderByAggregateInput
    _min?: ProductStockMinOrderByAggregateInput
    _sum?: ProductStockSumOrderByAggregateInput
  }

  export type ProductStockScalarWhereWithAggregatesInput = {
    AND?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    OR?: ProductStockScalarWhereWithAggregatesInput[]
    NOT?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductStock"> | string
    productId?: UuidWithAggregatesFilter<"ProductStock"> | string
    locationId?: UuidWithAggregatesFilter<"ProductStock"> | string
    onHand?: IntWithAggregatesFilter<"ProductStock"> | number
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: UuidFilter<"StockMovement"> | string
    productId?: UuidFilter<"StockMovement"> | string
    locationId?: UuidFilter<"StockMovement"> | string
    qty?: IntFilter<"StockMovement"> | number
    reason?: EnumStockReasonFilter<"StockMovement"> | $Enums.StockReason
    reference?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    product?: XOR<InventoryProductScalarRelationFilter, InventoryProductWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    qty?: SortOrder
    reason?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: InventoryProductOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    productId?: UuidFilter<"StockMovement"> | string
    locationId?: UuidFilter<"StockMovement"> | string
    qty?: IntFilter<"StockMovement"> | number
    reason?: EnumStockReasonFilter<"StockMovement"> | $Enums.StockReason
    reference?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    product?: XOR<InventoryProductScalarRelationFilter, InventoryProductWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    qty?: SortOrder
    reason?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StockMovement"> | string
    productId?: UuidWithAggregatesFilter<"StockMovement"> | string
    locationId?: UuidWithAggregatesFilter<"StockMovement"> | string
    qty?: IntWithAggregatesFilter<"StockMovement"> | number
    reason?: EnumStockReasonWithAggregatesFilter<"StockMovement"> | $Enums.StockReason
    reference?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type LabInstrumentWhereInput = {
    AND?: LabInstrumentWhereInput | LabInstrumentWhereInput[]
    OR?: LabInstrumentWhereInput[]
    NOT?: LabInstrumentWhereInput | LabInstrumentWhereInput[]
    id?: UuidFilter<"LabInstrument"> | string
    name?: StringFilter<"LabInstrument"> | string
    vendor?: StringNullableFilter<"LabInstrument"> | string | null
    model?: StringNullableFilter<"LabInstrument"> | string | null
    serialNo?: StringNullableFilter<"LabInstrument"> | string | null
    connectionType?: EnumConnectionTypeNullableFilter<"LabInstrument"> | $Enums.ConnectionType | null
    locationId?: UuidNullableFilter<"LabInstrument"> | string | null
    isActive?: BoolFilter<"LabInstrument"> | boolean
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    testsDefault?: TestCatalogListRelationFilter
    orderTests?: LabOrderTestListRelationFilter
    messages?: LabDeviceMessageListRelationFilter
  }

  export type LabInstrumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vendor?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNo?: SortOrderInput | SortOrder
    connectionType?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    location?: LocationOrderByWithRelationInput
    testsDefault?: TestCatalogOrderByRelationAggregateInput
    orderTests?: LabOrderTestOrderByRelationAggregateInput
    messages?: LabDeviceMessageOrderByRelationAggregateInput
  }

  export type LabInstrumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabInstrumentWhereInput | LabInstrumentWhereInput[]
    OR?: LabInstrumentWhereInput[]
    NOT?: LabInstrumentWhereInput | LabInstrumentWhereInput[]
    name?: StringFilter<"LabInstrument"> | string
    vendor?: StringNullableFilter<"LabInstrument"> | string | null
    model?: StringNullableFilter<"LabInstrument"> | string | null
    serialNo?: StringNullableFilter<"LabInstrument"> | string | null
    connectionType?: EnumConnectionTypeNullableFilter<"LabInstrument"> | $Enums.ConnectionType | null
    locationId?: UuidNullableFilter<"LabInstrument"> | string | null
    isActive?: BoolFilter<"LabInstrument"> | boolean
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    testsDefault?: TestCatalogListRelationFilter
    orderTests?: LabOrderTestListRelationFilter
    messages?: LabDeviceMessageListRelationFilter
  }, "id">

  export type LabInstrumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    vendor?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNo?: SortOrderInput | SortOrder
    connectionType?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: LabInstrumentCountOrderByAggregateInput
    _max?: LabInstrumentMaxOrderByAggregateInput
    _min?: LabInstrumentMinOrderByAggregateInput
  }

  export type LabInstrumentScalarWhereWithAggregatesInput = {
    AND?: LabInstrumentScalarWhereWithAggregatesInput | LabInstrumentScalarWhereWithAggregatesInput[]
    OR?: LabInstrumentScalarWhereWithAggregatesInput[]
    NOT?: LabInstrumentScalarWhereWithAggregatesInput | LabInstrumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LabInstrument"> | string
    name?: StringWithAggregatesFilter<"LabInstrument"> | string
    vendor?: StringNullableWithAggregatesFilter<"LabInstrument"> | string | null
    model?: StringNullableWithAggregatesFilter<"LabInstrument"> | string | null
    serialNo?: StringNullableWithAggregatesFilter<"LabInstrument"> | string | null
    connectionType?: EnumConnectionTypeNullableWithAggregatesFilter<"LabInstrument"> | $Enums.ConnectionType | null
    locationId?: UuidNullableWithAggregatesFilter<"LabInstrument"> | string | null
    isActive?: BoolWithAggregatesFilter<"LabInstrument"> | boolean
  }

  export type SpecimenTypeWhereInput = {
    AND?: SpecimenTypeWhereInput | SpecimenTypeWhereInput[]
    OR?: SpecimenTypeWhereInput[]
    NOT?: SpecimenTypeWhereInput | SpecimenTypeWhereInput[]
    id?: UuidFilter<"SpecimenType"> | string
    name?: StringFilter<"SpecimenType"> | string
    tests?: TestCatalogListRelationFilter
    orders?: LabOrderListRelationFilter
  }

  export type SpecimenTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tests?: TestCatalogOrderByRelationAggregateInput
    orders?: LabOrderOrderByRelationAggregateInput
  }

  export type SpecimenTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SpecimenTypeWhereInput | SpecimenTypeWhereInput[]
    OR?: SpecimenTypeWhereInput[]
    NOT?: SpecimenTypeWhereInput | SpecimenTypeWhereInput[]
    tests?: TestCatalogListRelationFilter
    orders?: LabOrderListRelationFilter
  }, "id" | "name">

  export type SpecimenTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: SpecimenTypeCountOrderByAggregateInput
    _max?: SpecimenTypeMaxOrderByAggregateInput
    _min?: SpecimenTypeMinOrderByAggregateInput
  }

  export type SpecimenTypeScalarWhereWithAggregatesInput = {
    AND?: SpecimenTypeScalarWhereWithAggregatesInput | SpecimenTypeScalarWhereWithAggregatesInput[]
    OR?: SpecimenTypeScalarWhereWithAggregatesInput[]
    NOT?: SpecimenTypeScalarWhereWithAggregatesInput | SpecimenTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SpecimenType"> | string
    name?: StringWithAggregatesFilter<"SpecimenType"> | string
  }

  export type TestCatalogWhereInput = {
    AND?: TestCatalogWhereInput | TestCatalogWhereInput[]
    OR?: TestCatalogWhereInput[]
    NOT?: TestCatalogWhereInput | TestCatalogWhereInput[]
    id?: UuidFilter<"TestCatalog"> | string
    code?: StringFilter<"TestCatalog"> | string
    name?: StringFilter<"TestCatalog"> | string
    loincCode?: StringNullableFilter<"TestCatalog"> | string | null
    units?: StringNullableFilter<"TestCatalog"> | string | null
    specimenTypeId?: UuidNullableFilter<"TestCatalog"> | string | null
    defaultInstrumentId?: UuidNullableFilter<"TestCatalog"> | string | null
    isPanel?: BoolFilter<"TestCatalog"> | boolean
    parentPanelId?: UuidNullableFilter<"TestCatalog"> | string | null
    specimenType?: XOR<SpecimenTypeNullableScalarRelationFilter, SpecimenTypeWhereInput> | null
    defaultInstrument?: XOR<LabInstrumentNullableScalarRelationFilter, LabInstrumentWhereInput> | null
    parentPanel?: XOR<TestCatalogNullableScalarRelationFilter, TestCatalogWhereInput> | null
    panelMembers?: TestCatalogListRelationFilter
    ranges?: ReferenceRangeListRelationFilter
    orderTests?: LabOrderTestListRelationFilter
  }

  export type TestCatalogOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    loincCode?: SortOrderInput | SortOrder
    units?: SortOrderInput | SortOrder
    specimenTypeId?: SortOrderInput | SortOrder
    defaultInstrumentId?: SortOrderInput | SortOrder
    isPanel?: SortOrder
    parentPanelId?: SortOrderInput | SortOrder
    specimenType?: SpecimenTypeOrderByWithRelationInput
    defaultInstrument?: LabInstrumentOrderByWithRelationInput
    parentPanel?: TestCatalogOrderByWithRelationInput
    panelMembers?: TestCatalogOrderByRelationAggregateInput
    ranges?: ReferenceRangeOrderByRelationAggregateInput
    orderTests?: LabOrderTestOrderByRelationAggregateInput
  }

  export type TestCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TestCatalogWhereInput | TestCatalogWhereInput[]
    OR?: TestCatalogWhereInput[]
    NOT?: TestCatalogWhereInput | TestCatalogWhereInput[]
    name?: StringFilter<"TestCatalog"> | string
    loincCode?: StringNullableFilter<"TestCatalog"> | string | null
    units?: StringNullableFilter<"TestCatalog"> | string | null
    specimenTypeId?: UuidNullableFilter<"TestCatalog"> | string | null
    defaultInstrumentId?: UuidNullableFilter<"TestCatalog"> | string | null
    isPanel?: BoolFilter<"TestCatalog"> | boolean
    parentPanelId?: UuidNullableFilter<"TestCatalog"> | string | null
    specimenType?: XOR<SpecimenTypeNullableScalarRelationFilter, SpecimenTypeWhereInput> | null
    defaultInstrument?: XOR<LabInstrumentNullableScalarRelationFilter, LabInstrumentWhereInput> | null
    parentPanel?: XOR<TestCatalogNullableScalarRelationFilter, TestCatalogWhereInput> | null
    panelMembers?: TestCatalogListRelationFilter
    ranges?: ReferenceRangeListRelationFilter
    orderTests?: LabOrderTestListRelationFilter
  }, "id" | "code">

  export type TestCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    loincCode?: SortOrderInput | SortOrder
    units?: SortOrderInput | SortOrder
    specimenTypeId?: SortOrderInput | SortOrder
    defaultInstrumentId?: SortOrderInput | SortOrder
    isPanel?: SortOrder
    parentPanelId?: SortOrderInput | SortOrder
    _count?: TestCatalogCountOrderByAggregateInput
    _max?: TestCatalogMaxOrderByAggregateInput
    _min?: TestCatalogMinOrderByAggregateInput
  }

  export type TestCatalogScalarWhereWithAggregatesInput = {
    AND?: TestCatalogScalarWhereWithAggregatesInput | TestCatalogScalarWhereWithAggregatesInput[]
    OR?: TestCatalogScalarWhereWithAggregatesInput[]
    NOT?: TestCatalogScalarWhereWithAggregatesInput | TestCatalogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TestCatalog"> | string
    code?: StringWithAggregatesFilter<"TestCatalog"> | string
    name?: StringWithAggregatesFilter<"TestCatalog"> | string
    loincCode?: StringNullableWithAggregatesFilter<"TestCatalog"> | string | null
    units?: StringNullableWithAggregatesFilter<"TestCatalog"> | string | null
    specimenTypeId?: UuidNullableWithAggregatesFilter<"TestCatalog"> | string | null
    defaultInstrumentId?: UuidNullableWithAggregatesFilter<"TestCatalog"> | string | null
    isPanel?: BoolWithAggregatesFilter<"TestCatalog"> | boolean
    parentPanelId?: UuidNullableWithAggregatesFilter<"TestCatalog"> | string | null
  }

  export type ReferenceRangeWhereInput = {
    AND?: ReferenceRangeWhereInput | ReferenceRangeWhereInput[]
    OR?: ReferenceRangeWhereInput[]
    NOT?: ReferenceRangeWhereInput | ReferenceRangeWhereInput[]
    id?: UuidFilter<"ReferenceRange"> | string
    testId?: UuidFilter<"ReferenceRange"> | string
    sex?: EnumSexNullableFilter<"ReferenceRange"> | $Enums.Sex | null
    ageMinYears?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    lowValue?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    highValue?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"ReferenceRange"> | string | null
    test?: XOR<TestCatalogScalarRelationFilter, TestCatalogWhereInput>
  }

  export type ReferenceRangeOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    sex?: SortOrderInput | SortOrder
    ageMinYears?: SortOrderInput | SortOrder
    ageMaxYears?: SortOrderInput | SortOrder
    lowValue?: SortOrderInput | SortOrder
    highValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    test?: TestCatalogOrderByWithRelationInput
  }

  export type ReferenceRangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferenceRangeWhereInput | ReferenceRangeWhereInput[]
    OR?: ReferenceRangeWhereInput[]
    NOT?: ReferenceRangeWhereInput | ReferenceRangeWhereInput[]
    testId?: UuidFilter<"ReferenceRange"> | string
    sex?: EnumSexNullableFilter<"ReferenceRange"> | $Enums.Sex | null
    ageMinYears?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    lowValue?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    highValue?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"ReferenceRange"> | string | null
    test?: XOR<TestCatalogScalarRelationFilter, TestCatalogWhereInput>
  }, "id">

  export type ReferenceRangeOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    sex?: SortOrderInput | SortOrder
    ageMinYears?: SortOrderInput | SortOrder
    ageMaxYears?: SortOrderInput | SortOrder
    lowValue?: SortOrderInput | SortOrder
    highValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ReferenceRangeCountOrderByAggregateInput
    _avg?: ReferenceRangeAvgOrderByAggregateInput
    _max?: ReferenceRangeMaxOrderByAggregateInput
    _min?: ReferenceRangeMinOrderByAggregateInput
    _sum?: ReferenceRangeSumOrderByAggregateInput
  }

  export type ReferenceRangeScalarWhereWithAggregatesInput = {
    AND?: ReferenceRangeScalarWhereWithAggregatesInput | ReferenceRangeScalarWhereWithAggregatesInput[]
    OR?: ReferenceRangeScalarWhereWithAggregatesInput[]
    NOT?: ReferenceRangeScalarWhereWithAggregatesInput | ReferenceRangeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ReferenceRange"> | string
    testId?: UuidWithAggregatesFilter<"ReferenceRange"> | string
    sex?: EnumSexNullableWithAggregatesFilter<"ReferenceRange"> | $Enums.Sex | null
    ageMinYears?: DecimalNullableWithAggregatesFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: DecimalNullableWithAggregatesFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    lowValue?: DecimalNullableWithAggregatesFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    highValue?: DecimalNullableWithAggregatesFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"ReferenceRange"> | string | null
  }

  export type LabOrderWhereInput = {
    AND?: LabOrderWhereInput | LabOrderWhereInput[]
    OR?: LabOrderWhereInput[]
    NOT?: LabOrderWhereInput | LabOrderWhereInput[]
    id?: UuidFilter<"LabOrder"> | string
    accessionNo?: StringFilter<"LabOrder"> | string
    patientId?: UuidFilter<"LabOrder"> | string
    orderingProviderId?: UuidNullableFilter<"LabOrder"> | string | null
    invoiceId?: UuidNullableFilter<"LabOrder"> | string | null
    preclinicId?: UuidNullableFilter<"LabOrder"> | string | null
    specimenTypeId?: UuidNullableFilter<"LabOrder"> | string | null
    collectionTime?: DateTimeNullableFilter<"LabOrder"> | Date | string | null
    collectedById?: UuidNullableFilter<"LabOrder"> | string | null
    priority?: EnumPriorityNullableFilter<"LabOrder"> | $Enums.Priority | null
    status?: EnumLabOrderStatusFilter<"LabOrder"> | $Enums.LabOrderStatus
    notes?: StringNullableFilter<"LabOrder"> | string | null
    requestContextId?: UuidFilter<"LabOrder"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    orderingProvider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    preclinic?: XOR<PreclinicNullableScalarRelationFilter, PreclinicWhereInput> | null
    specimenType?: XOR<SpecimenTypeNullableScalarRelationFilter, SpecimenTypeWhereInput> | null
    collectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
    tests?: LabOrderTestListRelationFilter
    messages?: LabDeviceMessageListRelationFilter
  }

  export type LabOrderOrderByWithRelationInput = {
    id?: SortOrder
    accessionNo?: SortOrder
    patientId?: SortOrder
    orderingProviderId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    preclinicId?: SortOrderInput | SortOrder
    specimenTypeId?: SortOrderInput | SortOrder
    collectionTime?: SortOrderInput | SortOrder
    collectedById?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    requestContextId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    orderingProvider?: UserOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    preclinic?: PreclinicOrderByWithRelationInput
    specimenType?: SpecimenTypeOrderByWithRelationInput
    collectedBy?: UserOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
    tests?: LabOrderTestOrderByRelationAggregateInput
    messages?: LabDeviceMessageOrderByRelationAggregateInput
  }

  export type LabOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessionNo?: string
    AND?: LabOrderWhereInput | LabOrderWhereInput[]
    OR?: LabOrderWhereInput[]
    NOT?: LabOrderWhereInput | LabOrderWhereInput[]
    patientId?: UuidFilter<"LabOrder"> | string
    orderingProviderId?: UuidNullableFilter<"LabOrder"> | string | null
    invoiceId?: UuidNullableFilter<"LabOrder"> | string | null
    preclinicId?: UuidNullableFilter<"LabOrder"> | string | null
    specimenTypeId?: UuidNullableFilter<"LabOrder"> | string | null
    collectionTime?: DateTimeNullableFilter<"LabOrder"> | Date | string | null
    collectedById?: UuidNullableFilter<"LabOrder"> | string | null
    priority?: EnumPriorityNullableFilter<"LabOrder"> | $Enums.Priority | null
    status?: EnumLabOrderStatusFilter<"LabOrder"> | $Enums.LabOrderStatus
    notes?: StringNullableFilter<"LabOrder"> | string | null
    requestContextId?: UuidFilter<"LabOrder"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    orderingProvider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    preclinic?: XOR<PreclinicNullableScalarRelationFilter, PreclinicWhereInput> | null
    specimenType?: XOR<SpecimenTypeNullableScalarRelationFilter, SpecimenTypeWhereInput> | null
    collectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
    tests?: LabOrderTestListRelationFilter
    messages?: LabDeviceMessageListRelationFilter
  }, "id" | "accessionNo">

  export type LabOrderOrderByWithAggregationInput = {
    id?: SortOrder
    accessionNo?: SortOrder
    patientId?: SortOrder
    orderingProviderId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    preclinicId?: SortOrderInput | SortOrder
    specimenTypeId?: SortOrderInput | SortOrder
    collectionTime?: SortOrderInput | SortOrder
    collectedById?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    requestContextId?: SortOrder
    _count?: LabOrderCountOrderByAggregateInput
    _max?: LabOrderMaxOrderByAggregateInput
    _min?: LabOrderMinOrderByAggregateInput
  }

  export type LabOrderScalarWhereWithAggregatesInput = {
    AND?: LabOrderScalarWhereWithAggregatesInput | LabOrderScalarWhereWithAggregatesInput[]
    OR?: LabOrderScalarWhereWithAggregatesInput[]
    NOT?: LabOrderScalarWhereWithAggregatesInput | LabOrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LabOrder"> | string
    accessionNo?: StringWithAggregatesFilter<"LabOrder"> | string
    patientId?: UuidWithAggregatesFilter<"LabOrder"> | string
    orderingProviderId?: UuidNullableWithAggregatesFilter<"LabOrder"> | string | null
    invoiceId?: UuidNullableWithAggregatesFilter<"LabOrder"> | string | null
    preclinicId?: UuidNullableWithAggregatesFilter<"LabOrder"> | string | null
    specimenTypeId?: UuidNullableWithAggregatesFilter<"LabOrder"> | string | null
    collectionTime?: DateTimeNullableWithAggregatesFilter<"LabOrder"> | Date | string | null
    collectedById?: UuidNullableWithAggregatesFilter<"LabOrder"> | string | null
    priority?: EnumPriorityNullableWithAggregatesFilter<"LabOrder"> | $Enums.Priority | null
    status?: EnumLabOrderStatusWithAggregatesFilter<"LabOrder"> | $Enums.LabOrderStatus
    notes?: StringNullableWithAggregatesFilter<"LabOrder"> | string | null
    requestContextId?: UuidWithAggregatesFilter<"LabOrder"> | string
  }

  export type LabOrderTestWhereInput = {
    AND?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    OR?: LabOrderTestWhereInput[]
    NOT?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    id?: UuidFilter<"LabOrderTest"> | string
    orderId?: UuidFilter<"LabOrderTest"> | string
    testId?: UuidFilter<"LabOrderTest"> | string
    status?: EnumLabOrderTestStatusFilter<"LabOrderTest"> | $Enums.LabOrderTestStatus
    instrumentId?: UuidNullableFilter<"LabOrderTest"> | string | null
    analyteCodeInstrument?: StringNullableFilter<"LabOrderTest"> | string | null
    resultValue?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    resultText?: StringNullableFilter<"LabOrderTest"> | string | null
    units?: StringNullableFilter<"LabOrderTest"> | string | null
    flagAbnormal?: EnumAbnormalFlagNullableFilter<"LabOrderTest"> | $Enums.AbnormalFlag | null
    outOfRange?: EnumOutOfRangeFlagNullableFilter<"LabOrderTest"> | $Enums.OutOfRangeFlag | null
    referenceLow?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    completedAt?: DateTimeNullableFilter<"LabOrderTest"> | Date | string | null
    resultNotes?: StringNullableFilter<"LabOrderTest"> | string | null
    requestContextId?: UuidFilter<"LabOrderTest"> | string
    order?: XOR<LabOrderScalarRelationFilter, LabOrderWhereInput>
    test?: XOR<TestCatalogScalarRelationFilter, TestCatalogWhereInput>
    instrument?: XOR<LabInstrumentNullableScalarRelationFilter, LabInstrumentWhereInput> | null
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }

  export type LabOrderTestOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    instrumentId?: SortOrderInput | SortOrder
    analyteCodeInstrument?: SortOrderInput | SortOrder
    resultValue?: SortOrderInput | SortOrder
    resultText?: SortOrderInput | SortOrder
    units?: SortOrderInput | SortOrder
    flagAbnormal?: SortOrderInput | SortOrder
    outOfRange?: SortOrderInput | SortOrder
    referenceLow?: SortOrderInput | SortOrder
    referenceHigh?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    resultNotes?: SortOrderInput | SortOrder
    requestContextId?: SortOrder
    order?: LabOrderOrderByWithRelationInput
    test?: TestCatalogOrderByWithRelationInput
    instrument?: LabInstrumentOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
  }

  export type LabOrderTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    OR?: LabOrderTestWhereInput[]
    NOT?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    orderId?: UuidFilter<"LabOrderTest"> | string
    testId?: UuidFilter<"LabOrderTest"> | string
    status?: EnumLabOrderTestStatusFilter<"LabOrderTest"> | $Enums.LabOrderTestStatus
    instrumentId?: UuidNullableFilter<"LabOrderTest"> | string | null
    analyteCodeInstrument?: StringNullableFilter<"LabOrderTest"> | string | null
    resultValue?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    resultText?: StringNullableFilter<"LabOrderTest"> | string | null
    units?: StringNullableFilter<"LabOrderTest"> | string | null
    flagAbnormal?: EnumAbnormalFlagNullableFilter<"LabOrderTest"> | $Enums.AbnormalFlag | null
    outOfRange?: EnumOutOfRangeFlagNullableFilter<"LabOrderTest"> | $Enums.OutOfRangeFlag | null
    referenceLow?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    completedAt?: DateTimeNullableFilter<"LabOrderTest"> | Date | string | null
    resultNotes?: StringNullableFilter<"LabOrderTest"> | string | null
    requestContextId?: UuidFilter<"LabOrderTest"> | string
    order?: XOR<LabOrderScalarRelationFilter, LabOrderWhereInput>
    test?: XOR<TestCatalogScalarRelationFilter, TestCatalogWhereInput>
    instrument?: XOR<LabInstrumentNullableScalarRelationFilter, LabInstrumentWhereInput> | null
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }, "id">

  export type LabOrderTestOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    instrumentId?: SortOrderInput | SortOrder
    analyteCodeInstrument?: SortOrderInput | SortOrder
    resultValue?: SortOrderInput | SortOrder
    resultText?: SortOrderInput | SortOrder
    units?: SortOrderInput | SortOrder
    flagAbnormal?: SortOrderInput | SortOrder
    outOfRange?: SortOrderInput | SortOrder
    referenceLow?: SortOrderInput | SortOrder
    referenceHigh?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    resultNotes?: SortOrderInput | SortOrder
    requestContextId?: SortOrder
    _count?: LabOrderTestCountOrderByAggregateInput
    _avg?: LabOrderTestAvgOrderByAggregateInput
    _max?: LabOrderTestMaxOrderByAggregateInput
    _min?: LabOrderTestMinOrderByAggregateInput
    _sum?: LabOrderTestSumOrderByAggregateInput
  }

  export type LabOrderTestScalarWhereWithAggregatesInput = {
    AND?: LabOrderTestScalarWhereWithAggregatesInput | LabOrderTestScalarWhereWithAggregatesInput[]
    OR?: LabOrderTestScalarWhereWithAggregatesInput[]
    NOT?: LabOrderTestScalarWhereWithAggregatesInput | LabOrderTestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LabOrderTest"> | string
    orderId?: UuidWithAggregatesFilter<"LabOrderTest"> | string
    testId?: UuidWithAggregatesFilter<"LabOrderTest"> | string
    status?: EnumLabOrderTestStatusWithAggregatesFilter<"LabOrderTest"> | $Enums.LabOrderTestStatus
    instrumentId?: UuidNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    analyteCodeInstrument?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    resultValue?: DecimalNullableWithAggregatesFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    resultText?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    units?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    flagAbnormal?: EnumAbnormalFlagNullableWithAggregatesFilter<"LabOrderTest"> | $Enums.AbnormalFlag | null
    outOfRange?: EnumOutOfRangeFlagNullableWithAggregatesFilter<"LabOrderTest"> | $Enums.OutOfRangeFlag | null
    referenceLow?: DecimalNullableWithAggregatesFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableWithAggregatesFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"LabOrderTest"> | Date | string | null
    resultNotes?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    requestContextId?: UuidWithAggregatesFilter<"LabOrderTest"> | string
  }

  export type LabDeviceMessageWhereInput = {
    AND?: LabDeviceMessageWhereInput | LabDeviceMessageWhereInput[]
    OR?: LabDeviceMessageWhereInput[]
    NOT?: LabDeviceMessageWhereInput | LabDeviceMessageWhereInput[]
    id?: UuidFilter<"LabDeviceMessage"> | string
    instrumentId?: UuidFilter<"LabDeviceMessage"> | string
    orderId?: UuidNullableFilter<"LabDeviceMessage"> | string | null
    receivedAt?: DateTimeFilter<"LabDeviceMessage"> | Date | string
    protocol?: EnumProtocolKindNullableFilter<"LabDeviceMessage"> | $Enums.ProtocolKind | null
    rawContent?: StringFilter<"LabDeviceMessage"> | string
    parsedOk?: BoolFilter<"LabDeviceMessage"> | boolean
    instrument?: XOR<LabInstrumentScalarRelationFilter, LabInstrumentWhereInput>
    order?: XOR<LabOrderNullableScalarRelationFilter, LabOrderWhereInput> | null
  }

  export type LabDeviceMessageOrderByWithRelationInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    protocol?: SortOrderInput | SortOrder
    rawContent?: SortOrder
    parsedOk?: SortOrder
    instrument?: LabInstrumentOrderByWithRelationInput
    order?: LabOrderOrderByWithRelationInput
  }

  export type LabDeviceMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabDeviceMessageWhereInput | LabDeviceMessageWhereInput[]
    OR?: LabDeviceMessageWhereInput[]
    NOT?: LabDeviceMessageWhereInput | LabDeviceMessageWhereInput[]
    instrumentId?: UuidFilter<"LabDeviceMessage"> | string
    orderId?: UuidNullableFilter<"LabDeviceMessage"> | string | null
    receivedAt?: DateTimeFilter<"LabDeviceMessage"> | Date | string
    protocol?: EnumProtocolKindNullableFilter<"LabDeviceMessage"> | $Enums.ProtocolKind | null
    rawContent?: StringFilter<"LabDeviceMessage"> | string
    parsedOk?: BoolFilter<"LabDeviceMessage"> | boolean
    instrument?: XOR<LabInstrumentScalarRelationFilter, LabInstrumentWhereInput>
    order?: XOR<LabOrderNullableScalarRelationFilter, LabOrderWhereInput> | null
  }, "id">

  export type LabDeviceMessageOrderByWithAggregationInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    protocol?: SortOrderInput | SortOrder
    rawContent?: SortOrder
    parsedOk?: SortOrder
    _count?: LabDeviceMessageCountOrderByAggregateInput
    _max?: LabDeviceMessageMaxOrderByAggregateInput
    _min?: LabDeviceMessageMinOrderByAggregateInput
  }

  export type LabDeviceMessageScalarWhereWithAggregatesInput = {
    AND?: LabDeviceMessageScalarWhereWithAggregatesInput | LabDeviceMessageScalarWhereWithAggregatesInput[]
    OR?: LabDeviceMessageScalarWhereWithAggregatesInput[]
    NOT?: LabDeviceMessageScalarWhereWithAggregatesInput | LabDeviceMessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LabDeviceMessage"> | string
    instrumentId?: UuidWithAggregatesFilter<"LabDeviceMessage"> | string
    orderId?: UuidNullableWithAggregatesFilter<"LabDeviceMessage"> | string | null
    receivedAt?: DateTimeWithAggregatesFilter<"LabDeviceMessage"> | Date | string
    protocol?: EnumProtocolKindNullableWithAggregatesFilter<"LabDeviceMessage"> | $Enums.ProtocolKind | null
    rawContent?: StringWithAggregatesFilter<"LabDeviceMessage"> | string
    parsedOk?: BoolWithAggregatesFilter<"LabDeviceMessage"> | boolean
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: UuidFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: UuidFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    actorId?: UuidFilter<"ActivityLog"> | string
    requestContextId?: UuidFilter<"ActivityLog"> | string
    metadata?: JsonNullableFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    actor?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    requestContextId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
    requestContext?: RequestContextOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: UuidFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    actorId?: UuidFilter<"ActivityLog"> | string
    requestContextId?: UuidFilter<"ActivityLog"> | string
    metadata?: JsonNullableFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    actor?: XOR<UserScalarRelationFilter, UserWhereInput>
    requestContext?: XOR<RequestContextScalarRelationFilter, RequestContextWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    requestContextId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ActivityLog"> | string
    entity?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: UuidWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    actorId?: UuidWithAggregatesFilter<"ActivityLog"> | string
    requestContextId?: UuidWithAggregatesFilter<"ActivityLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type bootstrapCreateInput = {
    id?: string
    txt: string
  }

  export type bootstrapUncheckedCreateInput = {
    id?: string
    txt: string
  }

  export type bootstrapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    txt?: StringFieldUpdateOperationsInput | string
  }

  export type bootstrapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    txt?: StringFieldUpdateOperationsInput | string
  }

  export type bootstrapCreateManyInput = {
    id?: string
    txt: string
  }

  export type bootstrapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    txt?: StringFieldUpdateOperationsInput | string
  }

  export type bootstrapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    txt?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address?: string | null
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashRegisterCreateInput = {
    id?: string
    name: string
    location: LocationCreateNestedOneWithoutRegistersInput
    sessions?: CashSessionCreateNestedManyWithoutRegisterInput
    invoices?: InvoiceCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateInput = {
    id?: string
    name: string
    locationId: string
    sessions?: CashSessionUncheckedCreateNestedManyWithoutRegisterInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutRegistersNestedInput
    sessions?: CashSessionUpdateManyWithoutRegisterNestedInput
    invoices?: InvoiceUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sessions?: CashSessionUncheckedUpdateManyWithoutRegisterNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterCreateManyInput = {
    id?: string
    name: string
    locationId: string
  }

  export type CashRegisterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CashRegisterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type PosTerminalCreateInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    location: LocationCreateNestedOneWithoutPosTerminalsInput
    payments?: PaymentCreateNestedManyWithoutPosTerminalInput
  }

  export type PosTerminalUncheckedCreateInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    locationId: string
    payments?: PaymentUncheckedCreateNestedManyWithoutPosTerminalInput
  }

  export type PosTerminalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutPosTerminalsNestedInput
    payments?: PaymentUpdateManyWithoutPosTerminalNestedInput
  }

  export type PosTerminalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutPosTerminalNestedInput
  }

  export type PosTerminalCreateManyInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    locationId: string
  }

  export type PosTerminalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PosTerminalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkstationCreateInput = {
    id?: string
    name: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    location: LocationCreateNestedOneWithoutWorkstationsInput
    sessions?: AuthSessionCreateNestedManyWithoutWorkstationInput
    contexts?: RequestContextCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationUncheckedCreateInput = {
    id?: string
    name: string
    locationId: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutWorkstationInput
    contexts?: RequestContextUncheckedCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutWorkstationsNestedInput
    sessions?: AuthSessionUpdateManyWithoutWorkstationNestedInput
    contexts?: RequestContextUpdateManyWithoutWorkstationNestedInput
  }

  export type WorkstationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sessions?: AuthSessionUncheckedUpdateManyWithoutWorkstationNestedInput
    contexts?: RequestContextUncheckedUpdateManyWithoutWorkstationNestedInput
  }

  export type WorkstationCreateManyInput = {
    id?: string
    name: string
    locationId: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
  }

  export type WorkstationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkstationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PatientCreateInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
    workstation?: WorkstationCreateNestedOneWithoutSessionsInput
    contexts?: RequestContextCreateNestedManyWithoutSessionInput
  }

  export type AuthSessionUncheckedCreateInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    contexts?: RequestContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AuthSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    workstation?: WorkstationUpdateOneWithoutSessionsNestedInput
    contexts?: RequestContextUpdateManyWithoutSessionNestedInput
  }

  export type AuthSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    contexts?: RequestContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AuthSessionCreateManyInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
  }

  export type AuthSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuthSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestContextCreateInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextCreateManyInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
  }

  export type RequestContextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type RequestContextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PreclinicCreateInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    patient: PatientCreateNestedOneWithoutPreclinicsInput
    labOrders?: LabOrderCreateNestedManyWithoutPreclinicInput
    recordedBy: UserCreateNestedOneWithoutPreclinicsInput
    requestContext: RequestContextCreateNestedOneWithoutPreclinicsInput
    invoices?: InvoiceCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicUncheckedCreateInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    requestContextId: string
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPreclinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutPreclinicsNestedInput
    labOrders?: LabOrderUpdateManyWithoutPreclinicNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutPreclinicsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPreclinicsNestedInput
    invoices?: InvoiceUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    labOrders?: LabOrderUncheckedUpdateManyWithoutPreclinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicCreateManyInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    requestContextId: string
  }

  export type PreclinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreclinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyCreateInput = {
    id?: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAllergiesInput
    recordedBy?: UserCreateNestedOneWithoutAllergiesRecordedInput
  }

  export type AllergyUncheckedCreateInput = {
    id?: string
    patientId: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    recordedById?: string | null
  }

  export type AllergyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAllergiesNestedInput
    recordedBy?: UserUpdateOneWithoutAllergiesRecordedNestedInput
  }

  export type AllergyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyCreateManyInput = {
    id?: string
    patientId: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    recordedById?: string | null
  }

  export type AllergyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProblemCreateInput = {
    id?: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutProblemsInput
    recordedBy?: UserCreateNestedOneWithoutProblemsRecordedInput
  }

  export type ProblemUncheckedCreateInput = {
    id?: string
    patientId: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    recordedById?: string | null
  }

  export type ProblemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutProblemsNestedInput
    recordedBy?: UserUpdateOneWithoutProblemsRecordedNestedInput
  }

  export type ProblemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProblemCreateManyInput = {
    id?: string
    patientId: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    recordedById?: string | null
  }

  export type ProblemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProblemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationCreateInput = {
    id?: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutMedicationsInput
    prescribedBy?: UserCreateNestedOneWithoutMedicationsRxInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    patientId: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    prescribedById?: string | null
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutMedicationsNestedInput
    prescribedBy?: UserUpdateOneWithoutMedicationsRxNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationCreateManyInput = {
    id?: string
    patientId: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    prescribedById?: string | null
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    services?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    code: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    lines?: InvoiceLineCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    categoryId: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    code: string
    name: string
    categoryId: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderCreateInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    lines?: InvoiceLineCreateNestedManyWithoutProviderInput
    commissions?: ProviderCommissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutProviderInput
    commissions?: ProviderCommissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUpdateManyWithoutProviderNestedInput
    commissions?: ProviderCommissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutProviderNestedInput
    commissions?: ProviderCommissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineCreateInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
    service?: ServiceCreateNestedOneWithoutLinesInput
    product?: InventoryProductCreateNestedOneWithoutLinesInput
    provider?: ProviderCreateNestedOneWithoutLinesInput
    commission?: ProviderCommissionCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
    commission?: ProviderCommissionUncheckedCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
    service?: ServiceUpdateOneWithoutLinesNestedInput
    product?: InventoryProductUpdateOneWithoutLinesNestedInput
    provider?: ProviderUpdateOneWithoutLinesNestedInput
    commission?: ProviderCommissionUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: ProviderCommissionUncheckedUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
  }

  export type InvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderCommissionCreateInput = {
    id?: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    invoiceLine: InvoiceLineCreateNestedOneWithoutCommissionInput
    provider: ProviderCreateNestedOneWithoutCommissionsInput
  }

  export type ProviderCommissionUncheckedCreateInput = {
    id?: string
    invoiceLineId: string
    providerId: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
  }

  export type ProviderCommissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceLine?: InvoiceLineUpdateOneRequiredWithoutCommissionNestedInput
    provider?: ProviderUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type ProviderCommissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceLineId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderCommissionCreateManyInput = {
    id?: string
    invoiceLineId: string
    providerId: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
  }

  export type ProviderCommissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderCommissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceLineId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    posTerminal?: PosTerminalCreateNestedOneWithoutPaymentsInput
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
    requestContext: RequestContextCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    posTerminal?: PosTerminalUpdateOneWithoutPaymentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashSessionCreateInput = {
    id?: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    register: CashRegisterCreateNestedOneWithoutSessionsInput
    openedBy: UserCreateNestedOneWithoutCashSessionsOpenInput
    closedBy?: UserCreateNestedOneWithoutCashSessionsCloseInput
    movements?: CashMovementCreateNestedManyWithoutSessionInput
  }

  export type CashSessionUncheckedCreateInput = {
    id?: string
    registerId: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CashSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    register?: CashRegisterUpdateOneRequiredWithoutSessionsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutCashSessionsOpenNestedInput
    closedBy?: UserUpdateOneWithoutCashSessionsCloseNestedInput
    movements?: CashMovementUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionCreateManyInput = {
    id?: string
    registerId: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashMovementCreateInput = {
    id?: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    session: CashSessionCreateNestedOneWithoutMovementsInput
    createdBy: UserCreateNestedOneWithoutCashMovementsInput
    requestContext: RequestContextCreateNestedOneWithoutCashMovesInput
  }

  export type CashMovementUncheckedCreateInput = {
    id?: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type CashMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CashSessionUpdateOneRequiredWithoutMovementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCashMovementsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutCashMovesNestedInput
  }

  export type CashMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementCreateManyInput = {
    id?: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type CashMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryProductCreateInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stock?: ProductStockCreateNestedManyWithoutProductInput
    stockMoves?: StockMovementCreateNestedManyWithoutProductInput
    lines?: InvoiceLineCreateNestedManyWithoutProductInput
  }

  export type InventoryProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stock?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutProductInput
  }

  export type InventoryProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stock?: ProductStockUpdateManyWithoutProductNestedInput
    stockMoves?: StockMovementUpdateManyWithoutProductNestedInput
    lines?: InvoiceLineUpdateManyWithoutProductNestedInput
  }

  export type InventoryProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stock?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    lines?: InvoiceLineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type InventoryProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
  }

  export type InventoryProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductStockCreateInput = {
    id?: string
    onHand: number
    product: InventoryProductCreateNestedOneWithoutStockInput
    location: LocationCreateNestedOneWithoutProductStockInput
  }

  export type ProductStockUncheckedCreateInput = {
    id?: string
    productId: string
    locationId: string
    onHand: number
  }

  export type ProductStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
    product?: InventoryProductUpdateOneRequiredWithoutStockNestedInput
    location?: LocationUpdateOneRequiredWithoutProductStockNestedInput
  }

  export type ProductStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type ProductStockCreateManyInput = {
    id?: string
    productId: string
    locationId: string
    onHand: number
  }

  export type ProductStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type ProductStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type StockMovementCreateInput = {
    id?: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
    product: InventoryProductCreateNestedOneWithoutStockMovesInput
    location: LocationCreateNestedOneWithoutStockMovesInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    productId: string
    locationId: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: InventoryProductUpdateOneRequiredWithoutStockMovesNestedInput
    location?: LocationUpdateOneRequiredWithoutStockMovesNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    productId: string
    locationId: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabInstrumentCreateInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
    location?: LocationCreateNestedOneWithoutLabInstrumentsInput
    testsDefault?: TestCatalogCreateNestedManyWithoutDefaultInstrumentInput
    orderTests?: LabOrderTestCreateNestedManyWithoutInstrumentInput
    messages?: LabDeviceMessageCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentUncheckedCreateInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    locationId?: string | null
    isActive?: boolean
    testsDefault?: TestCatalogUncheckedCreateNestedManyWithoutDefaultInstrumentInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutInstrumentInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutLabInstrumentsNestedInput
    testsDefault?: TestCatalogUpdateManyWithoutDefaultInstrumentNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutInstrumentNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    testsDefault?: TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutInstrumentNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentCreateManyInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    locationId?: string | null
    isActive?: boolean
  }

  export type LabInstrumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabInstrumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpecimenTypeCreateInput = {
    id?: string
    name: string
    tests?: TestCatalogCreateNestedManyWithoutSpecimenTypeInput
    orders?: LabOrderCreateNestedManyWithoutSpecimenTypeInput
  }

  export type SpecimenTypeUncheckedCreateInput = {
    id?: string
    name: string
    tests?: TestCatalogUncheckedCreateNestedManyWithoutSpecimenTypeInput
    orders?: LabOrderUncheckedCreateNestedManyWithoutSpecimenTypeInput
  }

  export type SpecimenTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tests?: TestCatalogUpdateManyWithoutSpecimenTypeNestedInput
    orders?: LabOrderUpdateManyWithoutSpecimenTypeNestedInput
  }

  export type SpecimenTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tests?: TestCatalogUncheckedUpdateManyWithoutSpecimenTypeNestedInput
    orders?: LabOrderUncheckedUpdateManyWithoutSpecimenTypeNestedInput
  }

  export type SpecimenTypeCreateManyInput = {
    id?: string
    name: string
  }

  export type SpecimenTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpecimenTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TestCatalogCreateInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    specimenType?: SpecimenTypeCreateNestedOneWithoutTestsInput
    defaultInstrument?: LabInstrumentCreateNestedOneWithoutTestsDefaultInput
    parentPanel?: TestCatalogCreateNestedOneWithoutPanelMembersInput
    panelMembers?: TestCatalogCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
    panelMembers?: TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeUncheckedCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    specimenType?: SpecimenTypeUpdateOneWithoutTestsNestedInput
    defaultInstrument?: LabInstrumentUpdateOneWithoutTestsDefaultNestedInput
    parentPanel?: TestCatalogUpdateOneWithoutPanelMembersNestedInput
    panelMembers?: TestCatalogUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    panelMembers?: TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogCreateManyInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
  }

  export type TestCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceRangeCreateInput = {
    id?: string
    sex?: $Enums.Sex | null
    ageMinYears?: Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: Decimal | DecimalJsLike | number | string | null
    lowValue?: Decimal | DecimalJsLike | number | string | null
    highValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    test: TestCatalogCreateNestedOneWithoutRangesInput
  }

  export type ReferenceRangeUncheckedCreateInput = {
    id?: string
    testId: string
    sex?: $Enums.Sex | null
    ageMinYears?: Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: Decimal | DecimalJsLike | number | string | null
    lowValue?: Decimal | DecimalJsLike | number | string | null
    highValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type ReferenceRangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    test?: TestCatalogUpdateOneRequiredWithoutRangesNestedInput
  }

  export type ReferenceRangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceRangeCreateManyInput = {
    id?: string
    testId: string
    sex?: $Enums.Sex | null
    ageMinYears?: Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: Decimal | DecimalJsLike | number | string | null
    lowValue?: Decimal | DecimalJsLike | number | string | null
    highValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type ReferenceRangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceRangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderCreateInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderCreateManyInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type LabOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestCreateInput = {
    id?: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    order: LabOrderCreateNestedOneWithoutTestsInput
    test: TestCatalogCreateNestedOneWithoutOrderTestsInput
    instrument?: LabInstrumentCreateNestedOneWithoutOrderTestsInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrderTestsInput
  }

  export type LabOrderTestUncheckedCreateInput = {
    id?: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabOrderTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
    test?: TestCatalogUpdateOneRequiredWithoutOrderTestsNestedInput
    instrument?: LabInstrumentUpdateOneWithoutOrderTestsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrderTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestCreateManyInput = {
    id?: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabOrderTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabDeviceMessageCreateInput = {
    id?: string
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
    instrument: LabInstrumentCreateNestedOneWithoutMessagesInput
    order?: LabOrderCreateNestedOneWithoutMessagesInput
  }

  export type LabDeviceMessageUncheckedCreateInput = {
    id?: string
    instrumentId: string
    orderId?: string | null
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
  }

  export type LabDeviceMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
    instrument?: LabInstrumentUpdateOneRequiredWithoutMessagesNestedInput
    order?: LabOrderUpdateOneWithoutMessagesNestedInput
  }

  export type LabDeviceMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabDeviceMessageCreateManyInput = {
    id?: string
    instrumentId: string
    orderId?: string | null
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
  }

  export type LabDeviceMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabDeviceMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogCreateInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor: UserCreateNestedOneWithoutActivityInput
    requestContext: RequestContextCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    actorId: string
    requestContextId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutActivityNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    actorId: string
    requestContextId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type bootstrapCountOrderByAggregateInput = {
    id?: SortOrder
    txt?: SortOrder
  }

  export type bootstrapMaxOrderByAggregateInput = {
    id?: SortOrder
    txt?: SortOrder
  }

  export type bootstrapMinOrderByAggregateInput = {
    id?: SortOrder
    txt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AuthSessionListRelationFilter = {
    every?: AuthSessionWhereInput
    some?: AuthSessionWhereInput
    none?: AuthSessionWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type PreclinicListRelationFilter = {
    every?: PreclinicWhereInput
    some?: PreclinicWhereInput
    none?: PreclinicWhereInput
  }

  export type ProblemListRelationFilter = {
    every?: ProblemWhereInput
    some?: ProblemWhereInput
    none?: ProblemWhereInput
  }

  export type AllergyListRelationFilter = {
    every?: AllergyWhereInput
    some?: AllergyWhereInput
    none?: AllergyWhereInput
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CashSessionListRelationFilter = {
    every?: CashSessionWhereInput
    some?: CashSessionWhereInput
    none?: CashSessionWhereInput
  }

  export type CashMovementListRelationFilter = {
    every?: CashMovementWhereInput
    some?: CashMovementWhereInput
    none?: CashMovementWhereInput
  }

  export type LabOrderListRelationFilter = {
    every?: LabOrderWhereInput
    some?: LabOrderWhereInput
    none?: LabOrderWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type AuthSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreclinicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllergyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type CashRegisterListRelationFilter = {
    every?: CashRegisterWhereInput
    some?: CashRegisterWhereInput
    none?: CashRegisterWhereInput
  }

  export type PosTerminalListRelationFilter = {
    every?: PosTerminalWhereInput
    some?: PosTerminalWhereInput
    none?: PosTerminalWhereInput
  }

  export type WorkstationListRelationFilter = {
    every?: WorkstationWhereInput
    some?: WorkstationWhereInput
    none?: WorkstationWhereInput
  }

  export type ProductStockListRelationFilter = {
    every?: ProductStockWhereInput
    some?: ProductStockWhereInput
    none?: ProductStockWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type LabInstrumentListRelationFilter = {
    every?: LabInstrumentWhereInput
    some?: LabInstrumentWhereInput
    none?: LabInstrumentWhereInput
  }

  export type CashRegisterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosTerminalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkstationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabInstrumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type CashRegisterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
  }

  export type CashRegisterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
  }

  export type CashRegisterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
  }

  export type PosTerminalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    merchantId?: SortOrder
    locationId?: SortOrder
  }

  export type PosTerminalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    merchantId?: SortOrder
    locationId?: SortOrder
  }

  export type PosTerminalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    merchantId?: SortOrder
    locationId?: SortOrder
  }

  export type EnumWorkstationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkstationType | EnumWorkstationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkstationTypeFilter<$PrismaModel> | $Enums.WorkstationType
  }

  export type RequestContextListRelationFilter = {
    every?: RequestContextWhereInput
    some?: RequestContextWhereInput
    none?: RequestContextWhereInput
  }

  export type RequestContextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkstationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    macAddress?: SortOrder
    allowedIpCidr?: SortOrder
    isActive?: SortOrder
  }

  export type WorkstationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    macAddress?: SortOrder
    allowedIpCidr?: SortOrder
    isActive?: SortOrder
  }

  export type WorkstationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    macAddress?: SortOrder
    allowedIpCidr?: SortOrder
    isActive?: SortOrder
  }

  export type EnumWorkstationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkstationType | EnumWorkstationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkstationTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkstationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkstationTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkstationTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSexNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableFilter<$PrismaModel> | $Enums.Sex | null
  }

  export type EnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    mrn?: SortOrder
    nationalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    sex?: SortOrder
    maritalStatus?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    bloodType?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    mrn?: SortOrder
    nationalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    sex?: SortOrder
    maritalStatus?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    bloodType?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    mrn?: SortOrder
    nationalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    sex?: SortOrder
    maritalStatus?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    bloodType?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSexNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sex | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexNullableFilter<$PrismaModel>
    _max?: NestedEnumSexNullableFilter<$PrismaModel>
  }

  export type EnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkstationNullableScalarRelationFilter = {
    is?: WorkstationWhereInput | null
    isNot?: WorkstationWhereInput | null
  }

  export type AuthSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    workstationId?: SortOrder
    geoCountry?: SortOrder
    geoRegion?: SortOrder
    geoCity?: SortOrder
    geoLat?: SortOrder
    geoLon?: SortOrder
    mfaPassed?: SortOrder
  }

  export type AuthSessionAvgOrderByAggregateInput = {
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type AuthSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    workstationId?: SortOrder
    geoCountry?: SortOrder
    geoRegion?: SortOrder
    geoCity?: SortOrder
    geoLat?: SortOrder
    geoLon?: SortOrder
    mfaPassed?: SortOrder
  }

  export type AuthSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    workstationId?: SortOrder
    geoCountry?: SortOrder
    geoRegion?: SortOrder
    geoCity?: SortOrder
    geoLat?: SortOrder
    geoLon?: SortOrder
    mfaPassed?: SortOrder
  }

  export type AuthSessionSumOrderByAggregateInput = {
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type AuthSessionScalarRelationFilter = {
    is?: AuthSessionWhereInput
    isNot?: AuthSessionWhereInput
  }

  export type LabOrderTestListRelationFilter = {
    every?: LabOrderTestWhereInput
    some?: LabOrderTestWhereInput
    none?: LabOrderTestWhereInput
  }

  export type LabOrderTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestContextCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    occurredAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    workstationId?: SortOrder
    geoCountry?: SortOrder
    geoRegion?: SortOrder
    geoCity?: SortOrder
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type RequestContextAvgOrderByAggregateInput = {
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type RequestContextMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    occurredAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    workstationId?: SortOrder
    geoCountry?: SortOrder
    geoRegion?: SortOrder
    geoCity?: SortOrder
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type RequestContextMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    occurredAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    workstationId?: SortOrder
    geoCountry?: SortOrder
    geoRegion?: SortOrder
    geoCity?: SortOrder
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type RequestContextSumOrderByAggregateInput = {
    geoLat?: SortOrder
    geoLon?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type RequestContextScalarRelationFilter = {
    is?: RequestContextWhereInput
    isNot?: RequestContextWhereInput
  }

  export type PreclinicCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitDate?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respRate?: SortOrder
    temperatureC?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bmi?: SortOrder
    chiefComplaint?: SortOrder
    currentMedications?: SortOrder
    diabetes?: SortOrder
    hypertension?: SortOrder
    otherConditions?: SortOrder
    allergiesReported?: SortOrder
    recordedById?: SortOrder
    requestContextId?: SortOrder
  }

  export type PreclinicAvgOrderByAggregateInput = {
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respRate?: SortOrder
    temperatureC?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bmi?: SortOrder
  }

  export type PreclinicMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitDate?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respRate?: SortOrder
    temperatureC?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bmi?: SortOrder
    chiefComplaint?: SortOrder
    currentMedications?: SortOrder
    diabetes?: SortOrder
    hypertension?: SortOrder
    otherConditions?: SortOrder
    allergiesReported?: SortOrder
    recordedById?: SortOrder
    requestContextId?: SortOrder
  }

  export type PreclinicMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitDate?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respRate?: SortOrder
    temperatureC?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bmi?: SortOrder
    chiefComplaint?: SortOrder
    currentMedications?: SortOrder
    diabetes?: SortOrder
    hypertension?: SortOrder
    otherConditions?: SortOrder
    allergiesReported?: SortOrder
    recordedById?: SortOrder
    requestContextId?: SortOrder
  }

  export type PreclinicSumOrderByAggregateInput = {
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    respRate?: SortOrder
    temperatureC?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bmi?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumAllergySeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergySeverity | EnumAllergySeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAllergySeverityNullableFilter<$PrismaModel> | $Enums.AllergySeverity | null
  }

  export type AllergyCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    reaction?: SortOrder
    severity?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type AllergyMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    reaction?: SortOrder
    severity?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type AllergyMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    reaction?: SortOrder
    severity?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type EnumAllergySeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergySeverity | EnumAllergySeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAllergySeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.AllergySeverity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAllergySeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumAllergySeverityNullableFilter<$PrismaModel>
  }

  export type EnumProblemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProblemStatus | EnumProblemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProblemStatusFilter<$PrismaModel> | $Enums.ProblemStatus
  }

  export type ProblemCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    diagnosedAt?: SortOrder
    resolvedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type ProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    diagnosedAt?: SortOrder
    resolvedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type ProblemMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    diagnosedAt?: SortOrder
    resolvedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type EnumProblemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProblemStatus | EnumProblemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProblemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProblemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProblemStatusFilter<$PrismaModel>
    _max?: NestedEnumProblemStatusFilter<$PrismaModel>
  }

  export type EnumRouteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Route | EnumRouteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRouteNullableFilter<$PrismaModel> | $Enums.Route | null
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    drugName?: SortOrder
    dose?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    prescribedById?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    drugName?: SortOrder
    dose?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    prescribedById?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    drugName?: SortOrder
    dose?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    prescribedById?: SortOrder
  }

  export type EnumRouteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Route | EnumRouteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRouteNullableWithAggregatesFilter<$PrismaModel> | $Enums.Route | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRouteNullableFilter<$PrismaModel>
    _max?: NestedEnumRouteNullableFilter<$PrismaModel>
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrder
    requiresProvider?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrder
    requiresProvider?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrder
    requiresProvider?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    taxRatePct?: SortOrder
    commissionPct?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProviderCommissionListRelationFilter = {
    every?: ProviderCommissionWhereInput
    some?: ProviderCommissionWhereInput
    none?: ProviderCommissionWhereInput
  }

  export type ProviderCommissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    specialty?: SortOrder
    defaultCommissionPct?: SortOrder
    isActive?: SortOrder
  }

  export type ProviderAvgOrderByAggregateInput = {
    defaultCommissionPct?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    specialty?: SortOrder
    defaultCommissionPct?: SortOrder
    isActive?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    specialty?: SortOrder
    defaultCommissionPct?: SortOrder
    isActive?: SortOrder
  }

  export type ProviderSumOrderByAggregateInput = {
    defaultCommissionPct?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type PreclinicNullableScalarRelationFilter = {
    is?: PreclinicWhereInput | null
    isNot?: PreclinicWhereInput | null
  }

  export type CashRegisterNullableScalarRelationFilter = {
    is?: CashRegisterWhereInput | null
    isNot?: CashRegisterWhereInput | null
  }

  export type InvoiceInvoiceNoLocationIdCompoundUniqueInput = {
    invoiceNo: string
    locationId: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    patientId?: SortOrder
    preclinicId?: SortOrder
    status?: SortOrder
    invoiceAt?: SortOrder
    locationId?: SortOrder
    cashierId?: SortOrder
    registerId?: SortOrder
    requestContextId?: SortOrder
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    patientId?: SortOrder
    preclinicId?: SortOrder
    status?: SortOrder
    invoiceAt?: SortOrder
    locationId?: SortOrder
    cashierId?: SortOrder
    registerId?: SortOrder
    requestContextId?: SortOrder
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    patientId?: SortOrder
    preclinicId?: SortOrder
    status?: SortOrder
    invoiceAt?: SortOrder
    locationId?: SortOrder
    cashierId?: SortOrder
    registerId?: SortOrder
    requestContextId?: SortOrder
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    discountTotal?: SortOrder
    taxTotal?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type InventoryProductNullableScalarRelationFilter = {
    is?: InventoryProductWhereInput | null
    isNot?: InventoryProductWhereInput | null
  }

  export type ProviderNullableScalarRelationFilter = {
    is?: ProviderWhereInput | null
    isNot?: ProviderWhereInput | null
  }

  export type ProviderCommissionNullableScalarRelationFilter = {
    is?: ProviderCommissionWhereInput | null
    isNot?: ProviderCommissionWhereInput | null
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNo?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
    providerId?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    lineNo?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNo?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
    providerId?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNo?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
    providerId?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    lineNo?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPct?: SortOrder
    taxRatePct?: SortOrder
    lineTotal?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type InvoiceLineScalarRelationFilter = {
    is?: InvoiceLineWhereInput
    isNot?: InvoiceLineWhereInput
  }

  export type ProviderScalarRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type ProviderCommissionCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceLineId?: SortOrder
    providerId?: SortOrder
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
    isPaid?: SortOrder
  }

  export type ProviderCommissionAvgOrderByAggregateInput = {
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
  }

  export type ProviderCommissionMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceLineId?: SortOrder
    providerId?: SortOrder
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
    isPaid?: SortOrder
  }

  export type ProviderCommissionMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceLineId?: SortOrder
    providerId?: SortOrder
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
    isPaid?: SortOrder
  }

  export type ProviderCommissionSumOrderByAggregateInput = {
    baseAmount?: SortOrder
    ratePct?: SortOrder
    commissionAmount?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumTransferStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransferStatusNullableFilter<$PrismaModel> | $Enums.TransferStatus | null
  }

  export type PosTerminalNullableScalarRelationFilter = {
    is?: PosTerminalWhereInput | null
    isNot?: PosTerminalWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    transferStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    reference?: SortOrder
    posTerminalId?: SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    transferStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    reference?: SortOrder
    posTerminalId?: SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    transferStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    reference?: SortOrder
    posTerminalId?: SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumTransferStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransferStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusNullableFilter<$PrismaModel>
  }

  export type CashRegisterScalarRelationFilter = {
    is?: CashRegisterWhereInput
    isNot?: CashRegisterWhereInput
  }

  export type CashSessionCountOrderByAggregateInput = {
    id?: SortOrder
    registerId?: SortOrder
    openedById?: SortOrder
    openedAt?: SortOrder
    openingFloat?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    declaredTotal?: SortOrder
    systemTotal?: SortOrder
    variance?: SortOrder
  }

  export type CashSessionAvgOrderByAggregateInput = {
    openingFloat?: SortOrder
    declaredTotal?: SortOrder
    systemTotal?: SortOrder
    variance?: SortOrder
  }

  export type CashSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    registerId?: SortOrder
    openedById?: SortOrder
    openedAt?: SortOrder
    openingFloat?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    declaredTotal?: SortOrder
    systemTotal?: SortOrder
    variance?: SortOrder
  }

  export type CashSessionMinOrderByAggregateInput = {
    id?: SortOrder
    registerId?: SortOrder
    openedById?: SortOrder
    openedAt?: SortOrder
    openingFloat?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    declaredTotal?: SortOrder
    systemTotal?: SortOrder
    variance?: SortOrder
  }

  export type CashSessionSumOrderByAggregateInput = {
    openingFloat?: SortOrder
    declaredTotal?: SortOrder
    systemTotal?: SortOrder
    variance?: SortOrder
  }

  export type EnumCashMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashMovementType | EnumCashMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashMovementTypeFilter<$PrismaModel> | $Enums.CashMovementType
  }

  export type CashSessionScalarRelationFilter = {
    is?: CashSessionWhereInput
    isNot?: CashSessionWhereInput
  }

  export type CashMovementCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type CashMovementAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CashMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type CashMovementMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    createdById?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type CashMovementSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumCashMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashMovementType | EnumCashMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumCashMovementTypeFilter<$PrismaModel>
  }

  export type InventoryProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    isActive?: SortOrder
  }

  export type InventoryProductAvgOrderByAggregateInput = {
    price?: SortOrder
    taxRatePct?: SortOrder
  }

  export type InventoryProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    isActive?: SortOrder
  }

  export type InventoryProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    taxRatePct?: SortOrder
    isActive?: SortOrder
  }

  export type InventoryProductSumOrderByAggregateInput = {
    price?: SortOrder
    taxRatePct?: SortOrder
  }

  export type InventoryProductScalarRelationFilter = {
    is?: InventoryProductWhereInput
    isNot?: InventoryProductWhereInput
  }

  export type ProductStockProductIdLocationIdCompoundUniqueInput = {
    productId: string
    locationId: string
  }

  export type ProductStockCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
  }

  export type ProductStockAvgOrderByAggregateInput = {
    onHand?: SortOrder
  }

  export type ProductStockMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
  }

  export type ProductStockMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
  }

  export type ProductStockSumOrderByAggregateInput = {
    onHand?: SortOrder
  }

  export type EnumStockReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.StockReason | EnumStockReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStockReasonFilter<$PrismaModel> | $Enums.StockReason
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    qty?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    qty?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    locationId?: SortOrder
    qty?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type EnumStockReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockReason | EnumStockReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStockReasonWithAggregatesFilter<$PrismaModel> | $Enums.StockReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockReasonFilter<$PrismaModel>
    _max?: NestedEnumStockReasonFilter<$PrismaModel>
  }

  export type EnumConnectionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConnectionTypeNullableFilter<$PrismaModel> | $Enums.ConnectionType | null
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type TestCatalogListRelationFilter = {
    every?: TestCatalogWhereInput
    some?: TestCatalogWhereInput
    none?: TestCatalogWhereInput
  }

  export type LabDeviceMessageListRelationFilter = {
    every?: LabDeviceMessageWhereInput
    some?: LabDeviceMessageWhereInput
    none?: LabDeviceMessageWhereInput
  }

  export type TestCatalogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabDeviceMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabInstrumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vendor?: SortOrder
    model?: SortOrder
    serialNo?: SortOrder
    connectionType?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
  }

  export type LabInstrumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vendor?: SortOrder
    model?: SortOrder
    serialNo?: SortOrder
    connectionType?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
  }

  export type LabInstrumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vendor?: SortOrder
    model?: SortOrder
    serialNo?: SortOrder
    connectionType?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
  }

  export type EnumConnectionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConnectionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConnectionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumConnectionTypeNullableFilter<$PrismaModel>
  }

  export type SpecimenTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SpecimenTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SpecimenTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SpecimenTypeNullableScalarRelationFilter = {
    is?: SpecimenTypeWhereInput | null
    isNot?: SpecimenTypeWhereInput | null
  }

  export type LabInstrumentNullableScalarRelationFilter = {
    is?: LabInstrumentWhereInput | null
    isNot?: LabInstrumentWhereInput | null
  }

  export type TestCatalogNullableScalarRelationFilter = {
    is?: TestCatalogWhereInput | null
    isNot?: TestCatalogWhereInput | null
  }

  export type ReferenceRangeListRelationFilter = {
    every?: ReferenceRangeWhereInput
    some?: ReferenceRangeWhereInput
    none?: ReferenceRangeWhereInput
  }

  export type ReferenceRangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    loincCode?: SortOrder
    units?: SortOrder
    specimenTypeId?: SortOrder
    defaultInstrumentId?: SortOrder
    isPanel?: SortOrder
    parentPanelId?: SortOrder
  }

  export type TestCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    loincCode?: SortOrder
    units?: SortOrder
    specimenTypeId?: SortOrder
    defaultInstrumentId?: SortOrder
    isPanel?: SortOrder
    parentPanelId?: SortOrder
  }

  export type TestCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    loincCode?: SortOrder
    units?: SortOrder
    specimenTypeId?: SortOrder
    defaultInstrumentId?: SortOrder
    isPanel?: SortOrder
    parentPanelId?: SortOrder
  }

  export type TestCatalogScalarRelationFilter = {
    is?: TestCatalogWhereInput
    isNot?: TestCatalogWhereInput
  }

  export type ReferenceRangeCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    sex?: SortOrder
    ageMinYears?: SortOrder
    ageMaxYears?: SortOrder
    lowValue?: SortOrder
    highValue?: SortOrder
    notes?: SortOrder
  }

  export type ReferenceRangeAvgOrderByAggregateInput = {
    ageMinYears?: SortOrder
    ageMaxYears?: SortOrder
    lowValue?: SortOrder
    highValue?: SortOrder
  }

  export type ReferenceRangeMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    sex?: SortOrder
    ageMinYears?: SortOrder
    ageMaxYears?: SortOrder
    lowValue?: SortOrder
    highValue?: SortOrder
    notes?: SortOrder
  }

  export type ReferenceRangeMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    sex?: SortOrder
    ageMinYears?: SortOrder
    ageMaxYears?: SortOrder
    lowValue?: SortOrder
    highValue?: SortOrder
    notes?: SortOrder
  }

  export type ReferenceRangeSumOrderByAggregateInput = {
    ageMinYears?: SortOrder
    ageMaxYears?: SortOrder
    lowValue?: SortOrder
    highValue?: SortOrder
  }

  export type EnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type EnumLabOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusFilter<$PrismaModel> | $Enums.LabOrderStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type LabOrderCountOrderByAggregateInput = {
    id?: SortOrder
    accessionNo?: SortOrder
    patientId?: SortOrder
    orderingProviderId?: SortOrder
    invoiceId?: SortOrder
    preclinicId?: SortOrder
    specimenTypeId?: SortOrder
    collectionTime?: SortOrder
    collectedById?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    requestContextId?: SortOrder
  }

  export type LabOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    accessionNo?: SortOrder
    patientId?: SortOrder
    orderingProviderId?: SortOrder
    invoiceId?: SortOrder
    preclinicId?: SortOrder
    specimenTypeId?: SortOrder
    collectionTime?: SortOrder
    collectedById?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    requestContextId?: SortOrder
  }

  export type LabOrderMinOrderByAggregateInput = {
    id?: SortOrder
    accessionNo?: SortOrder
    patientId?: SortOrder
    orderingProviderId?: SortOrder
    invoiceId?: SortOrder
    preclinicId?: SortOrder
    specimenTypeId?: SortOrder
    collectionTime?: SortOrder
    collectedById?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    requestContextId?: SortOrder
  }

  export type EnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type EnumLabOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumLabOrderStatusFilter<$PrismaModel>
  }

  export type EnumLabOrderTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderTestStatus | EnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderTestStatusFilter<$PrismaModel> | $Enums.LabOrderTestStatus
  }

  export type EnumAbnormalFlagNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AbnormalFlag | EnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbnormalFlagNullableFilter<$PrismaModel> | $Enums.AbnormalFlag | null
  }

  export type EnumOutOfRangeFlagNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OutOfRangeFlag | EnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel> | $Enums.OutOfRangeFlag | null
  }

  export type LabOrderScalarRelationFilter = {
    is?: LabOrderWhereInput
    isNot?: LabOrderWhereInput
  }

  export type LabOrderTestCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    instrumentId?: SortOrder
    analyteCodeInstrument?: SortOrder
    resultValue?: SortOrder
    resultText?: SortOrder
    units?: SortOrder
    flagAbnormal?: SortOrder
    outOfRange?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    completedAt?: SortOrder
    resultNotes?: SortOrder
    requestContextId?: SortOrder
  }

  export type LabOrderTestAvgOrderByAggregateInput = {
    resultValue?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
  }

  export type LabOrderTestMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    instrumentId?: SortOrder
    analyteCodeInstrument?: SortOrder
    resultValue?: SortOrder
    resultText?: SortOrder
    units?: SortOrder
    flagAbnormal?: SortOrder
    outOfRange?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    completedAt?: SortOrder
    resultNotes?: SortOrder
    requestContextId?: SortOrder
  }

  export type LabOrderTestMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    instrumentId?: SortOrder
    analyteCodeInstrument?: SortOrder
    resultValue?: SortOrder
    resultText?: SortOrder
    units?: SortOrder
    flagAbnormal?: SortOrder
    outOfRange?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    completedAt?: SortOrder
    resultNotes?: SortOrder
    requestContextId?: SortOrder
  }

  export type LabOrderTestSumOrderByAggregateInput = {
    resultValue?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
  }

  export type EnumLabOrderTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderTestStatus | EnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabOrderTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabOrderTestStatusFilter<$PrismaModel>
    _max?: NestedEnumLabOrderTestStatusFilter<$PrismaModel>
  }

  export type EnumAbnormalFlagNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbnormalFlag | EnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbnormalFlagNullableWithAggregatesFilter<$PrismaModel> | $Enums.AbnormalFlag | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAbnormalFlagNullableFilter<$PrismaModel>
    _max?: NestedEnumAbnormalFlagNullableFilter<$PrismaModel>
  }

  export type EnumOutOfRangeFlagNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutOfRangeFlag | EnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOutOfRangeFlagNullableWithAggregatesFilter<$PrismaModel> | $Enums.OutOfRangeFlag | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel>
    _max?: NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel>
  }

  export type EnumProtocolKindNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProtocolKind | EnumProtocolKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProtocolKindNullableFilter<$PrismaModel> | $Enums.ProtocolKind | null
  }

  export type LabInstrumentScalarRelationFilter = {
    is?: LabInstrumentWhereInput
    isNot?: LabInstrumentWhereInput
  }

  export type LabOrderNullableScalarRelationFilter = {
    is?: LabOrderWhereInput | null
    isNot?: LabOrderWhereInput | null
  }

  export type LabDeviceMessageCountOrderByAggregateInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    orderId?: SortOrder
    receivedAt?: SortOrder
    protocol?: SortOrder
    rawContent?: SortOrder
    parsedOk?: SortOrder
  }

  export type LabDeviceMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    orderId?: SortOrder
    receivedAt?: SortOrder
    protocol?: SortOrder
    rawContent?: SortOrder
    parsedOk?: SortOrder
  }

  export type LabDeviceMessageMinOrderByAggregateInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    orderId?: SortOrder
    receivedAt?: SortOrder
    protocol?: SortOrder
    rawContent?: SortOrder
    parsedOk?: SortOrder
  }

  export type EnumProtocolKindNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProtocolKind | EnumProtocolKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProtocolKindNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProtocolKind | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProtocolKindNullableFilter<$PrismaModel>
    _max?: NestedEnumProtocolKindNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    requestContextId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    requestContextId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AuthSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PreclinicCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<PreclinicCreateWithoutRecordedByInput, PreclinicUncheckedCreateWithoutRecordedByInput> | PreclinicCreateWithoutRecordedByInput[] | PreclinicUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRecordedByInput | PreclinicCreateOrConnectWithoutRecordedByInput[]
    createMany?: PreclinicCreateManyRecordedByInputEnvelope
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
  }

  export type ProblemCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<ProblemCreateWithoutRecordedByInput, ProblemUncheckedCreateWithoutRecordedByInput> | ProblemCreateWithoutRecordedByInput[] | ProblemUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutRecordedByInput | ProblemCreateOrConnectWithoutRecordedByInput[]
    createMany?: ProblemCreateManyRecordedByInputEnvelope
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
  }

  export type AllergyCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<AllergyCreateWithoutRecordedByInput, AllergyUncheckedCreateWithoutRecordedByInput> | AllergyCreateWithoutRecordedByInput[] | AllergyUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutRecordedByInput | AllergyCreateOrConnectWithoutRecordedByInput[]
    createMany?: AllergyCreateManyRecordedByInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutPrescribedByInput = {
    create?: XOR<MedicationCreateWithoutPrescribedByInput, MedicationUncheckedCreateWithoutPrescribedByInput> | MedicationCreateWithoutPrescribedByInput[] | MedicationUncheckedCreateWithoutPrescribedByInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescribedByInput | MedicationCreateOrConnectWithoutPrescribedByInput[]
    createMany?: MedicationCreateManyPrescribedByInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCashierInput = {
    create?: XOR<InvoiceCreateWithoutCashierInput, InvoiceUncheckedCreateWithoutCashierInput> | InvoiceCreateWithoutCashierInput[] | InvoiceUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCashierInput | InvoiceCreateOrConnectWithoutCashierInput[]
    createMany?: InvoiceCreateManyCashierInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashSessionCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<CashSessionCreateWithoutOpenedByInput, CashSessionUncheckedCreateWithoutOpenedByInput> | CashSessionCreateWithoutOpenedByInput[] | CashSessionUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutOpenedByInput | CashSessionCreateOrConnectWithoutOpenedByInput[]
    createMany?: CashSessionCreateManyOpenedByInputEnvelope
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
  }

  export type CashSessionCreateNestedManyWithoutClosedByInput = {
    create?: XOR<CashSessionCreateWithoutClosedByInput, CashSessionUncheckedCreateWithoutClosedByInput> | CashSessionCreateWithoutClosedByInput[] | CashSessionUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutClosedByInput | CashSessionCreateOrConnectWithoutClosedByInput[]
    createMany?: CashSessionCreateManyClosedByInputEnvelope
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
  }

  export type CashMovementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CashMovementCreateWithoutCreatedByInput, CashMovementUncheckedCreateWithoutCreatedByInput> | CashMovementCreateWithoutCreatedByInput[] | CashMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutCreatedByInput | CashMovementCreateOrConnectWithoutCreatedByInput[]
    createMany?: CashMovementCreateManyCreatedByInputEnvelope
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutOrderingProviderInput = {
    create?: XOR<LabOrderCreateWithoutOrderingProviderInput, LabOrderUncheckedCreateWithoutOrderingProviderInput> | LabOrderCreateWithoutOrderingProviderInput[] | LabOrderUncheckedCreateWithoutOrderingProviderInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutOrderingProviderInput | LabOrderCreateOrConnectWithoutOrderingProviderInput[]
    createMany?: LabOrderCreateManyOrderingProviderInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutCollectedByInput = {
    create?: XOR<LabOrderCreateWithoutCollectedByInput, LabOrderUncheckedCreateWithoutCollectedByInput> | LabOrderCreateWithoutCollectedByInput[] | LabOrderUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutCollectedByInput | LabOrderCreateOrConnectWithoutCollectedByInput[]
    createMany?: LabOrderCreateManyCollectedByInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutActorInput = {
    create?: XOR<ActivityLogCreateWithoutActorInput, ActivityLogUncheckedCreateWithoutActorInput> | ActivityLogCreateWithoutActorInput[] | ActivityLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActorInput | ActivityLogCreateOrConnectWithoutActorInput[]
    createMany?: ActivityLogCreateManyActorInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AuthSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PreclinicUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<PreclinicCreateWithoutRecordedByInput, PreclinicUncheckedCreateWithoutRecordedByInput> | PreclinicCreateWithoutRecordedByInput[] | PreclinicUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRecordedByInput | PreclinicCreateOrConnectWithoutRecordedByInput[]
    createMany?: PreclinicCreateManyRecordedByInputEnvelope
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
  }

  export type ProblemUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<ProblemCreateWithoutRecordedByInput, ProblemUncheckedCreateWithoutRecordedByInput> | ProblemCreateWithoutRecordedByInput[] | ProblemUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutRecordedByInput | ProblemCreateOrConnectWithoutRecordedByInput[]
    createMany?: ProblemCreateManyRecordedByInputEnvelope
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
  }

  export type AllergyUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<AllergyCreateWithoutRecordedByInput, AllergyUncheckedCreateWithoutRecordedByInput> | AllergyCreateWithoutRecordedByInput[] | AllergyUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutRecordedByInput | AllergyCreateOrConnectWithoutRecordedByInput[]
    createMany?: AllergyCreateManyRecordedByInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutPrescribedByInput = {
    create?: XOR<MedicationCreateWithoutPrescribedByInput, MedicationUncheckedCreateWithoutPrescribedByInput> | MedicationCreateWithoutPrescribedByInput[] | MedicationUncheckedCreateWithoutPrescribedByInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescribedByInput | MedicationCreateOrConnectWithoutPrescribedByInput[]
    createMany?: MedicationCreateManyPrescribedByInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCashierInput = {
    create?: XOR<InvoiceCreateWithoutCashierInput, InvoiceUncheckedCreateWithoutCashierInput> | InvoiceCreateWithoutCashierInput[] | InvoiceUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCashierInput | InvoiceCreateOrConnectWithoutCashierInput[]
    createMany?: InvoiceCreateManyCashierInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashSessionUncheckedCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<CashSessionCreateWithoutOpenedByInput, CashSessionUncheckedCreateWithoutOpenedByInput> | CashSessionCreateWithoutOpenedByInput[] | CashSessionUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutOpenedByInput | CashSessionCreateOrConnectWithoutOpenedByInput[]
    createMany?: CashSessionCreateManyOpenedByInputEnvelope
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
  }

  export type CashSessionUncheckedCreateNestedManyWithoutClosedByInput = {
    create?: XOR<CashSessionCreateWithoutClosedByInput, CashSessionUncheckedCreateWithoutClosedByInput> | CashSessionCreateWithoutClosedByInput[] | CashSessionUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutClosedByInput | CashSessionCreateOrConnectWithoutClosedByInput[]
    createMany?: CashSessionCreateManyClosedByInputEnvelope
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
  }

  export type CashMovementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CashMovementCreateWithoutCreatedByInput, CashMovementUncheckedCreateWithoutCreatedByInput> | CashMovementCreateWithoutCreatedByInput[] | CashMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutCreatedByInput | CashMovementCreateOrConnectWithoutCreatedByInput[]
    createMany?: CashMovementCreateManyCreatedByInputEnvelope
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput = {
    create?: XOR<LabOrderCreateWithoutOrderingProviderInput, LabOrderUncheckedCreateWithoutOrderingProviderInput> | LabOrderCreateWithoutOrderingProviderInput[] | LabOrderUncheckedCreateWithoutOrderingProviderInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutOrderingProviderInput | LabOrderCreateOrConnectWithoutOrderingProviderInput[]
    createMany?: LabOrderCreateManyOrderingProviderInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutCollectedByInput = {
    create?: XOR<LabOrderCreateWithoutCollectedByInput, LabOrderUncheckedCreateWithoutCollectedByInput> | LabOrderCreateWithoutCollectedByInput[] | LabOrderUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutCollectedByInput | LabOrderCreateOrConnectWithoutCollectedByInput[]
    createMany?: LabOrderCreateManyCollectedByInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<ActivityLogCreateWithoutActorInput, ActivityLogUncheckedCreateWithoutActorInput> | ActivityLogCreateWithoutActorInput[] | ActivityLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActorInput | ActivityLogCreateOrConnectWithoutActorInput[]
    createMany?: ActivityLogCreateManyActorInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AuthSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutCreatedByInput | PatientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutCreatedByInput | PatientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutCreatedByInput | PatientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type PreclinicUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<PreclinicCreateWithoutRecordedByInput, PreclinicUncheckedCreateWithoutRecordedByInput> | PreclinicCreateWithoutRecordedByInput[] | PreclinicUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRecordedByInput | PreclinicCreateOrConnectWithoutRecordedByInput[]
    upsert?: PreclinicUpsertWithWhereUniqueWithoutRecordedByInput | PreclinicUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: PreclinicCreateManyRecordedByInputEnvelope
    set?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    disconnect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    delete?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    update?: PreclinicUpdateWithWhereUniqueWithoutRecordedByInput | PreclinicUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: PreclinicUpdateManyWithWhereWithoutRecordedByInput | PreclinicUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
  }

  export type ProblemUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<ProblemCreateWithoutRecordedByInput, ProblemUncheckedCreateWithoutRecordedByInput> | ProblemCreateWithoutRecordedByInput[] | ProblemUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutRecordedByInput | ProblemCreateOrConnectWithoutRecordedByInput[]
    upsert?: ProblemUpsertWithWhereUniqueWithoutRecordedByInput | ProblemUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: ProblemCreateManyRecordedByInputEnvelope
    set?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    disconnect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    delete?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    update?: ProblemUpdateWithWhereUniqueWithoutRecordedByInput | ProblemUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: ProblemUpdateManyWithWhereWithoutRecordedByInput | ProblemUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
  }

  export type AllergyUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<AllergyCreateWithoutRecordedByInput, AllergyUncheckedCreateWithoutRecordedByInput> | AllergyCreateWithoutRecordedByInput[] | AllergyUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutRecordedByInput | AllergyCreateOrConnectWithoutRecordedByInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutRecordedByInput | AllergyUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: AllergyCreateManyRecordedByInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutRecordedByInput | AllergyUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutRecordedByInput | AllergyUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutPrescribedByNestedInput = {
    create?: XOR<MedicationCreateWithoutPrescribedByInput, MedicationUncheckedCreateWithoutPrescribedByInput> | MedicationCreateWithoutPrescribedByInput[] | MedicationUncheckedCreateWithoutPrescribedByInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescribedByInput | MedicationCreateOrConnectWithoutPrescribedByInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPrescribedByInput | MedicationUpsertWithWhereUniqueWithoutPrescribedByInput[]
    createMany?: MedicationCreateManyPrescribedByInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPrescribedByInput | MedicationUpdateWithWhereUniqueWithoutPrescribedByInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPrescribedByInput | MedicationUpdateManyWithWhereWithoutPrescribedByInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCashierNestedInput = {
    create?: XOR<InvoiceCreateWithoutCashierInput, InvoiceUncheckedCreateWithoutCashierInput> | InvoiceCreateWithoutCashierInput[] | InvoiceUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCashierInput | InvoiceCreateOrConnectWithoutCashierInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCashierInput | InvoiceUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: InvoiceCreateManyCashierInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCashierInput | InvoiceUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCashierInput | InvoiceUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatedByInput | PaymentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatedByInput | PaymentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatedByInput | PaymentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashSessionUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<CashSessionCreateWithoutOpenedByInput, CashSessionUncheckedCreateWithoutOpenedByInput> | CashSessionCreateWithoutOpenedByInput[] | CashSessionUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutOpenedByInput | CashSessionCreateOrConnectWithoutOpenedByInput[]
    upsert?: CashSessionUpsertWithWhereUniqueWithoutOpenedByInput | CashSessionUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: CashSessionCreateManyOpenedByInputEnvelope
    set?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    disconnect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    delete?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    update?: CashSessionUpdateWithWhereUniqueWithoutOpenedByInput | CashSessionUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: CashSessionUpdateManyWithWhereWithoutOpenedByInput | CashSessionUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
  }

  export type CashSessionUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<CashSessionCreateWithoutClosedByInput, CashSessionUncheckedCreateWithoutClosedByInput> | CashSessionCreateWithoutClosedByInput[] | CashSessionUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutClosedByInput | CashSessionCreateOrConnectWithoutClosedByInput[]
    upsert?: CashSessionUpsertWithWhereUniqueWithoutClosedByInput | CashSessionUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: CashSessionCreateManyClosedByInputEnvelope
    set?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    disconnect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    delete?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    update?: CashSessionUpdateWithWhereUniqueWithoutClosedByInput | CashSessionUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: CashSessionUpdateManyWithWhereWithoutClosedByInput | CashSessionUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
  }

  export type CashMovementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CashMovementCreateWithoutCreatedByInput, CashMovementUncheckedCreateWithoutCreatedByInput> | CashMovementCreateWithoutCreatedByInput[] | CashMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutCreatedByInput | CashMovementCreateOrConnectWithoutCreatedByInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutCreatedByInput | CashMovementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CashMovementCreateManyCreatedByInputEnvelope
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutCreatedByInput | CashMovementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutCreatedByInput | CashMovementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutOrderingProviderNestedInput = {
    create?: XOR<LabOrderCreateWithoutOrderingProviderInput, LabOrderUncheckedCreateWithoutOrderingProviderInput> | LabOrderCreateWithoutOrderingProviderInput[] | LabOrderUncheckedCreateWithoutOrderingProviderInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutOrderingProviderInput | LabOrderCreateOrConnectWithoutOrderingProviderInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutOrderingProviderInput | LabOrderUpsertWithWhereUniqueWithoutOrderingProviderInput[]
    createMany?: LabOrderCreateManyOrderingProviderInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutOrderingProviderInput | LabOrderUpdateWithWhereUniqueWithoutOrderingProviderInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutOrderingProviderInput | LabOrderUpdateManyWithWhereWithoutOrderingProviderInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutCollectedByNestedInput = {
    create?: XOR<LabOrderCreateWithoutCollectedByInput, LabOrderUncheckedCreateWithoutCollectedByInput> | LabOrderCreateWithoutCollectedByInput[] | LabOrderUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutCollectedByInput | LabOrderCreateOrConnectWithoutCollectedByInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutCollectedByInput | LabOrderUpsertWithWhereUniqueWithoutCollectedByInput[]
    createMany?: LabOrderCreateManyCollectedByInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutCollectedByInput | LabOrderUpdateWithWhereUniqueWithoutCollectedByInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutCollectedByInput | LabOrderUpdateManyWithWhereWithoutCollectedByInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<ActivityLogCreateWithoutActorInput, ActivityLogUncheckedCreateWithoutActorInput> | ActivityLogCreateWithoutActorInput[] | ActivityLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActorInput | ActivityLogCreateOrConnectWithoutActorInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutActorInput | ActivityLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: ActivityLogCreateManyActorInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutActorInput | ActivityLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutActorInput | ActivityLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput> | PatientCreateWithoutCreatedByInput[] | PatientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutCreatedByInput | PatientCreateOrConnectWithoutCreatedByInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutCreatedByInput | PatientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PatientCreateManyCreatedByInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutCreatedByInput | PatientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutCreatedByInput | PatientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<PreclinicCreateWithoutRecordedByInput, PreclinicUncheckedCreateWithoutRecordedByInput> | PreclinicCreateWithoutRecordedByInput[] | PreclinicUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRecordedByInput | PreclinicCreateOrConnectWithoutRecordedByInput[]
    upsert?: PreclinicUpsertWithWhereUniqueWithoutRecordedByInput | PreclinicUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: PreclinicCreateManyRecordedByInputEnvelope
    set?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    disconnect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    delete?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    update?: PreclinicUpdateWithWhereUniqueWithoutRecordedByInput | PreclinicUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: PreclinicUpdateManyWithWhereWithoutRecordedByInput | PreclinicUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
  }

  export type ProblemUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<ProblemCreateWithoutRecordedByInput, ProblemUncheckedCreateWithoutRecordedByInput> | ProblemCreateWithoutRecordedByInput[] | ProblemUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutRecordedByInput | ProblemCreateOrConnectWithoutRecordedByInput[]
    upsert?: ProblemUpsertWithWhereUniqueWithoutRecordedByInput | ProblemUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: ProblemCreateManyRecordedByInputEnvelope
    set?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    disconnect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    delete?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    update?: ProblemUpdateWithWhereUniqueWithoutRecordedByInput | ProblemUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: ProblemUpdateManyWithWhereWithoutRecordedByInput | ProblemUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
  }

  export type AllergyUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<AllergyCreateWithoutRecordedByInput, AllergyUncheckedCreateWithoutRecordedByInput> | AllergyCreateWithoutRecordedByInput[] | AllergyUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutRecordedByInput | AllergyCreateOrConnectWithoutRecordedByInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutRecordedByInput | AllergyUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: AllergyCreateManyRecordedByInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutRecordedByInput | AllergyUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutRecordedByInput | AllergyUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput = {
    create?: XOR<MedicationCreateWithoutPrescribedByInput, MedicationUncheckedCreateWithoutPrescribedByInput> | MedicationCreateWithoutPrescribedByInput[] | MedicationUncheckedCreateWithoutPrescribedByInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescribedByInput | MedicationCreateOrConnectWithoutPrescribedByInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPrescribedByInput | MedicationUpsertWithWhereUniqueWithoutPrescribedByInput[]
    createMany?: MedicationCreateManyPrescribedByInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPrescribedByInput | MedicationUpdateWithWhereUniqueWithoutPrescribedByInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPrescribedByInput | MedicationUpdateManyWithWhereWithoutPrescribedByInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCashierNestedInput = {
    create?: XOR<InvoiceCreateWithoutCashierInput, InvoiceUncheckedCreateWithoutCashierInput> | InvoiceCreateWithoutCashierInput[] | InvoiceUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCashierInput | InvoiceCreateOrConnectWithoutCashierInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCashierInput | InvoiceUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: InvoiceCreateManyCashierInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCashierInput | InvoiceUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCashierInput | InvoiceUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatedByInput | PaymentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatedByInput | PaymentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatedByInput | PaymentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<CashSessionCreateWithoutOpenedByInput, CashSessionUncheckedCreateWithoutOpenedByInput> | CashSessionCreateWithoutOpenedByInput[] | CashSessionUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutOpenedByInput | CashSessionCreateOrConnectWithoutOpenedByInput[]
    upsert?: CashSessionUpsertWithWhereUniqueWithoutOpenedByInput | CashSessionUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: CashSessionCreateManyOpenedByInputEnvelope
    set?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    disconnect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    delete?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    update?: CashSessionUpdateWithWhereUniqueWithoutOpenedByInput | CashSessionUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: CashSessionUpdateManyWithWhereWithoutOpenedByInput | CashSessionUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
  }

  export type CashSessionUncheckedUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<CashSessionCreateWithoutClosedByInput, CashSessionUncheckedCreateWithoutClosedByInput> | CashSessionCreateWithoutClosedByInput[] | CashSessionUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutClosedByInput | CashSessionCreateOrConnectWithoutClosedByInput[]
    upsert?: CashSessionUpsertWithWhereUniqueWithoutClosedByInput | CashSessionUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: CashSessionCreateManyClosedByInputEnvelope
    set?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    disconnect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    delete?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    update?: CashSessionUpdateWithWhereUniqueWithoutClosedByInput | CashSessionUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: CashSessionUpdateManyWithWhereWithoutClosedByInput | CashSessionUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
  }

  export type CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CashMovementCreateWithoutCreatedByInput, CashMovementUncheckedCreateWithoutCreatedByInput> | CashMovementCreateWithoutCreatedByInput[] | CashMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutCreatedByInput | CashMovementCreateOrConnectWithoutCreatedByInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutCreatedByInput | CashMovementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CashMovementCreateManyCreatedByInputEnvelope
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutCreatedByInput | CashMovementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutCreatedByInput | CashMovementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput = {
    create?: XOR<LabOrderCreateWithoutOrderingProviderInput, LabOrderUncheckedCreateWithoutOrderingProviderInput> | LabOrderCreateWithoutOrderingProviderInput[] | LabOrderUncheckedCreateWithoutOrderingProviderInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutOrderingProviderInput | LabOrderCreateOrConnectWithoutOrderingProviderInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutOrderingProviderInput | LabOrderUpsertWithWhereUniqueWithoutOrderingProviderInput[]
    createMany?: LabOrderCreateManyOrderingProviderInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutOrderingProviderInput | LabOrderUpdateWithWhereUniqueWithoutOrderingProviderInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutOrderingProviderInput | LabOrderUpdateManyWithWhereWithoutOrderingProviderInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput = {
    create?: XOR<LabOrderCreateWithoutCollectedByInput, LabOrderUncheckedCreateWithoutCollectedByInput> | LabOrderCreateWithoutCollectedByInput[] | LabOrderUncheckedCreateWithoutCollectedByInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutCollectedByInput | LabOrderCreateOrConnectWithoutCollectedByInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutCollectedByInput | LabOrderUpsertWithWhereUniqueWithoutCollectedByInput[]
    createMany?: LabOrderCreateManyCollectedByInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutCollectedByInput | LabOrderUpdateWithWhereUniqueWithoutCollectedByInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutCollectedByInput | LabOrderUpdateManyWithWhereWithoutCollectedByInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<ActivityLogCreateWithoutActorInput, ActivityLogUncheckedCreateWithoutActorInput> | ActivityLogCreateWithoutActorInput[] | ActivityLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActorInput | ActivityLogCreateOrConnectWithoutActorInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutActorInput | ActivityLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: ActivityLogCreateManyActorInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutActorInput | ActivityLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutActorInput | ActivityLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type CashRegisterCreateNestedManyWithoutLocationInput = {
    create?: XOR<CashRegisterCreateWithoutLocationInput, CashRegisterUncheckedCreateWithoutLocationInput> | CashRegisterCreateWithoutLocationInput[] | CashRegisterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutLocationInput | CashRegisterCreateOrConnectWithoutLocationInput[]
    createMany?: CashRegisterCreateManyLocationInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type PosTerminalCreateNestedManyWithoutLocationInput = {
    create?: XOR<PosTerminalCreateWithoutLocationInput, PosTerminalUncheckedCreateWithoutLocationInput> | PosTerminalCreateWithoutLocationInput[] | PosTerminalUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PosTerminalCreateOrConnectWithoutLocationInput | PosTerminalCreateOrConnectWithoutLocationInput[]
    createMany?: PosTerminalCreateManyLocationInputEnvelope
    connect?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
  }

  export type WorkstationCreateNestedManyWithoutLocationInput = {
    create?: XOR<WorkstationCreateWithoutLocationInput, WorkstationUncheckedCreateWithoutLocationInput> | WorkstationCreateWithoutLocationInput[] | WorkstationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkstationCreateOrConnectWithoutLocationInput | WorkstationCreateOrConnectWithoutLocationInput[]
    createMany?: WorkstationCreateManyLocationInputEnvelope
    connect?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
  }

  export type ProductStockCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProductStockCreateWithoutLocationInput, ProductStockUncheckedCreateWithoutLocationInput> | ProductStockCreateWithoutLocationInput[] | ProductStockUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutLocationInput | ProductStockCreateOrConnectWithoutLocationInput[]
    createMany?: ProductStockCreateManyLocationInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutLocationInput = {
    create?: XOR<StockMovementCreateWithoutLocationInput, StockMovementUncheckedCreateWithoutLocationInput> | StockMovementCreateWithoutLocationInput[] | StockMovementUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutLocationInput | StockMovementCreateOrConnectWithoutLocationInput[]
    createMany?: StockMovementCreateManyLocationInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type LabInstrumentCreateNestedManyWithoutLocationInput = {
    create?: XOR<LabInstrumentCreateWithoutLocationInput, LabInstrumentUncheckedCreateWithoutLocationInput> | LabInstrumentCreateWithoutLocationInput[] | LabInstrumentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutLocationInput | LabInstrumentCreateOrConnectWithoutLocationInput[]
    createMany?: LabInstrumentCreateManyLocationInputEnvelope
    connect?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutLocationInput = {
    create?: XOR<InvoiceCreateWithoutLocationInput, InvoiceUncheckedCreateWithoutLocationInput> | InvoiceCreateWithoutLocationInput[] | InvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLocationInput | InvoiceCreateOrConnectWithoutLocationInput[]
    createMany?: InvoiceCreateManyLocationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CashRegisterUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<CashRegisterCreateWithoutLocationInput, CashRegisterUncheckedCreateWithoutLocationInput> | CashRegisterCreateWithoutLocationInput[] | CashRegisterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutLocationInput | CashRegisterCreateOrConnectWithoutLocationInput[]
    createMany?: CashRegisterCreateManyLocationInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type PosTerminalUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PosTerminalCreateWithoutLocationInput, PosTerminalUncheckedCreateWithoutLocationInput> | PosTerminalCreateWithoutLocationInput[] | PosTerminalUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PosTerminalCreateOrConnectWithoutLocationInput | PosTerminalCreateOrConnectWithoutLocationInput[]
    createMany?: PosTerminalCreateManyLocationInputEnvelope
    connect?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
  }

  export type WorkstationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<WorkstationCreateWithoutLocationInput, WorkstationUncheckedCreateWithoutLocationInput> | WorkstationCreateWithoutLocationInput[] | WorkstationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkstationCreateOrConnectWithoutLocationInput | WorkstationCreateOrConnectWithoutLocationInput[]
    createMany?: WorkstationCreateManyLocationInputEnvelope
    connect?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
  }

  export type ProductStockUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProductStockCreateWithoutLocationInput, ProductStockUncheckedCreateWithoutLocationInput> | ProductStockCreateWithoutLocationInput[] | ProductStockUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutLocationInput | ProductStockCreateOrConnectWithoutLocationInput[]
    createMany?: ProductStockCreateManyLocationInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<StockMovementCreateWithoutLocationInput, StockMovementUncheckedCreateWithoutLocationInput> | StockMovementCreateWithoutLocationInput[] | StockMovementUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutLocationInput | StockMovementCreateOrConnectWithoutLocationInput[]
    createMany?: StockMovementCreateManyLocationInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type LabInstrumentUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<LabInstrumentCreateWithoutLocationInput, LabInstrumentUncheckedCreateWithoutLocationInput> | LabInstrumentCreateWithoutLocationInput[] | LabInstrumentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutLocationInput | LabInstrumentCreateOrConnectWithoutLocationInput[]
    createMany?: LabInstrumentCreateManyLocationInputEnvelope
    connect?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<InvoiceCreateWithoutLocationInput, InvoiceUncheckedCreateWithoutLocationInput> | InvoiceCreateWithoutLocationInput[] | InvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLocationInput | InvoiceCreateOrConnectWithoutLocationInput[]
    createMany?: InvoiceCreateManyLocationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CashRegisterUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CashRegisterCreateWithoutLocationInput, CashRegisterUncheckedCreateWithoutLocationInput> | CashRegisterCreateWithoutLocationInput[] | CashRegisterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutLocationInput | CashRegisterCreateOrConnectWithoutLocationInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutLocationInput | CashRegisterUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CashRegisterCreateManyLocationInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutLocationInput | CashRegisterUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutLocationInput | CashRegisterUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type PosTerminalUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PosTerminalCreateWithoutLocationInput, PosTerminalUncheckedCreateWithoutLocationInput> | PosTerminalCreateWithoutLocationInput[] | PosTerminalUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PosTerminalCreateOrConnectWithoutLocationInput | PosTerminalCreateOrConnectWithoutLocationInput[]
    upsert?: PosTerminalUpsertWithWhereUniqueWithoutLocationInput | PosTerminalUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PosTerminalCreateManyLocationInputEnvelope
    set?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    disconnect?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    delete?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    connect?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    update?: PosTerminalUpdateWithWhereUniqueWithoutLocationInput | PosTerminalUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PosTerminalUpdateManyWithWhereWithoutLocationInput | PosTerminalUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PosTerminalScalarWhereInput | PosTerminalScalarWhereInput[]
  }

  export type WorkstationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<WorkstationCreateWithoutLocationInput, WorkstationUncheckedCreateWithoutLocationInput> | WorkstationCreateWithoutLocationInput[] | WorkstationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkstationCreateOrConnectWithoutLocationInput | WorkstationCreateOrConnectWithoutLocationInput[]
    upsert?: WorkstationUpsertWithWhereUniqueWithoutLocationInput | WorkstationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: WorkstationCreateManyLocationInputEnvelope
    set?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    disconnect?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    delete?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    connect?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    update?: WorkstationUpdateWithWhereUniqueWithoutLocationInput | WorkstationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: WorkstationUpdateManyWithWhereWithoutLocationInput | WorkstationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: WorkstationScalarWhereInput | WorkstationScalarWhereInput[]
  }

  export type ProductStockUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProductStockCreateWithoutLocationInput, ProductStockUncheckedCreateWithoutLocationInput> | ProductStockCreateWithoutLocationInput[] | ProductStockUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutLocationInput | ProductStockCreateOrConnectWithoutLocationInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutLocationInput | ProductStockUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProductStockCreateManyLocationInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutLocationInput | ProductStockUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutLocationInput | ProductStockUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StockMovementCreateWithoutLocationInput, StockMovementUncheckedCreateWithoutLocationInput> | StockMovementCreateWithoutLocationInput[] | StockMovementUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutLocationInput | StockMovementCreateOrConnectWithoutLocationInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutLocationInput | StockMovementUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StockMovementCreateManyLocationInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutLocationInput | StockMovementUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutLocationInput | StockMovementUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type LabInstrumentUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LabInstrumentCreateWithoutLocationInput, LabInstrumentUncheckedCreateWithoutLocationInput> | LabInstrumentCreateWithoutLocationInput[] | LabInstrumentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutLocationInput | LabInstrumentCreateOrConnectWithoutLocationInput[]
    upsert?: LabInstrumentUpsertWithWhereUniqueWithoutLocationInput | LabInstrumentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LabInstrumentCreateManyLocationInputEnvelope
    set?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    disconnect?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    delete?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    connect?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    update?: LabInstrumentUpdateWithWhereUniqueWithoutLocationInput | LabInstrumentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LabInstrumentUpdateManyWithWhereWithoutLocationInput | LabInstrumentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LabInstrumentScalarWhereInput | LabInstrumentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InvoiceCreateWithoutLocationInput, InvoiceUncheckedCreateWithoutLocationInput> | InvoiceCreateWithoutLocationInput[] | InvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLocationInput | InvoiceCreateOrConnectWithoutLocationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLocationInput | InvoiceUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InvoiceCreateManyLocationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLocationInput | InvoiceUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLocationInput | InvoiceUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CashRegisterUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CashRegisterCreateWithoutLocationInput, CashRegisterUncheckedCreateWithoutLocationInput> | CashRegisterCreateWithoutLocationInput[] | CashRegisterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutLocationInput | CashRegisterCreateOrConnectWithoutLocationInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutLocationInput | CashRegisterUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CashRegisterCreateManyLocationInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutLocationInput | CashRegisterUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutLocationInput | CashRegisterUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type PosTerminalUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PosTerminalCreateWithoutLocationInput, PosTerminalUncheckedCreateWithoutLocationInput> | PosTerminalCreateWithoutLocationInput[] | PosTerminalUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PosTerminalCreateOrConnectWithoutLocationInput | PosTerminalCreateOrConnectWithoutLocationInput[]
    upsert?: PosTerminalUpsertWithWhereUniqueWithoutLocationInput | PosTerminalUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PosTerminalCreateManyLocationInputEnvelope
    set?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    disconnect?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    delete?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    connect?: PosTerminalWhereUniqueInput | PosTerminalWhereUniqueInput[]
    update?: PosTerminalUpdateWithWhereUniqueWithoutLocationInput | PosTerminalUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PosTerminalUpdateManyWithWhereWithoutLocationInput | PosTerminalUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PosTerminalScalarWhereInput | PosTerminalScalarWhereInput[]
  }

  export type WorkstationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<WorkstationCreateWithoutLocationInput, WorkstationUncheckedCreateWithoutLocationInput> | WorkstationCreateWithoutLocationInput[] | WorkstationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkstationCreateOrConnectWithoutLocationInput | WorkstationCreateOrConnectWithoutLocationInput[]
    upsert?: WorkstationUpsertWithWhereUniqueWithoutLocationInput | WorkstationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: WorkstationCreateManyLocationInputEnvelope
    set?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    disconnect?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    delete?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    connect?: WorkstationWhereUniqueInput | WorkstationWhereUniqueInput[]
    update?: WorkstationUpdateWithWhereUniqueWithoutLocationInput | WorkstationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: WorkstationUpdateManyWithWhereWithoutLocationInput | WorkstationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: WorkstationScalarWhereInput | WorkstationScalarWhereInput[]
  }

  export type ProductStockUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProductStockCreateWithoutLocationInput, ProductStockUncheckedCreateWithoutLocationInput> | ProductStockCreateWithoutLocationInput[] | ProductStockUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutLocationInput | ProductStockCreateOrConnectWithoutLocationInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutLocationInput | ProductStockUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProductStockCreateManyLocationInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutLocationInput | ProductStockUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutLocationInput | ProductStockUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StockMovementCreateWithoutLocationInput, StockMovementUncheckedCreateWithoutLocationInput> | StockMovementCreateWithoutLocationInput[] | StockMovementUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutLocationInput | StockMovementCreateOrConnectWithoutLocationInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutLocationInput | StockMovementUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StockMovementCreateManyLocationInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutLocationInput | StockMovementUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutLocationInput | StockMovementUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LabInstrumentCreateWithoutLocationInput, LabInstrumentUncheckedCreateWithoutLocationInput> | LabInstrumentCreateWithoutLocationInput[] | LabInstrumentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutLocationInput | LabInstrumentCreateOrConnectWithoutLocationInput[]
    upsert?: LabInstrumentUpsertWithWhereUniqueWithoutLocationInput | LabInstrumentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LabInstrumentCreateManyLocationInputEnvelope
    set?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    disconnect?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    delete?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    connect?: LabInstrumentWhereUniqueInput | LabInstrumentWhereUniqueInput[]
    update?: LabInstrumentUpdateWithWhereUniqueWithoutLocationInput | LabInstrumentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LabInstrumentUpdateManyWithWhereWithoutLocationInput | LabInstrumentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LabInstrumentScalarWhereInput | LabInstrumentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InvoiceCreateWithoutLocationInput, InvoiceUncheckedCreateWithoutLocationInput> | InvoiceCreateWithoutLocationInput[] | InvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLocationInput | InvoiceCreateOrConnectWithoutLocationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLocationInput | InvoiceUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InvoiceCreateManyLocationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLocationInput | InvoiceUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLocationInput | InvoiceUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutRegistersInput = {
    create?: XOR<LocationCreateWithoutRegistersInput, LocationUncheckedCreateWithoutRegistersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRegistersInput
    connect?: LocationWhereUniqueInput
  }

  export type CashSessionCreateNestedManyWithoutRegisterInput = {
    create?: XOR<CashSessionCreateWithoutRegisterInput, CashSessionUncheckedCreateWithoutRegisterInput> | CashSessionCreateWithoutRegisterInput[] | CashSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutRegisterInput | CashSessionCreateOrConnectWithoutRegisterInput[]
    createMany?: CashSessionCreateManyRegisterInputEnvelope
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutRegisterInput = {
    create?: XOR<InvoiceCreateWithoutRegisterInput, InvoiceUncheckedCreateWithoutRegisterInput> | InvoiceCreateWithoutRegisterInput[] | InvoiceUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRegisterInput | InvoiceCreateOrConnectWithoutRegisterInput[]
    createMany?: InvoiceCreateManyRegisterInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CashSessionUncheckedCreateNestedManyWithoutRegisterInput = {
    create?: XOR<CashSessionCreateWithoutRegisterInput, CashSessionUncheckedCreateWithoutRegisterInput> | CashSessionCreateWithoutRegisterInput[] | CashSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutRegisterInput | CashSessionCreateOrConnectWithoutRegisterInput[]
    createMany?: CashSessionCreateManyRegisterInputEnvelope
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutRegisterInput = {
    create?: XOR<InvoiceCreateWithoutRegisterInput, InvoiceUncheckedCreateWithoutRegisterInput> | InvoiceCreateWithoutRegisterInput[] | InvoiceUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRegisterInput | InvoiceCreateOrConnectWithoutRegisterInput[]
    createMany?: InvoiceCreateManyRegisterInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutRegistersNestedInput = {
    create?: XOR<LocationCreateWithoutRegistersInput, LocationUncheckedCreateWithoutRegistersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRegistersInput
    upsert?: LocationUpsertWithoutRegistersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRegistersInput, LocationUpdateWithoutRegistersInput>, LocationUncheckedUpdateWithoutRegistersInput>
  }

  export type CashSessionUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<CashSessionCreateWithoutRegisterInput, CashSessionUncheckedCreateWithoutRegisterInput> | CashSessionCreateWithoutRegisterInput[] | CashSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutRegisterInput | CashSessionCreateOrConnectWithoutRegisterInput[]
    upsert?: CashSessionUpsertWithWhereUniqueWithoutRegisterInput | CashSessionUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: CashSessionCreateManyRegisterInputEnvelope
    set?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    disconnect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    delete?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    update?: CashSessionUpdateWithWhereUniqueWithoutRegisterInput | CashSessionUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: CashSessionUpdateManyWithWhereWithoutRegisterInput | CashSessionUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<InvoiceCreateWithoutRegisterInput, InvoiceUncheckedCreateWithoutRegisterInput> | InvoiceCreateWithoutRegisterInput[] | InvoiceUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRegisterInput | InvoiceCreateOrConnectWithoutRegisterInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRegisterInput | InvoiceUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: InvoiceCreateManyRegisterInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRegisterInput | InvoiceUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRegisterInput | InvoiceUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CashSessionUncheckedUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<CashSessionCreateWithoutRegisterInput, CashSessionUncheckedCreateWithoutRegisterInput> | CashSessionCreateWithoutRegisterInput[] | CashSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: CashSessionCreateOrConnectWithoutRegisterInput | CashSessionCreateOrConnectWithoutRegisterInput[]
    upsert?: CashSessionUpsertWithWhereUniqueWithoutRegisterInput | CashSessionUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: CashSessionCreateManyRegisterInputEnvelope
    set?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    disconnect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    delete?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    connect?: CashSessionWhereUniqueInput | CashSessionWhereUniqueInput[]
    update?: CashSessionUpdateWithWhereUniqueWithoutRegisterInput | CashSessionUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: CashSessionUpdateManyWithWhereWithoutRegisterInput | CashSessionUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<InvoiceCreateWithoutRegisterInput, InvoiceUncheckedCreateWithoutRegisterInput> | InvoiceCreateWithoutRegisterInput[] | InvoiceUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRegisterInput | InvoiceCreateOrConnectWithoutRegisterInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRegisterInput | InvoiceUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: InvoiceCreateManyRegisterInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRegisterInput | InvoiceUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRegisterInput | InvoiceUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutPosTerminalsInput = {
    create?: XOR<LocationCreateWithoutPosTerminalsInput, LocationUncheckedCreateWithoutPosTerminalsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPosTerminalsInput
    connect?: LocationWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutPosTerminalInput = {
    create?: XOR<PaymentCreateWithoutPosTerminalInput, PaymentUncheckedCreateWithoutPosTerminalInput> | PaymentCreateWithoutPosTerminalInput[] | PaymentUncheckedCreateWithoutPosTerminalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPosTerminalInput | PaymentCreateOrConnectWithoutPosTerminalInput[]
    createMany?: PaymentCreateManyPosTerminalInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPosTerminalInput = {
    create?: XOR<PaymentCreateWithoutPosTerminalInput, PaymentUncheckedCreateWithoutPosTerminalInput> | PaymentCreateWithoutPosTerminalInput[] | PaymentUncheckedCreateWithoutPosTerminalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPosTerminalInput | PaymentCreateOrConnectWithoutPosTerminalInput[]
    createMany?: PaymentCreateManyPosTerminalInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutPosTerminalsNestedInput = {
    create?: XOR<LocationCreateWithoutPosTerminalsInput, LocationUncheckedCreateWithoutPosTerminalsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPosTerminalsInput
    upsert?: LocationUpsertWithoutPosTerminalsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPosTerminalsInput, LocationUpdateWithoutPosTerminalsInput>, LocationUncheckedUpdateWithoutPosTerminalsInput>
  }

  export type PaymentUpdateManyWithoutPosTerminalNestedInput = {
    create?: XOR<PaymentCreateWithoutPosTerminalInput, PaymentUncheckedCreateWithoutPosTerminalInput> | PaymentCreateWithoutPosTerminalInput[] | PaymentUncheckedCreateWithoutPosTerminalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPosTerminalInput | PaymentCreateOrConnectWithoutPosTerminalInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPosTerminalInput | PaymentUpsertWithWhereUniqueWithoutPosTerminalInput[]
    createMany?: PaymentCreateManyPosTerminalInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPosTerminalInput | PaymentUpdateWithWhereUniqueWithoutPosTerminalInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPosTerminalInput | PaymentUpdateManyWithWhereWithoutPosTerminalInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPosTerminalNestedInput = {
    create?: XOR<PaymentCreateWithoutPosTerminalInput, PaymentUncheckedCreateWithoutPosTerminalInput> | PaymentCreateWithoutPosTerminalInput[] | PaymentUncheckedCreateWithoutPosTerminalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPosTerminalInput | PaymentCreateOrConnectWithoutPosTerminalInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPosTerminalInput | PaymentUpsertWithWhereUniqueWithoutPosTerminalInput[]
    createMany?: PaymentCreateManyPosTerminalInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPosTerminalInput | PaymentUpdateWithWhereUniqueWithoutPosTerminalInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPosTerminalInput | PaymentUpdateManyWithWhereWithoutPosTerminalInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutWorkstationsInput = {
    create?: XOR<LocationCreateWithoutWorkstationsInput, LocationUncheckedCreateWithoutWorkstationsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWorkstationsInput
    connect?: LocationWhereUniqueInput
  }

  export type AuthSessionCreateNestedManyWithoutWorkstationInput = {
    create?: XOR<AuthSessionCreateWithoutWorkstationInput, AuthSessionUncheckedCreateWithoutWorkstationInput> | AuthSessionCreateWithoutWorkstationInput[] | AuthSessionUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutWorkstationInput | AuthSessionCreateOrConnectWithoutWorkstationInput[]
    createMany?: AuthSessionCreateManyWorkstationInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type RequestContextCreateNestedManyWithoutWorkstationInput = {
    create?: XOR<RequestContextCreateWithoutWorkstationInput, RequestContextUncheckedCreateWithoutWorkstationInput> | RequestContextCreateWithoutWorkstationInput[] | RequestContextUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutWorkstationInput | RequestContextCreateOrConnectWithoutWorkstationInput[]
    createMany?: RequestContextCreateManyWorkstationInputEnvelope
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
  }

  export type AuthSessionUncheckedCreateNestedManyWithoutWorkstationInput = {
    create?: XOR<AuthSessionCreateWithoutWorkstationInput, AuthSessionUncheckedCreateWithoutWorkstationInput> | AuthSessionCreateWithoutWorkstationInput[] | AuthSessionUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutWorkstationInput | AuthSessionCreateOrConnectWithoutWorkstationInput[]
    createMany?: AuthSessionCreateManyWorkstationInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type RequestContextUncheckedCreateNestedManyWithoutWorkstationInput = {
    create?: XOR<RequestContextCreateWithoutWorkstationInput, RequestContextUncheckedCreateWithoutWorkstationInput> | RequestContextCreateWithoutWorkstationInput[] | RequestContextUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutWorkstationInput | RequestContextCreateOrConnectWithoutWorkstationInput[]
    createMany?: RequestContextCreateManyWorkstationInputEnvelope
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
  }

  export type EnumWorkstationTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkstationType
  }

  export type LocationUpdateOneRequiredWithoutWorkstationsNestedInput = {
    create?: XOR<LocationCreateWithoutWorkstationsInput, LocationUncheckedCreateWithoutWorkstationsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWorkstationsInput
    upsert?: LocationUpsertWithoutWorkstationsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutWorkstationsInput, LocationUpdateWithoutWorkstationsInput>, LocationUncheckedUpdateWithoutWorkstationsInput>
  }

  export type AuthSessionUpdateManyWithoutWorkstationNestedInput = {
    create?: XOR<AuthSessionCreateWithoutWorkstationInput, AuthSessionUncheckedCreateWithoutWorkstationInput> | AuthSessionCreateWithoutWorkstationInput[] | AuthSessionUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutWorkstationInput | AuthSessionCreateOrConnectWithoutWorkstationInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutWorkstationInput | AuthSessionUpsertWithWhereUniqueWithoutWorkstationInput[]
    createMany?: AuthSessionCreateManyWorkstationInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutWorkstationInput | AuthSessionUpdateWithWhereUniqueWithoutWorkstationInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutWorkstationInput | AuthSessionUpdateManyWithWhereWithoutWorkstationInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type RequestContextUpdateManyWithoutWorkstationNestedInput = {
    create?: XOR<RequestContextCreateWithoutWorkstationInput, RequestContextUncheckedCreateWithoutWorkstationInput> | RequestContextCreateWithoutWorkstationInput[] | RequestContextUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutWorkstationInput | RequestContextCreateOrConnectWithoutWorkstationInput[]
    upsert?: RequestContextUpsertWithWhereUniqueWithoutWorkstationInput | RequestContextUpsertWithWhereUniqueWithoutWorkstationInput[]
    createMany?: RequestContextCreateManyWorkstationInputEnvelope
    set?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    disconnect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    delete?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    update?: RequestContextUpdateWithWhereUniqueWithoutWorkstationInput | RequestContextUpdateWithWhereUniqueWithoutWorkstationInput[]
    updateMany?: RequestContextUpdateManyWithWhereWithoutWorkstationInput | RequestContextUpdateManyWithWhereWithoutWorkstationInput[]
    deleteMany?: RequestContextScalarWhereInput | RequestContextScalarWhereInput[]
  }

  export type AuthSessionUncheckedUpdateManyWithoutWorkstationNestedInput = {
    create?: XOR<AuthSessionCreateWithoutWorkstationInput, AuthSessionUncheckedCreateWithoutWorkstationInput> | AuthSessionCreateWithoutWorkstationInput[] | AuthSessionUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutWorkstationInput | AuthSessionCreateOrConnectWithoutWorkstationInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutWorkstationInput | AuthSessionUpsertWithWhereUniqueWithoutWorkstationInput[]
    createMany?: AuthSessionCreateManyWorkstationInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutWorkstationInput | AuthSessionUpdateWithWhereUniqueWithoutWorkstationInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutWorkstationInput | AuthSessionUpdateManyWithWhereWithoutWorkstationInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type RequestContextUncheckedUpdateManyWithoutWorkstationNestedInput = {
    create?: XOR<RequestContextCreateWithoutWorkstationInput, RequestContextUncheckedCreateWithoutWorkstationInput> | RequestContextCreateWithoutWorkstationInput[] | RequestContextUncheckedCreateWithoutWorkstationInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutWorkstationInput | RequestContextCreateOrConnectWithoutWorkstationInput[]
    upsert?: RequestContextUpsertWithWhereUniqueWithoutWorkstationInput | RequestContextUpsertWithWhereUniqueWithoutWorkstationInput[]
    createMany?: RequestContextCreateManyWorkstationInputEnvelope
    set?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    disconnect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    delete?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    update?: RequestContextUpdateWithWhereUniqueWithoutWorkstationInput | RequestContextUpdateWithWhereUniqueWithoutWorkstationInput[]
    updateMany?: RequestContextUpdateManyWithWhereWithoutWorkstationInput | RequestContextUpdateManyWithWhereWithoutWorkstationInput[]
    deleteMany?: RequestContextScalarWhereInput | RequestContextScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPatientsCreatedInput = {
    create?: XOR<UserCreateWithoutPatientsCreatedInput, UserUncheckedCreateWithoutPatientsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type PreclinicCreateNestedManyWithoutPatientInput = {
    create?: XOR<PreclinicCreateWithoutPatientInput, PreclinicUncheckedCreateWithoutPatientInput> | PreclinicCreateWithoutPatientInput[] | PreclinicUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutPatientInput | PreclinicCreateOrConnectWithoutPatientInput[]
    createMany?: PreclinicCreateManyPatientInputEnvelope
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
  }

  export type AllergyCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type ProblemCreateNestedManyWithoutPatientInput = {
    create?: XOR<ProblemCreateWithoutPatientInput, ProblemUncheckedCreateWithoutPatientInput> | ProblemCreateWithoutPatientInput[] | ProblemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutPatientInput | ProblemCreateOrConnectWithoutPatientInput[]
    createMany?: ProblemCreateManyPatientInputEnvelope
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type PreclinicUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PreclinicCreateWithoutPatientInput, PreclinicUncheckedCreateWithoutPatientInput> | PreclinicCreateWithoutPatientInput[] | PreclinicUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutPatientInput | PreclinicCreateOrConnectWithoutPatientInput[]
    createMany?: PreclinicCreateManyPatientInputEnvelope
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
  }

  export type AllergyUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type ProblemUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ProblemCreateWithoutPatientInput, ProblemUncheckedCreateWithoutPatientInput> | ProblemCreateWithoutPatientInput[] | ProblemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutPatientInput | ProblemCreateOrConnectWithoutPatientInput[]
    createMany?: ProblemCreateManyPatientInputEnvelope
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumSexFieldUpdateOperationsInput = {
    set?: $Enums.Sex | null
  }

  export type NullableEnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus | null
  }

  export type UserUpdateOneWithoutPatientsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutPatientsCreatedInput, UserUncheckedCreateWithoutPatientsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientsCreatedInput
    upsert?: UserUpsertWithoutPatientsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientsCreatedInput, UserUpdateWithoutPatientsCreatedInput>, UserUncheckedUpdateWithoutPatientsCreatedInput>
  }

  export type PreclinicUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PreclinicCreateWithoutPatientInput, PreclinicUncheckedCreateWithoutPatientInput> | PreclinicCreateWithoutPatientInput[] | PreclinicUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutPatientInput | PreclinicCreateOrConnectWithoutPatientInput[]
    upsert?: PreclinicUpsertWithWhereUniqueWithoutPatientInput | PreclinicUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PreclinicCreateManyPatientInputEnvelope
    set?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    disconnect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    delete?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    update?: PreclinicUpdateWithWhereUniqueWithoutPatientInput | PreclinicUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PreclinicUpdateManyWithWhereWithoutPatientInput | PreclinicUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
  }

  export type AllergyUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutPatientInput | AllergyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutPatientInput | AllergyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutPatientInput | AllergyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type ProblemUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ProblemCreateWithoutPatientInput, ProblemUncheckedCreateWithoutPatientInput> | ProblemCreateWithoutPatientInput[] | ProblemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutPatientInput | ProblemCreateOrConnectWithoutPatientInput[]
    upsert?: ProblemUpsertWithWhereUniqueWithoutPatientInput | ProblemUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ProblemCreateManyPatientInputEnvelope
    set?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    disconnect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    delete?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    update?: ProblemUpdateWithWhereUniqueWithoutPatientInput | ProblemUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ProblemUpdateManyWithWhereWithoutPatientInput | ProblemUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPatientInput | MedicationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPatientInput | MedicationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPatientInput | MedicationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutPatientInput | LabOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutPatientInput | LabOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutPatientInput | LabOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type PreclinicUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PreclinicCreateWithoutPatientInput, PreclinicUncheckedCreateWithoutPatientInput> | PreclinicCreateWithoutPatientInput[] | PreclinicUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutPatientInput | PreclinicCreateOrConnectWithoutPatientInput[]
    upsert?: PreclinicUpsertWithWhereUniqueWithoutPatientInput | PreclinicUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PreclinicCreateManyPatientInputEnvelope
    set?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    disconnect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    delete?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    update?: PreclinicUpdateWithWhereUniqueWithoutPatientInput | PreclinicUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PreclinicUpdateManyWithWhereWithoutPatientInput | PreclinicUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
  }

  export type AllergyUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutPatientInput | AllergyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutPatientInput | AllergyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutPatientInput | AllergyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type ProblemUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ProblemCreateWithoutPatientInput, ProblemUncheckedCreateWithoutPatientInput> | ProblemCreateWithoutPatientInput[] | ProblemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutPatientInput | ProblemCreateOrConnectWithoutPatientInput[]
    upsert?: ProblemUpsertWithWhereUniqueWithoutPatientInput | ProblemUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ProblemCreateManyPatientInputEnvelope
    set?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    disconnect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    delete?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    update?: ProblemUpdateWithWhereUniqueWithoutPatientInput | ProblemUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ProblemUpdateManyWithWhereWithoutPatientInput | ProblemUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPatientInput | MedicationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPatientInput | MedicationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPatientInput | MedicationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutPatientInput | LabOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutPatientInput | LabOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutPatientInput | LabOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkstationCreateNestedOneWithoutSessionsInput = {
    create?: XOR<WorkstationCreateWithoutSessionsInput, WorkstationUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WorkstationCreateOrConnectWithoutSessionsInput
    connect?: WorkstationWhereUniqueInput
  }

  export type RequestContextCreateNestedManyWithoutSessionInput = {
    create?: XOR<RequestContextCreateWithoutSessionInput, RequestContextUncheckedCreateWithoutSessionInput> | RequestContextCreateWithoutSessionInput[] | RequestContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutSessionInput | RequestContextCreateOrConnectWithoutSessionInput[]
    createMany?: RequestContextCreateManySessionInputEnvelope
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
  }

  export type RequestContextUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<RequestContextCreateWithoutSessionInput, RequestContextUncheckedCreateWithoutSessionInput> | RequestContextCreateWithoutSessionInput[] | RequestContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutSessionInput | RequestContextCreateOrConnectWithoutSessionInput[]
    createMany?: RequestContextCreateManySessionInputEnvelope
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type WorkstationUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<WorkstationCreateWithoutSessionsInput, WorkstationUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WorkstationCreateOrConnectWithoutSessionsInput
    upsert?: WorkstationUpsertWithoutSessionsInput
    disconnect?: WorkstationWhereInput | boolean
    delete?: WorkstationWhereInput | boolean
    connect?: WorkstationWhereUniqueInput
    update?: XOR<XOR<WorkstationUpdateToOneWithWhereWithoutSessionsInput, WorkstationUpdateWithoutSessionsInput>, WorkstationUncheckedUpdateWithoutSessionsInput>
  }

  export type RequestContextUpdateManyWithoutSessionNestedInput = {
    create?: XOR<RequestContextCreateWithoutSessionInput, RequestContextUncheckedCreateWithoutSessionInput> | RequestContextCreateWithoutSessionInput[] | RequestContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutSessionInput | RequestContextCreateOrConnectWithoutSessionInput[]
    upsert?: RequestContextUpsertWithWhereUniqueWithoutSessionInput | RequestContextUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: RequestContextCreateManySessionInputEnvelope
    set?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    disconnect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    delete?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    update?: RequestContextUpdateWithWhereUniqueWithoutSessionInput | RequestContextUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: RequestContextUpdateManyWithWhereWithoutSessionInput | RequestContextUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: RequestContextScalarWhereInput | RequestContextScalarWhereInput[]
  }

  export type RequestContextUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<RequestContextCreateWithoutSessionInput, RequestContextUncheckedCreateWithoutSessionInput> | RequestContextCreateWithoutSessionInput[] | RequestContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: RequestContextCreateOrConnectWithoutSessionInput | RequestContextCreateOrConnectWithoutSessionInput[]
    upsert?: RequestContextUpsertWithWhereUniqueWithoutSessionInput | RequestContextUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: RequestContextCreateManySessionInputEnvelope
    set?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    disconnect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    delete?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    connect?: RequestContextWhereUniqueInput | RequestContextWhereUniqueInput[]
    update?: RequestContextUpdateWithWhereUniqueWithoutSessionInput | RequestContextUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: RequestContextUpdateManyWithWhereWithoutSessionInput | RequestContextUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: RequestContextScalarWhereInput | RequestContextScalarWhereInput[]
  }

  export type AuthSessionCreateNestedOneWithoutContextsInput = {
    create?: XOR<AuthSessionCreateWithoutContextsInput, AuthSessionUncheckedCreateWithoutContextsInput>
    connectOrCreate?: AuthSessionCreateOrConnectWithoutContextsInput
    connect?: AuthSessionWhereUniqueInput
  }

  export type WorkstationCreateNestedOneWithoutContextsInput = {
    create?: XOR<WorkstationCreateWithoutContextsInput, WorkstationUncheckedCreateWithoutContextsInput>
    connectOrCreate?: WorkstationCreateOrConnectWithoutContextsInput
    connect?: WorkstationWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<InvoiceCreateWithoutRequestContextInput, InvoiceUncheckedCreateWithoutRequestContextInput> | InvoiceCreateWithoutRequestContextInput[] | InvoiceUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRequestContextInput | InvoiceCreateOrConnectWithoutRequestContextInput[]
    createMany?: InvoiceCreateManyRequestContextInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<PaymentCreateWithoutRequestContextInput, PaymentUncheckedCreateWithoutRequestContextInput> | PaymentCreateWithoutRequestContextInput[] | PaymentUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRequestContextInput | PaymentCreateOrConnectWithoutRequestContextInput[]
    createMany?: PaymentCreateManyRequestContextInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashMovementCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<CashMovementCreateWithoutRequestContextInput, CashMovementUncheckedCreateWithoutRequestContextInput> | CashMovementCreateWithoutRequestContextInput[] | CashMovementUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutRequestContextInput | CashMovementCreateOrConnectWithoutRequestContextInput[]
    createMany?: CashMovementCreateManyRequestContextInputEnvelope
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type PreclinicCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<PreclinicCreateWithoutRequestContextInput, PreclinicUncheckedCreateWithoutRequestContextInput> | PreclinicCreateWithoutRequestContextInput[] | PreclinicUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRequestContextInput | PreclinicCreateOrConnectWithoutRequestContextInput[]
    createMany?: PreclinicCreateManyRequestContextInputEnvelope
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<LabOrderCreateWithoutRequestContextInput, LabOrderUncheckedCreateWithoutRequestContextInput> | LabOrderCreateWithoutRequestContextInput[] | LabOrderUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutRequestContextInput | LabOrderCreateOrConnectWithoutRequestContextInput[]
    createMany?: LabOrderCreateManyRequestContextInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type LabOrderTestCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<LabOrderTestCreateWithoutRequestContextInput, LabOrderTestUncheckedCreateWithoutRequestContextInput> | LabOrderTestCreateWithoutRequestContextInput[] | LabOrderTestUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutRequestContextInput | LabOrderTestCreateOrConnectWithoutRequestContextInput[]
    createMany?: LabOrderTestCreateManyRequestContextInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<ActivityLogCreateWithoutRequestContextInput, ActivityLogUncheckedCreateWithoutRequestContextInput> | ActivityLogCreateWithoutRequestContextInput[] | ActivityLogUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutRequestContextInput | ActivityLogCreateOrConnectWithoutRequestContextInput[]
    createMany?: ActivityLogCreateManyRequestContextInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<InvoiceCreateWithoutRequestContextInput, InvoiceUncheckedCreateWithoutRequestContextInput> | InvoiceCreateWithoutRequestContextInput[] | InvoiceUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRequestContextInput | InvoiceCreateOrConnectWithoutRequestContextInput[]
    createMany?: InvoiceCreateManyRequestContextInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<PaymentCreateWithoutRequestContextInput, PaymentUncheckedCreateWithoutRequestContextInput> | PaymentCreateWithoutRequestContextInput[] | PaymentUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRequestContextInput | PaymentCreateOrConnectWithoutRequestContextInput[]
    createMany?: PaymentCreateManyRequestContextInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashMovementUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<CashMovementCreateWithoutRequestContextInput, CashMovementUncheckedCreateWithoutRequestContextInput> | CashMovementCreateWithoutRequestContextInput[] | CashMovementUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutRequestContextInput | CashMovementCreateOrConnectWithoutRequestContextInput[]
    createMany?: CashMovementCreateManyRequestContextInputEnvelope
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type PreclinicUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<PreclinicCreateWithoutRequestContextInput, PreclinicUncheckedCreateWithoutRequestContextInput> | PreclinicCreateWithoutRequestContextInput[] | PreclinicUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRequestContextInput | PreclinicCreateOrConnectWithoutRequestContextInput[]
    createMany?: PreclinicCreateManyRequestContextInputEnvelope
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<LabOrderCreateWithoutRequestContextInput, LabOrderUncheckedCreateWithoutRequestContextInput> | LabOrderCreateWithoutRequestContextInput[] | LabOrderUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutRequestContextInput | LabOrderCreateOrConnectWithoutRequestContextInput[]
    createMany?: LabOrderCreateManyRequestContextInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<LabOrderTestCreateWithoutRequestContextInput, LabOrderTestUncheckedCreateWithoutRequestContextInput> | LabOrderTestCreateWithoutRequestContextInput[] | LabOrderTestUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutRequestContextInput | LabOrderTestCreateOrConnectWithoutRequestContextInput[]
    createMany?: LabOrderTestCreateManyRequestContextInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput = {
    create?: XOR<ActivityLogCreateWithoutRequestContextInput, ActivityLogUncheckedCreateWithoutRequestContextInput> | ActivityLogCreateWithoutRequestContextInput[] | ActivityLogUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutRequestContextInput | ActivityLogCreateOrConnectWithoutRequestContextInput[]
    createMany?: ActivityLogCreateManyRequestContextInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AuthSessionUpdateOneRequiredWithoutContextsNestedInput = {
    create?: XOR<AuthSessionCreateWithoutContextsInput, AuthSessionUncheckedCreateWithoutContextsInput>
    connectOrCreate?: AuthSessionCreateOrConnectWithoutContextsInput
    upsert?: AuthSessionUpsertWithoutContextsInput
    connect?: AuthSessionWhereUniqueInput
    update?: XOR<XOR<AuthSessionUpdateToOneWithWhereWithoutContextsInput, AuthSessionUpdateWithoutContextsInput>, AuthSessionUncheckedUpdateWithoutContextsInput>
  }

  export type WorkstationUpdateOneWithoutContextsNestedInput = {
    create?: XOR<WorkstationCreateWithoutContextsInput, WorkstationUncheckedCreateWithoutContextsInput>
    connectOrCreate?: WorkstationCreateOrConnectWithoutContextsInput
    upsert?: WorkstationUpsertWithoutContextsInput
    disconnect?: WorkstationWhereInput | boolean
    delete?: WorkstationWhereInput | boolean
    connect?: WorkstationWhereUniqueInput
    update?: XOR<XOR<WorkstationUpdateToOneWithWhereWithoutContextsInput, WorkstationUpdateWithoutContextsInput>, WorkstationUncheckedUpdateWithoutContextsInput>
  }

  export type InvoiceUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<InvoiceCreateWithoutRequestContextInput, InvoiceUncheckedCreateWithoutRequestContextInput> | InvoiceCreateWithoutRequestContextInput[] | InvoiceUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRequestContextInput | InvoiceCreateOrConnectWithoutRequestContextInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRequestContextInput | InvoiceUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: InvoiceCreateManyRequestContextInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRequestContextInput | InvoiceUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRequestContextInput | InvoiceUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<PaymentCreateWithoutRequestContextInput, PaymentUncheckedCreateWithoutRequestContextInput> | PaymentCreateWithoutRequestContextInput[] | PaymentUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRequestContextInput | PaymentCreateOrConnectWithoutRequestContextInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutRequestContextInput | PaymentUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: PaymentCreateManyRequestContextInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutRequestContextInput | PaymentUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutRequestContextInput | PaymentUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashMovementUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<CashMovementCreateWithoutRequestContextInput, CashMovementUncheckedCreateWithoutRequestContextInput> | CashMovementCreateWithoutRequestContextInput[] | CashMovementUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutRequestContextInput | CashMovementCreateOrConnectWithoutRequestContextInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutRequestContextInput | CashMovementUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: CashMovementCreateManyRequestContextInputEnvelope
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutRequestContextInput | CashMovementUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutRequestContextInput | CashMovementUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type PreclinicUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<PreclinicCreateWithoutRequestContextInput, PreclinicUncheckedCreateWithoutRequestContextInput> | PreclinicCreateWithoutRequestContextInput[] | PreclinicUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRequestContextInput | PreclinicCreateOrConnectWithoutRequestContextInput[]
    upsert?: PreclinicUpsertWithWhereUniqueWithoutRequestContextInput | PreclinicUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: PreclinicCreateManyRequestContextInputEnvelope
    set?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    disconnect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    delete?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    update?: PreclinicUpdateWithWhereUniqueWithoutRequestContextInput | PreclinicUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: PreclinicUpdateManyWithWhereWithoutRequestContextInput | PreclinicUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<LabOrderCreateWithoutRequestContextInput, LabOrderUncheckedCreateWithoutRequestContextInput> | LabOrderCreateWithoutRequestContextInput[] | LabOrderUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutRequestContextInput | LabOrderCreateOrConnectWithoutRequestContextInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutRequestContextInput | LabOrderUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: LabOrderCreateManyRequestContextInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutRequestContextInput | LabOrderUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutRequestContextInput | LabOrderUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type LabOrderTestUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutRequestContextInput, LabOrderTestUncheckedCreateWithoutRequestContextInput> | LabOrderTestCreateWithoutRequestContextInput[] | LabOrderTestUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutRequestContextInput | LabOrderTestCreateOrConnectWithoutRequestContextInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutRequestContextInput | LabOrderTestUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: LabOrderTestCreateManyRequestContextInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutRequestContextInput | LabOrderTestUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutRequestContextInput | LabOrderTestUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<ActivityLogCreateWithoutRequestContextInput, ActivityLogUncheckedCreateWithoutRequestContextInput> | ActivityLogCreateWithoutRequestContextInput[] | ActivityLogUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutRequestContextInput | ActivityLogCreateOrConnectWithoutRequestContextInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutRequestContextInput | ActivityLogUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: ActivityLogCreateManyRequestContextInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutRequestContextInput | ActivityLogUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutRequestContextInput | ActivityLogUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<InvoiceCreateWithoutRequestContextInput, InvoiceUncheckedCreateWithoutRequestContextInput> | InvoiceCreateWithoutRequestContextInput[] | InvoiceUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRequestContextInput | InvoiceCreateOrConnectWithoutRequestContextInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRequestContextInput | InvoiceUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: InvoiceCreateManyRequestContextInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRequestContextInput | InvoiceUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRequestContextInput | InvoiceUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<PaymentCreateWithoutRequestContextInput, PaymentUncheckedCreateWithoutRequestContextInput> | PaymentCreateWithoutRequestContextInput[] | PaymentUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRequestContextInput | PaymentCreateOrConnectWithoutRequestContextInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutRequestContextInput | PaymentUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: PaymentCreateManyRequestContextInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutRequestContextInput | PaymentUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutRequestContextInput | PaymentUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<CashMovementCreateWithoutRequestContextInput, CashMovementUncheckedCreateWithoutRequestContextInput> | CashMovementCreateWithoutRequestContextInput[] | CashMovementUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutRequestContextInput | CashMovementCreateOrConnectWithoutRequestContextInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutRequestContextInput | CashMovementUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: CashMovementCreateManyRequestContextInputEnvelope
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutRequestContextInput | CashMovementUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutRequestContextInput | CashMovementUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<PreclinicCreateWithoutRequestContextInput, PreclinicUncheckedCreateWithoutRequestContextInput> | PreclinicCreateWithoutRequestContextInput[] | PreclinicUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: PreclinicCreateOrConnectWithoutRequestContextInput | PreclinicCreateOrConnectWithoutRequestContextInput[]
    upsert?: PreclinicUpsertWithWhereUniqueWithoutRequestContextInput | PreclinicUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: PreclinicCreateManyRequestContextInputEnvelope
    set?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    disconnect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    delete?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    connect?: PreclinicWhereUniqueInput | PreclinicWhereUniqueInput[]
    update?: PreclinicUpdateWithWhereUniqueWithoutRequestContextInput | PreclinicUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: PreclinicUpdateManyWithWhereWithoutRequestContextInput | PreclinicUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<LabOrderCreateWithoutRequestContextInput, LabOrderUncheckedCreateWithoutRequestContextInput> | LabOrderCreateWithoutRequestContextInput[] | LabOrderUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutRequestContextInput | LabOrderCreateOrConnectWithoutRequestContextInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutRequestContextInput | LabOrderUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: LabOrderCreateManyRequestContextInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutRequestContextInput | LabOrderUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutRequestContextInput | LabOrderUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutRequestContextInput, LabOrderTestUncheckedCreateWithoutRequestContextInput> | LabOrderTestCreateWithoutRequestContextInput[] | LabOrderTestUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutRequestContextInput | LabOrderTestCreateOrConnectWithoutRequestContextInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutRequestContextInput | LabOrderTestUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: LabOrderTestCreateManyRequestContextInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutRequestContextInput | LabOrderTestUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutRequestContextInput | LabOrderTestUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput = {
    create?: XOR<ActivityLogCreateWithoutRequestContextInput, ActivityLogUncheckedCreateWithoutRequestContextInput> | ActivityLogCreateWithoutRequestContextInput[] | ActivityLogUncheckedCreateWithoutRequestContextInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutRequestContextInput | ActivityLogCreateOrConnectWithoutRequestContextInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutRequestContextInput | ActivityLogUpsertWithWhereUniqueWithoutRequestContextInput[]
    createMany?: ActivityLogCreateManyRequestContextInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutRequestContextInput | ActivityLogUpdateWithWhereUniqueWithoutRequestContextInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutRequestContextInput | ActivityLogUpdateManyWithWhereWithoutRequestContextInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPreclinicsInput = {
    create?: XOR<PatientCreateWithoutPreclinicsInput, PatientUncheckedCreateWithoutPreclinicsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPreclinicsInput
    connect?: PatientWhereUniqueInput
  }

  export type LabOrderCreateNestedManyWithoutPreclinicInput = {
    create?: XOR<LabOrderCreateWithoutPreclinicInput, LabOrderUncheckedCreateWithoutPreclinicInput> | LabOrderCreateWithoutPreclinicInput[] | LabOrderUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPreclinicInput | LabOrderCreateOrConnectWithoutPreclinicInput[]
    createMany?: LabOrderCreateManyPreclinicInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPreclinicsInput = {
    create?: XOR<UserCreateWithoutPreclinicsInput, UserUncheckedCreateWithoutPreclinicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreclinicsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutPreclinicsInput = {
    create?: XOR<RequestContextCreateWithoutPreclinicsInput, RequestContextUncheckedCreateWithoutPreclinicsInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutPreclinicsInput
    connect?: RequestContextWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutPreclinicInput = {
    create?: XOR<InvoiceCreateWithoutPreclinicInput, InvoiceUncheckedCreateWithoutPreclinicInput> | InvoiceCreateWithoutPreclinicInput[] | InvoiceUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPreclinicInput | InvoiceCreateOrConnectWithoutPreclinicInput[]
    createMany?: InvoiceCreateManyPreclinicInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutPreclinicInput = {
    create?: XOR<LabOrderCreateWithoutPreclinicInput, LabOrderUncheckedCreateWithoutPreclinicInput> | LabOrderCreateWithoutPreclinicInput[] | LabOrderUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPreclinicInput | LabOrderCreateOrConnectWithoutPreclinicInput[]
    createMany?: LabOrderCreateManyPreclinicInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPreclinicInput = {
    create?: XOR<InvoiceCreateWithoutPreclinicInput, InvoiceUncheckedCreateWithoutPreclinicInput> | InvoiceCreateWithoutPreclinicInput[] | InvoiceUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPreclinicInput | InvoiceCreateOrConnectWithoutPreclinicInput[]
    createMany?: InvoiceCreateManyPreclinicInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PatientUpdateOneRequiredWithoutPreclinicsNestedInput = {
    create?: XOR<PatientCreateWithoutPreclinicsInput, PatientUncheckedCreateWithoutPreclinicsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPreclinicsInput
    upsert?: PatientUpsertWithoutPreclinicsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPreclinicsInput, PatientUpdateWithoutPreclinicsInput>, PatientUncheckedUpdateWithoutPreclinicsInput>
  }

  export type LabOrderUpdateManyWithoutPreclinicNestedInput = {
    create?: XOR<LabOrderCreateWithoutPreclinicInput, LabOrderUncheckedCreateWithoutPreclinicInput> | LabOrderCreateWithoutPreclinicInput[] | LabOrderUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPreclinicInput | LabOrderCreateOrConnectWithoutPreclinicInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutPreclinicInput | LabOrderUpsertWithWhereUniqueWithoutPreclinicInput[]
    createMany?: LabOrderCreateManyPreclinicInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutPreclinicInput | LabOrderUpdateWithWhereUniqueWithoutPreclinicInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutPreclinicInput | LabOrderUpdateManyWithWhereWithoutPreclinicInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPreclinicsNestedInput = {
    create?: XOR<UserCreateWithoutPreclinicsInput, UserUncheckedCreateWithoutPreclinicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreclinicsInput
    upsert?: UserUpsertWithoutPreclinicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreclinicsInput, UserUpdateWithoutPreclinicsInput>, UserUncheckedUpdateWithoutPreclinicsInput>
  }

  export type RequestContextUpdateOneRequiredWithoutPreclinicsNestedInput = {
    create?: XOR<RequestContextCreateWithoutPreclinicsInput, RequestContextUncheckedCreateWithoutPreclinicsInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutPreclinicsInput
    upsert?: RequestContextUpsertWithoutPreclinicsInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutPreclinicsInput, RequestContextUpdateWithoutPreclinicsInput>, RequestContextUncheckedUpdateWithoutPreclinicsInput>
  }

  export type InvoiceUpdateManyWithoutPreclinicNestedInput = {
    create?: XOR<InvoiceCreateWithoutPreclinicInput, InvoiceUncheckedCreateWithoutPreclinicInput> | InvoiceCreateWithoutPreclinicInput[] | InvoiceUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPreclinicInput | InvoiceCreateOrConnectWithoutPreclinicInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPreclinicInput | InvoiceUpsertWithWhereUniqueWithoutPreclinicInput[]
    createMany?: InvoiceCreateManyPreclinicInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPreclinicInput | InvoiceUpdateWithWhereUniqueWithoutPreclinicInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPreclinicInput | InvoiceUpdateManyWithWhereWithoutPreclinicInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutPreclinicNestedInput = {
    create?: XOR<LabOrderCreateWithoutPreclinicInput, LabOrderUncheckedCreateWithoutPreclinicInput> | LabOrderCreateWithoutPreclinicInput[] | LabOrderUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPreclinicInput | LabOrderCreateOrConnectWithoutPreclinicInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutPreclinicInput | LabOrderUpsertWithWhereUniqueWithoutPreclinicInput[]
    createMany?: LabOrderCreateManyPreclinicInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutPreclinicInput | LabOrderUpdateWithWhereUniqueWithoutPreclinicInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutPreclinicInput | LabOrderUpdateManyWithWhereWithoutPreclinicInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPreclinicNestedInput = {
    create?: XOR<InvoiceCreateWithoutPreclinicInput, InvoiceUncheckedCreateWithoutPreclinicInput> | InvoiceCreateWithoutPreclinicInput[] | InvoiceUncheckedCreateWithoutPreclinicInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPreclinicInput | InvoiceCreateOrConnectWithoutPreclinicInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPreclinicInput | InvoiceUpsertWithWhereUniqueWithoutPreclinicInput[]
    createMany?: InvoiceCreateManyPreclinicInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPreclinicInput | InvoiceUpdateWithWhereUniqueWithoutPreclinicInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPreclinicInput | InvoiceUpdateManyWithWhereWithoutPreclinicInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAllergiesInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAllergiesRecordedInput = {
    create?: XOR<UserCreateWithoutAllergiesRecordedInput, UserUncheckedCreateWithoutAllergiesRecordedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllergiesRecordedInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumAllergySeverityFieldUpdateOperationsInput = {
    set?: $Enums.AllergySeverity | null
  }

  export type PatientUpdateOneRequiredWithoutAllergiesNestedInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    upsert?: PatientUpsertWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAllergiesInput, PatientUpdateWithoutAllergiesInput>, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type UserUpdateOneWithoutAllergiesRecordedNestedInput = {
    create?: XOR<UserCreateWithoutAllergiesRecordedInput, UserUncheckedCreateWithoutAllergiesRecordedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllergiesRecordedInput
    upsert?: UserUpsertWithoutAllergiesRecordedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAllergiesRecordedInput, UserUpdateWithoutAllergiesRecordedInput>, UserUncheckedUpdateWithoutAllergiesRecordedInput>
  }

  export type PatientCreateNestedOneWithoutProblemsInput = {
    create?: XOR<PatientCreateWithoutProblemsInput, PatientUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutProblemsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProblemsRecordedInput = {
    create?: XOR<UserCreateWithoutProblemsRecordedInput, UserUncheckedCreateWithoutProblemsRecordedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProblemsRecordedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProblemStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProblemStatus
  }

  export type PatientUpdateOneRequiredWithoutProblemsNestedInput = {
    create?: XOR<PatientCreateWithoutProblemsInput, PatientUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutProblemsInput
    upsert?: PatientUpsertWithoutProblemsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutProblemsInput, PatientUpdateWithoutProblemsInput>, PatientUncheckedUpdateWithoutProblemsInput>
  }

  export type UserUpdateOneWithoutProblemsRecordedNestedInput = {
    create?: XOR<UserCreateWithoutProblemsRecordedInput, UserUncheckedCreateWithoutProblemsRecordedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProblemsRecordedInput
    upsert?: UserUpsertWithoutProblemsRecordedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProblemsRecordedInput, UserUpdateWithoutProblemsRecordedInput>, UserUncheckedUpdateWithoutProblemsRecordedInput>
  }

  export type PatientCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMedicationsRxInput = {
    create?: XOR<UserCreateWithoutMedicationsRxInput, UserUncheckedCreateWithoutMedicationsRxInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicationsRxInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumRouteFieldUpdateOperationsInput = {
    set?: $Enums.Route | null
  }

  export type PatientUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationsInput
    upsert?: PatientUpsertWithoutMedicationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicationsInput, PatientUpdateWithoutMedicationsInput>, PatientUncheckedUpdateWithoutMedicationsInput>
  }

  export type UserUpdateOneWithoutMedicationsRxNestedInput = {
    create?: XOR<UserCreateWithoutMedicationsRxInput, UserUncheckedCreateWithoutMedicationsRxInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicationsRxInput
    upsert?: UserUpsertWithoutMedicationsRxInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicationsRxInput, UserUpdateWithoutMedicationsRxInput>, UserUncheckedUpdateWithoutMedicationsRxInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type InvoiceLineCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceLineCreateWithoutServiceInput, InvoiceLineUncheckedCreateWithoutServiceInput> | InvoiceLineCreateWithoutServiceInput[] | InvoiceLineUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutServiceInput | InvoiceLineCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceLineCreateManyServiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceLineCreateWithoutServiceInput, InvoiceLineUncheckedCreateWithoutServiceInput> | InvoiceLineCreateWithoutServiceInput[] | InvoiceLineUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutServiceInput | InvoiceLineCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceLineCreateManyServiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    upsert?: ServiceCategoryUpsertWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutServicesInput, ServiceCategoryUpdateWithoutServicesInput>, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type InvoiceLineUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutServiceInput, InvoiceLineUncheckedCreateWithoutServiceInput> | InvoiceLineCreateWithoutServiceInput[] | InvoiceLineUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutServiceInput | InvoiceLineCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutServiceInput | InvoiceLineUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceLineCreateManyServiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutServiceInput | InvoiceLineUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutServiceInput | InvoiceLineUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutServiceInput, InvoiceLineUncheckedCreateWithoutServiceInput> | InvoiceLineCreateWithoutServiceInput[] | InvoiceLineUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutServiceInput | InvoiceLineCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutServiceInput | InvoiceLineUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceLineCreateManyServiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutServiceInput | InvoiceLineUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutServiceInput | InvoiceLineUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InvoiceLineCreateNestedManyWithoutProviderInput = {
    create?: XOR<InvoiceLineCreateWithoutProviderInput, InvoiceLineUncheckedCreateWithoutProviderInput> | InvoiceLineCreateWithoutProviderInput[] | InvoiceLineUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProviderInput | InvoiceLineCreateOrConnectWithoutProviderInput[]
    createMany?: InvoiceLineCreateManyProviderInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type ProviderCommissionCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderCommissionCreateWithoutProviderInput, ProviderCommissionUncheckedCreateWithoutProviderInput> | ProviderCommissionCreateWithoutProviderInput[] | ProviderCommissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutProviderInput | ProviderCommissionCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderCommissionCreateManyProviderInputEnvelope
    connect?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<InvoiceLineCreateWithoutProviderInput, InvoiceLineUncheckedCreateWithoutProviderInput> | InvoiceLineCreateWithoutProviderInput[] | InvoiceLineUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProviderInput | InvoiceLineCreateOrConnectWithoutProviderInput[]
    createMany?: InvoiceLineCreateManyProviderInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type ProviderCommissionUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderCommissionCreateWithoutProviderInput, ProviderCommissionUncheckedCreateWithoutProviderInput> | ProviderCommissionCreateWithoutProviderInput[] | ProviderCommissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutProviderInput | ProviderCommissionCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderCommissionCreateManyProviderInputEnvelope
    connect?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
  }

  export type InvoiceLineUpdateManyWithoutProviderNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutProviderInput, InvoiceLineUncheckedCreateWithoutProviderInput> | InvoiceLineCreateWithoutProviderInput[] | InvoiceLineUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProviderInput | InvoiceLineCreateOrConnectWithoutProviderInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutProviderInput | InvoiceLineUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: InvoiceLineCreateManyProviderInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutProviderInput | InvoiceLineUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutProviderInput | InvoiceLineUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type ProviderCommissionUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderCommissionCreateWithoutProviderInput, ProviderCommissionUncheckedCreateWithoutProviderInput> | ProviderCommissionCreateWithoutProviderInput[] | ProviderCommissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutProviderInput | ProviderCommissionCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderCommissionUpsertWithWhereUniqueWithoutProviderInput | ProviderCommissionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderCommissionCreateManyProviderInputEnvelope
    set?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    disconnect?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    delete?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    connect?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    update?: ProviderCommissionUpdateWithWhereUniqueWithoutProviderInput | ProviderCommissionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderCommissionUpdateManyWithWhereWithoutProviderInput | ProviderCommissionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderCommissionScalarWhereInput | ProviderCommissionScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutProviderInput, InvoiceLineUncheckedCreateWithoutProviderInput> | InvoiceLineCreateWithoutProviderInput[] | InvoiceLineUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProviderInput | InvoiceLineCreateOrConnectWithoutProviderInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutProviderInput | InvoiceLineUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: InvoiceLineCreateManyProviderInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutProviderInput | InvoiceLineUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutProviderInput | InvoiceLineUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type ProviderCommissionUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderCommissionCreateWithoutProviderInput, ProviderCommissionUncheckedCreateWithoutProviderInput> | ProviderCommissionCreateWithoutProviderInput[] | ProviderCommissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutProviderInput | ProviderCommissionCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderCommissionUpsertWithWhereUniqueWithoutProviderInput | ProviderCommissionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderCommissionCreateManyProviderInputEnvelope
    set?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    disconnect?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    delete?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    connect?: ProviderCommissionWhereUniqueInput | ProviderCommissionWhereUniqueInput[]
    update?: ProviderCommissionUpdateWithWhereUniqueWithoutProviderInput | ProviderCommissionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderCommissionUpdateManyWithWhereWithoutProviderInput | ProviderCommissionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderCommissionScalarWhereInput | ProviderCommissionScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type PreclinicCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PreclinicCreateWithoutInvoicesInput, PreclinicUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PreclinicCreateOrConnectWithoutInvoicesInput
    connect?: PreclinicWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<LocationCreateWithoutInvoicesInput, LocationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInvoicesInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoicesCashierInput = {
    create?: XOR<UserCreateWithoutInvoicesCashierInput, UserUncheckedCreateWithoutInvoicesCashierInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesCashierInput
    connect?: UserWhereUniqueInput
  }

  export type CashRegisterCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CashRegisterCreateWithoutInvoicesInput, CashRegisterUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutInvoicesInput
    connect?: CashRegisterWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<RequestContextCreateWithoutInvoicesInput, RequestContextUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutInvoicesInput
    connect?: RequestContextWhereUniqueInput
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LabOrderCreateWithoutInvoiceInput, LabOrderUncheckedCreateWithoutInvoiceInput> | LabOrderCreateWithoutInvoiceInput[] | LabOrderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutInvoiceInput | LabOrderCreateOrConnectWithoutInvoiceInput[]
    createMany?: LabOrderCreateManyInvoiceInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LabOrderCreateWithoutInvoiceInput, LabOrderUncheckedCreateWithoutInvoiceInput> | LabOrderCreateWithoutInvoiceInput[] | LabOrderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutInvoiceInput | LabOrderCreateOrConnectWithoutInvoiceInput[]
    createMany?: LabOrderCreateManyInvoiceInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type PatientUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PreclinicUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PreclinicCreateWithoutInvoicesInput, PreclinicUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PreclinicCreateOrConnectWithoutInvoicesInput
    upsert?: PreclinicUpsertWithoutInvoicesInput
    disconnect?: PreclinicWhereInput | boolean
    delete?: PreclinicWhereInput | boolean
    connect?: PreclinicWhereUniqueInput
    update?: XOR<XOR<PreclinicUpdateToOneWithWhereWithoutInvoicesInput, PreclinicUpdateWithoutInvoicesInput>, PreclinicUncheckedUpdateWithoutInvoicesInput>
  }

  export type LocationUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<LocationCreateWithoutInvoicesInput, LocationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInvoicesInput
    upsert?: LocationUpsertWithoutInvoicesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutInvoicesInput, LocationUpdateWithoutInvoicesInput>, LocationUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutInvoicesCashierNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesCashierInput, UserUncheckedCreateWithoutInvoicesCashierInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesCashierInput
    upsert?: UserUpsertWithoutInvoicesCashierInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesCashierInput, UserUpdateWithoutInvoicesCashierInput>, UserUncheckedUpdateWithoutInvoicesCashierInput>
  }

  export type CashRegisterUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CashRegisterCreateWithoutInvoicesInput, CashRegisterUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutInvoicesInput
    upsert?: CashRegisterUpsertWithoutInvoicesInput
    disconnect?: CashRegisterWhereInput | boolean
    delete?: CashRegisterWhereInput | boolean
    connect?: CashRegisterWhereUniqueInput
    update?: XOR<XOR<CashRegisterUpdateToOneWithWhereWithoutInvoicesInput, CashRegisterUpdateWithoutInvoicesInput>, CashRegisterUncheckedUpdateWithoutInvoicesInput>
  }

  export type RequestContextUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<RequestContextCreateWithoutInvoicesInput, RequestContextUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutInvoicesInput
    upsert?: RequestContextUpsertWithoutInvoicesInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutInvoicesInput, RequestContextUpdateWithoutInvoicesInput>, RequestContextUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LabOrderCreateWithoutInvoiceInput, LabOrderUncheckedCreateWithoutInvoiceInput> | LabOrderCreateWithoutInvoiceInput[] | LabOrderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutInvoiceInput | LabOrderCreateOrConnectWithoutInvoiceInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutInvoiceInput | LabOrderUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LabOrderCreateManyInvoiceInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutInvoiceInput | LabOrderUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutInvoiceInput | LabOrderUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LabOrderCreateWithoutInvoiceInput, LabOrderUncheckedCreateWithoutInvoiceInput> | LabOrderCreateWithoutInvoiceInput[] | LabOrderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutInvoiceInput | LabOrderCreateOrConnectWithoutInvoiceInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutInvoiceInput | LabOrderUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LabOrderCreateManyInvoiceInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutInvoiceInput | LabOrderUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutInvoiceInput | LabOrderUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<ServiceCreateWithoutLinesInput, ServiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutLinesInput
    connect?: ServiceWhereUniqueInput
  }

  export type InventoryProductCreateNestedOneWithoutLinesInput = {
    create?: XOR<InventoryProductCreateWithoutLinesInput, InventoryProductUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InventoryProductCreateOrConnectWithoutLinesInput
    connect?: InventoryProductWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutLinesInput = {
    create?: XOR<ProviderCreateWithoutLinesInput, ProviderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutLinesInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderCommissionCreateNestedOneWithoutInvoiceLineInput = {
    create?: XOR<ProviderCommissionCreateWithoutInvoiceLineInput, ProviderCommissionUncheckedCreateWithoutInvoiceLineInput>
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutInvoiceLineInput
    connect?: ProviderCommissionWhereUniqueInput
  }

  export type ProviderCommissionUncheckedCreateNestedOneWithoutInvoiceLineInput = {
    create?: XOR<ProviderCommissionCreateWithoutInvoiceLineInput, ProviderCommissionUncheckedCreateWithoutInvoiceLineInput>
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutInvoiceLineInput
    connect?: ProviderCommissionWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type InvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    upsert?: InvoiceUpsertWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLinesInput, InvoiceUpdateWithoutLinesInput>, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type ServiceUpdateOneWithoutLinesNestedInput = {
    create?: XOR<ServiceCreateWithoutLinesInput, ServiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutLinesInput
    upsert?: ServiceUpsertWithoutLinesInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutLinesInput, ServiceUpdateWithoutLinesInput>, ServiceUncheckedUpdateWithoutLinesInput>
  }

  export type InventoryProductUpdateOneWithoutLinesNestedInput = {
    create?: XOR<InventoryProductCreateWithoutLinesInput, InventoryProductUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InventoryProductCreateOrConnectWithoutLinesInput
    upsert?: InventoryProductUpsertWithoutLinesInput
    disconnect?: InventoryProductWhereInput | boolean
    delete?: InventoryProductWhereInput | boolean
    connect?: InventoryProductWhereUniqueInput
    update?: XOR<XOR<InventoryProductUpdateToOneWithWhereWithoutLinesInput, InventoryProductUpdateWithoutLinesInput>, InventoryProductUncheckedUpdateWithoutLinesInput>
  }

  export type ProviderUpdateOneWithoutLinesNestedInput = {
    create?: XOR<ProviderCreateWithoutLinesInput, ProviderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutLinesInput
    upsert?: ProviderUpsertWithoutLinesInput
    disconnect?: ProviderWhereInput | boolean
    delete?: ProviderWhereInput | boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutLinesInput, ProviderUpdateWithoutLinesInput>, ProviderUncheckedUpdateWithoutLinesInput>
  }

  export type ProviderCommissionUpdateOneWithoutInvoiceLineNestedInput = {
    create?: XOR<ProviderCommissionCreateWithoutInvoiceLineInput, ProviderCommissionUncheckedCreateWithoutInvoiceLineInput>
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutInvoiceLineInput
    upsert?: ProviderCommissionUpsertWithoutInvoiceLineInput
    disconnect?: ProviderCommissionWhereInput | boolean
    delete?: ProviderCommissionWhereInput | boolean
    connect?: ProviderCommissionWhereUniqueInput
    update?: XOR<XOR<ProviderCommissionUpdateToOneWithWhereWithoutInvoiceLineInput, ProviderCommissionUpdateWithoutInvoiceLineInput>, ProviderCommissionUncheckedUpdateWithoutInvoiceLineInput>
  }

  export type ProviderCommissionUncheckedUpdateOneWithoutInvoiceLineNestedInput = {
    create?: XOR<ProviderCommissionCreateWithoutInvoiceLineInput, ProviderCommissionUncheckedCreateWithoutInvoiceLineInput>
    connectOrCreate?: ProviderCommissionCreateOrConnectWithoutInvoiceLineInput
    upsert?: ProviderCommissionUpsertWithoutInvoiceLineInput
    disconnect?: ProviderCommissionWhereInput | boolean
    delete?: ProviderCommissionWhereInput | boolean
    connect?: ProviderCommissionWhereUniqueInput
    update?: XOR<XOR<ProviderCommissionUpdateToOneWithWhereWithoutInvoiceLineInput, ProviderCommissionUpdateWithoutInvoiceLineInput>, ProviderCommissionUncheckedUpdateWithoutInvoiceLineInput>
  }

  export type InvoiceLineCreateNestedOneWithoutCommissionInput = {
    create?: XOR<InvoiceLineCreateWithoutCommissionInput, InvoiceLineUncheckedCreateWithoutCommissionInput>
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutCommissionInput
    connect?: InvoiceLineWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<ProviderCreateWithoutCommissionsInput, ProviderUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutCommissionsInput
    connect?: ProviderWhereUniqueInput
  }

  export type InvoiceLineUpdateOneRequiredWithoutCommissionNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutCommissionInput, InvoiceLineUncheckedCreateWithoutCommissionInput>
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutCommissionInput
    upsert?: InvoiceLineUpsertWithoutCommissionInput
    connect?: InvoiceLineWhereUniqueInput
    update?: XOR<XOR<InvoiceLineUpdateToOneWithWhereWithoutCommissionInput, InvoiceLineUpdateWithoutCommissionInput>, InvoiceLineUncheckedUpdateWithoutCommissionInput>
  }

  export type ProviderUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<ProviderCreateWithoutCommissionsInput, ProviderUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutCommissionsInput
    upsert?: ProviderUpsertWithoutCommissionsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutCommissionsInput, ProviderUpdateWithoutCommissionsInput>, ProviderUncheckedUpdateWithoutCommissionsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PosTerminalCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PosTerminalCreateWithoutPaymentsInput, PosTerminalUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PosTerminalCreateOrConnectWithoutPaymentsInput
    connect?: PosTerminalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsCreatedInput = {
    create?: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<RequestContextCreateWithoutPaymentsInput, RequestContextUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutPaymentsInput
    connect?: RequestContextWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableEnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus | null
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type PosTerminalUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<PosTerminalCreateWithoutPaymentsInput, PosTerminalUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PosTerminalCreateOrConnectWithoutPaymentsInput
    upsert?: PosTerminalUpsertWithoutPaymentsInput
    disconnect?: PosTerminalWhereInput | boolean
    delete?: PosTerminalWhereInput | boolean
    connect?: PosTerminalWhereUniqueInput
    update?: XOR<XOR<PosTerminalUpdateToOneWithWhereWithoutPaymentsInput, PosTerminalUpdateWithoutPaymentsInput>, PosTerminalUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsCreatedInput
    upsert?: UserUpsertWithoutPaymentsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsCreatedInput, UserUpdateWithoutPaymentsCreatedInput>, UserUncheckedUpdateWithoutPaymentsCreatedInput>
  }

  export type RequestContextUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<RequestContextCreateWithoutPaymentsInput, RequestContextUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutPaymentsInput
    upsert?: RequestContextUpsertWithoutPaymentsInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutPaymentsInput, RequestContextUpdateWithoutPaymentsInput>, RequestContextUncheckedUpdateWithoutPaymentsInput>
  }

  export type CashRegisterCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CashRegisterCreateWithoutSessionsInput, CashRegisterUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutSessionsInput
    connect?: CashRegisterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashSessionsOpenInput = {
    create?: XOR<UserCreateWithoutCashSessionsOpenInput, UserUncheckedCreateWithoutCashSessionsOpenInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashSessionsOpenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashSessionsCloseInput = {
    create?: XOR<UserCreateWithoutCashSessionsCloseInput, UserUncheckedCreateWithoutCashSessionsCloseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashSessionsCloseInput
    connect?: UserWhereUniqueInput
  }

  export type CashMovementCreateNestedManyWithoutSessionInput = {
    create?: XOR<CashMovementCreateWithoutSessionInput, CashMovementUncheckedCreateWithoutSessionInput> | CashMovementCreateWithoutSessionInput[] | CashMovementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutSessionInput | CashMovementCreateOrConnectWithoutSessionInput[]
    createMany?: CashMovementCreateManySessionInputEnvelope
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type CashMovementUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CashMovementCreateWithoutSessionInput, CashMovementUncheckedCreateWithoutSessionInput> | CashMovementCreateWithoutSessionInput[] | CashMovementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutSessionInput | CashMovementCreateOrConnectWithoutSessionInput[]
    createMany?: CashMovementCreateManySessionInputEnvelope
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
  }

  export type CashRegisterUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<CashRegisterCreateWithoutSessionsInput, CashRegisterUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutSessionsInput
    upsert?: CashRegisterUpsertWithoutSessionsInput
    connect?: CashRegisterWhereUniqueInput
    update?: XOR<XOR<CashRegisterUpdateToOneWithWhereWithoutSessionsInput, CashRegisterUpdateWithoutSessionsInput>, CashRegisterUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutCashSessionsOpenNestedInput = {
    create?: XOR<UserCreateWithoutCashSessionsOpenInput, UserUncheckedCreateWithoutCashSessionsOpenInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashSessionsOpenInput
    upsert?: UserUpsertWithoutCashSessionsOpenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashSessionsOpenInput, UserUpdateWithoutCashSessionsOpenInput>, UserUncheckedUpdateWithoutCashSessionsOpenInput>
  }

  export type UserUpdateOneWithoutCashSessionsCloseNestedInput = {
    create?: XOR<UserCreateWithoutCashSessionsCloseInput, UserUncheckedCreateWithoutCashSessionsCloseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashSessionsCloseInput
    upsert?: UserUpsertWithoutCashSessionsCloseInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashSessionsCloseInput, UserUpdateWithoutCashSessionsCloseInput>, UserUncheckedUpdateWithoutCashSessionsCloseInput>
  }

  export type CashMovementUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CashMovementCreateWithoutSessionInput, CashMovementUncheckedCreateWithoutSessionInput> | CashMovementCreateWithoutSessionInput[] | CashMovementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutSessionInput | CashMovementCreateOrConnectWithoutSessionInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutSessionInput | CashMovementUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CashMovementCreateManySessionInputEnvelope
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutSessionInput | CashMovementUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutSessionInput | CashMovementUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type CashMovementUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CashMovementCreateWithoutSessionInput, CashMovementUncheckedCreateWithoutSessionInput> | CashMovementCreateWithoutSessionInput[] | CashMovementUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CashMovementCreateOrConnectWithoutSessionInput | CashMovementCreateOrConnectWithoutSessionInput[]
    upsert?: CashMovementUpsertWithWhereUniqueWithoutSessionInput | CashMovementUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CashMovementCreateManySessionInputEnvelope
    set?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    disconnect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    delete?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    connect?: CashMovementWhereUniqueInput | CashMovementWhereUniqueInput[]
    update?: CashMovementUpdateWithWhereUniqueWithoutSessionInput | CashMovementUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CashMovementUpdateManyWithWhereWithoutSessionInput | CashMovementUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
  }

  export type CashSessionCreateNestedOneWithoutMovementsInput = {
    create?: XOR<CashSessionCreateWithoutMovementsInput, CashSessionUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: CashSessionCreateOrConnectWithoutMovementsInput
    connect?: CashSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashMovementsInput = {
    create?: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutCashMovesInput = {
    create?: XOR<RequestContextCreateWithoutCashMovesInput, RequestContextUncheckedCreateWithoutCashMovesInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutCashMovesInput
    connect?: RequestContextWhereUniqueInput
  }

  export type EnumCashMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.CashMovementType
  }

  export type CashSessionUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<CashSessionCreateWithoutMovementsInput, CashSessionUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: CashSessionCreateOrConnectWithoutMovementsInput
    upsert?: CashSessionUpsertWithoutMovementsInput
    connect?: CashSessionWhereUniqueInput
    update?: XOR<XOR<CashSessionUpdateToOneWithWhereWithoutMovementsInput, CashSessionUpdateWithoutMovementsInput>, CashSessionUncheckedUpdateWithoutMovementsInput>
  }

  export type UserUpdateOneRequiredWithoutCashMovementsNestedInput = {
    create?: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashMovementsInput
    upsert?: UserUpsertWithoutCashMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashMovementsInput, UserUpdateWithoutCashMovementsInput>, UserUncheckedUpdateWithoutCashMovementsInput>
  }

  export type RequestContextUpdateOneRequiredWithoutCashMovesNestedInput = {
    create?: XOR<RequestContextCreateWithoutCashMovesInput, RequestContextUncheckedCreateWithoutCashMovesInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutCashMovesInput
    upsert?: RequestContextUpsertWithoutCashMovesInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutCashMovesInput, RequestContextUpdateWithoutCashMovesInput>, RequestContextUncheckedUpdateWithoutCashMovesInput>
  }

  export type ProductStockCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type InvoiceLineCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceLineCreateWithoutProductInput, InvoiceLineUncheckedCreateWithoutProductInput> | InvoiceLineCreateWithoutProductInput[] | InvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProductInput | InvoiceLineCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceLineCreateManyProductInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type ProductStockUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceLineCreateWithoutProductInput, InvoiceLineUncheckedCreateWithoutProductInput> | InvoiceLineCreateWithoutProductInput[] | InvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProductInput | InvoiceLineCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceLineCreateManyProductInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type ProductStockUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutProductInput | ProductStockUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutProductInput | ProductStockUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutProductInput | ProductStockUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type InvoiceLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutProductInput, InvoiceLineUncheckedCreateWithoutProductInput> | InvoiceLineCreateWithoutProductInput[] | InvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProductInput | InvoiceLineCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutProductInput | InvoiceLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceLineCreateManyProductInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutProductInput | InvoiceLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutProductInput | InvoiceLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type ProductStockUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutProductInput | ProductStockUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutProductInput | ProductStockUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutProductInput | ProductStockUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutProductInput, InvoiceLineUncheckedCreateWithoutProductInput> | InvoiceLineCreateWithoutProductInput[] | InvoiceLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutProductInput | InvoiceLineCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutProductInput | InvoiceLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceLineCreateManyProductInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutProductInput | InvoiceLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutProductInput | InvoiceLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InventoryProductCreateNestedOneWithoutStockInput = {
    create?: XOR<InventoryProductCreateWithoutStockInput, InventoryProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: InventoryProductCreateOrConnectWithoutStockInput
    connect?: InventoryProductWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutProductStockInput = {
    create?: XOR<LocationCreateWithoutProductStockInput, LocationUncheckedCreateWithoutProductStockInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductStockInput
    connect?: LocationWhereUniqueInput
  }

  export type InventoryProductUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<InventoryProductCreateWithoutStockInput, InventoryProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: InventoryProductCreateOrConnectWithoutStockInput
    upsert?: InventoryProductUpsertWithoutStockInput
    connect?: InventoryProductWhereUniqueInput
    update?: XOR<XOR<InventoryProductUpdateToOneWithWhereWithoutStockInput, InventoryProductUpdateWithoutStockInput>, InventoryProductUncheckedUpdateWithoutStockInput>
  }

  export type LocationUpdateOneRequiredWithoutProductStockNestedInput = {
    create?: XOR<LocationCreateWithoutProductStockInput, LocationUncheckedCreateWithoutProductStockInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductStockInput
    upsert?: LocationUpsertWithoutProductStockInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProductStockInput, LocationUpdateWithoutProductStockInput>, LocationUncheckedUpdateWithoutProductStockInput>
  }

  export type InventoryProductCreateNestedOneWithoutStockMovesInput = {
    create?: XOR<InventoryProductCreateWithoutStockMovesInput, InventoryProductUncheckedCreateWithoutStockMovesInput>
    connectOrCreate?: InventoryProductCreateOrConnectWithoutStockMovesInput
    connect?: InventoryProductWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutStockMovesInput = {
    create?: XOR<LocationCreateWithoutStockMovesInput, LocationUncheckedCreateWithoutStockMovesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockMovesInput
    connect?: LocationWhereUniqueInput
  }

  export type EnumStockReasonFieldUpdateOperationsInput = {
    set?: $Enums.StockReason
  }

  export type InventoryProductUpdateOneRequiredWithoutStockMovesNestedInput = {
    create?: XOR<InventoryProductCreateWithoutStockMovesInput, InventoryProductUncheckedCreateWithoutStockMovesInput>
    connectOrCreate?: InventoryProductCreateOrConnectWithoutStockMovesInput
    upsert?: InventoryProductUpsertWithoutStockMovesInput
    connect?: InventoryProductWhereUniqueInput
    update?: XOR<XOR<InventoryProductUpdateToOneWithWhereWithoutStockMovesInput, InventoryProductUpdateWithoutStockMovesInput>, InventoryProductUncheckedUpdateWithoutStockMovesInput>
  }

  export type LocationUpdateOneRequiredWithoutStockMovesNestedInput = {
    create?: XOR<LocationCreateWithoutStockMovesInput, LocationUncheckedCreateWithoutStockMovesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockMovesInput
    upsert?: LocationUpsertWithoutStockMovesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockMovesInput, LocationUpdateWithoutStockMovesInput>, LocationUncheckedUpdateWithoutStockMovesInput>
  }

  export type LocationCreateNestedOneWithoutLabInstrumentsInput = {
    create?: XOR<LocationCreateWithoutLabInstrumentsInput, LocationUncheckedCreateWithoutLabInstrumentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLabInstrumentsInput
    connect?: LocationWhereUniqueInput
  }

  export type TestCatalogCreateNestedManyWithoutDefaultInstrumentInput = {
    create?: XOR<TestCatalogCreateWithoutDefaultInstrumentInput, TestCatalogUncheckedCreateWithoutDefaultInstrumentInput> | TestCatalogCreateWithoutDefaultInstrumentInput[] | TestCatalogUncheckedCreateWithoutDefaultInstrumentInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutDefaultInstrumentInput | TestCatalogCreateOrConnectWithoutDefaultInstrumentInput[]
    createMany?: TestCatalogCreateManyDefaultInstrumentInputEnvelope
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
  }

  export type LabOrderTestCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<LabOrderTestCreateWithoutInstrumentInput, LabOrderTestUncheckedCreateWithoutInstrumentInput> | LabOrderTestCreateWithoutInstrumentInput[] | LabOrderTestUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutInstrumentInput | LabOrderTestCreateOrConnectWithoutInstrumentInput[]
    createMany?: LabOrderTestCreateManyInstrumentInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type LabDeviceMessageCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<LabDeviceMessageCreateWithoutInstrumentInput, LabDeviceMessageUncheckedCreateWithoutInstrumentInput> | LabDeviceMessageCreateWithoutInstrumentInput[] | LabDeviceMessageUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutInstrumentInput | LabDeviceMessageCreateOrConnectWithoutInstrumentInput[]
    createMany?: LabDeviceMessageCreateManyInstrumentInputEnvelope
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
  }

  export type TestCatalogUncheckedCreateNestedManyWithoutDefaultInstrumentInput = {
    create?: XOR<TestCatalogCreateWithoutDefaultInstrumentInput, TestCatalogUncheckedCreateWithoutDefaultInstrumentInput> | TestCatalogCreateWithoutDefaultInstrumentInput[] | TestCatalogUncheckedCreateWithoutDefaultInstrumentInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutDefaultInstrumentInput | TestCatalogCreateOrConnectWithoutDefaultInstrumentInput[]
    createMany?: TestCatalogCreateManyDefaultInstrumentInputEnvelope
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<LabOrderTestCreateWithoutInstrumentInput, LabOrderTestUncheckedCreateWithoutInstrumentInput> | LabOrderTestCreateWithoutInstrumentInput[] | LabOrderTestUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutInstrumentInput | LabOrderTestCreateOrConnectWithoutInstrumentInput[]
    createMany?: LabOrderTestCreateManyInstrumentInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type LabDeviceMessageUncheckedCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<LabDeviceMessageCreateWithoutInstrumentInput, LabDeviceMessageUncheckedCreateWithoutInstrumentInput> | LabDeviceMessageCreateWithoutInstrumentInput[] | LabDeviceMessageUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutInstrumentInput | LabDeviceMessageCreateOrConnectWithoutInstrumentInput[]
    createMany?: LabDeviceMessageCreateManyInstrumentInputEnvelope
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
  }

  export type NullableEnumConnectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConnectionType | null
  }

  export type LocationUpdateOneWithoutLabInstrumentsNestedInput = {
    create?: XOR<LocationCreateWithoutLabInstrumentsInput, LocationUncheckedCreateWithoutLabInstrumentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLabInstrumentsInput
    upsert?: LocationUpsertWithoutLabInstrumentsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutLabInstrumentsInput, LocationUpdateWithoutLabInstrumentsInput>, LocationUncheckedUpdateWithoutLabInstrumentsInput>
  }

  export type TestCatalogUpdateManyWithoutDefaultInstrumentNestedInput = {
    create?: XOR<TestCatalogCreateWithoutDefaultInstrumentInput, TestCatalogUncheckedCreateWithoutDefaultInstrumentInput> | TestCatalogCreateWithoutDefaultInstrumentInput[] | TestCatalogUncheckedCreateWithoutDefaultInstrumentInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutDefaultInstrumentInput | TestCatalogCreateOrConnectWithoutDefaultInstrumentInput[]
    upsert?: TestCatalogUpsertWithWhereUniqueWithoutDefaultInstrumentInput | TestCatalogUpsertWithWhereUniqueWithoutDefaultInstrumentInput[]
    createMany?: TestCatalogCreateManyDefaultInstrumentInputEnvelope
    set?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    disconnect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    delete?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    update?: TestCatalogUpdateWithWhereUniqueWithoutDefaultInstrumentInput | TestCatalogUpdateWithWhereUniqueWithoutDefaultInstrumentInput[]
    updateMany?: TestCatalogUpdateManyWithWhereWithoutDefaultInstrumentInput | TestCatalogUpdateManyWithWhereWithoutDefaultInstrumentInput[]
    deleteMany?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
  }

  export type LabOrderTestUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutInstrumentInput, LabOrderTestUncheckedCreateWithoutInstrumentInput> | LabOrderTestCreateWithoutInstrumentInput[] | LabOrderTestUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutInstrumentInput | LabOrderTestCreateOrConnectWithoutInstrumentInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutInstrumentInput | LabOrderTestUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: LabOrderTestCreateManyInstrumentInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutInstrumentInput | LabOrderTestUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutInstrumentInput | LabOrderTestUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type LabDeviceMessageUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<LabDeviceMessageCreateWithoutInstrumentInput, LabDeviceMessageUncheckedCreateWithoutInstrumentInput> | LabDeviceMessageCreateWithoutInstrumentInput[] | LabDeviceMessageUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutInstrumentInput | LabDeviceMessageCreateOrConnectWithoutInstrumentInput[]
    upsert?: LabDeviceMessageUpsertWithWhereUniqueWithoutInstrumentInput | LabDeviceMessageUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: LabDeviceMessageCreateManyInstrumentInputEnvelope
    set?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    disconnect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    delete?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    update?: LabDeviceMessageUpdateWithWhereUniqueWithoutInstrumentInput | LabDeviceMessageUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: LabDeviceMessageUpdateManyWithWhereWithoutInstrumentInput | LabDeviceMessageUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: LabDeviceMessageScalarWhereInput | LabDeviceMessageScalarWhereInput[]
  }

  export type TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentNestedInput = {
    create?: XOR<TestCatalogCreateWithoutDefaultInstrumentInput, TestCatalogUncheckedCreateWithoutDefaultInstrumentInput> | TestCatalogCreateWithoutDefaultInstrumentInput[] | TestCatalogUncheckedCreateWithoutDefaultInstrumentInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutDefaultInstrumentInput | TestCatalogCreateOrConnectWithoutDefaultInstrumentInput[]
    upsert?: TestCatalogUpsertWithWhereUniqueWithoutDefaultInstrumentInput | TestCatalogUpsertWithWhereUniqueWithoutDefaultInstrumentInput[]
    createMany?: TestCatalogCreateManyDefaultInstrumentInputEnvelope
    set?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    disconnect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    delete?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    update?: TestCatalogUpdateWithWhereUniqueWithoutDefaultInstrumentInput | TestCatalogUpdateWithWhereUniqueWithoutDefaultInstrumentInput[]
    updateMany?: TestCatalogUpdateManyWithWhereWithoutDefaultInstrumentInput | TestCatalogUpdateManyWithWhereWithoutDefaultInstrumentInput[]
    deleteMany?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
  }

  export type LabOrderTestUncheckedUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutInstrumentInput, LabOrderTestUncheckedCreateWithoutInstrumentInput> | LabOrderTestCreateWithoutInstrumentInput[] | LabOrderTestUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutInstrumentInput | LabOrderTestCreateOrConnectWithoutInstrumentInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutInstrumentInput | LabOrderTestUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: LabOrderTestCreateManyInstrumentInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutInstrumentInput | LabOrderTestUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutInstrumentInput | LabOrderTestUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type LabDeviceMessageUncheckedUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<LabDeviceMessageCreateWithoutInstrumentInput, LabDeviceMessageUncheckedCreateWithoutInstrumentInput> | LabDeviceMessageCreateWithoutInstrumentInput[] | LabDeviceMessageUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutInstrumentInput | LabDeviceMessageCreateOrConnectWithoutInstrumentInput[]
    upsert?: LabDeviceMessageUpsertWithWhereUniqueWithoutInstrumentInput | LabDeviceMessageUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: LabDeviceMessageCreateManyInstrumentInputEnvelope
    set?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    disconnect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    delete?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    update?: LabDeviceMessageUpdateWithWhereUniqueWithoutInstrumentInput | LabDeviceMessageUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: LabDeviceMessageUpdateManyWithWhereWithoutInstrumentInput | LabDeviceMessageUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: LabDeviceMessageScalarWhereInput | LabDeviceMessageScalarWhereInput[]
  }

  export type TestCatalogCreateNestedManyWithoutSpecimenTypeInput = {
    create?: XOR<TestCatalogCreateWithoutSpecimenTypeInput, TestCatalogUncheckedCreateWithoutSpecimenTypeInput> | TestCatalogCreateWithoutSpecimenTypeInput[] | TestCatalogUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutSpecimenTypeInput | TestCatalogCreateOrConnectWithoutSpecimenTypeInput[]
    createMany?: TestCatalogCreateManySpecimenTypeInputEnvelope
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutSpecimenTypeInput = {
    create?: XOR<LabOrderCreateWithoutSpecimenTypeInput, LabOrderUncheckedCreateWithoutSpecimenTypeInput> | LabOrderCreateWithoutSpecimenTypeInput[] | LabOrderUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutSpecimenTypeInput | LabOrderCreateOrConnectWithoutSpecimenTypeInput[]
    createMany?: LabOrderCreateManySpecimenTypeInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type TestCatalogUncheckedCreateNestedManyWithoutSpecimenTypeInput = {
    create?: XOR<TestCatalogCreateWithoutSpecimenTypeInput, TestCatalogUncheckedCreateWithoutSpecimenTypeInput> | TestCatalogCreateWithoutSpecimenTypeInput[] | TestCatalogUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutSpecimenTypeInput | TestCatalogCreateOrConnectWithoutSpecimenTypeInput[]
    createMany?: TestCatalogCreateManySpecimenTypeInputEnvelope
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutSpecimenTypeInput = {
    create?: XOR<LabOrderCreateWithoutSpecimenTypeInput, LabOrderUncheckedCreateWithoutSpecimenTypeInput> | LabOrderCreateWithoutSpecimenTypeInput[] | LabOrderUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutSpecimenTypeInput | LabOrderCreateOrConnectWithoutSpecimenTypeInput[]
    createMany?: LabOrderCreateManySpecimenTypeInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type TestCatalogUpdateManyWithoutSpecimenTypeNestedInput = {
    create?: XOR<TestCatalogCreateWithoutSpecimenTypeInput, TestCatalogUncheckedCreateWithoutSpecimenTypeInput> | TestCatalogCreateWithoutSpecimenTypeInput[] | TestCatalogUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutSpecimenTypeInput | TestCatalogCreateOrConnectWithoutSpecimenTypeInput[]
    upsert?: TestCatalogUpsertWithWhereUniqueWithoutSpecimenTypeInput | TestCatalogUpsertWithWhereUniqueWithoutSpecimenTypeInput[]
    createMany?: TestCatalogCreateManySpecimenTypeInputEnvelope
    set?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    disconnect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    delete?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    update?: TestCatalogUpdateWithWhereUniqueWithoutSpecimenTypeInput | TestCatalogUpdateWithWhereUniqueWithoutSpecimenTypeInput[]
    updateMany?: TestCatalogUpdateManyWithWhereWithoutSpecimenTypeInput | TestCatalogUpdateManyWithWhereWithoutSpecimenTypeInput[]
    deleteMany?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutSpecimenTypeNestedInput = {
    create?: XOR<LabOrderCreateWithoutSpecimenTypeInput, LabOrderUncheckedCreateWithoutSpecimenTypeInput> | LabOrderCreateWithoutSpecimenTypeInput[] | LabOrderUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutSpecimenTypeInput | LabOrderCreateOrConnectWithoutSpecimenTypeInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutSpecimenTypeInput | LabOrderUpsertWithWhereUniqueWithoutSpecimenTypeInput[]
    createMany?: LabOrderCreateManySpecimenTypeInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutSpecimenTypeInput | LabOrderUpdateWithWhereUniqueWithoutSpecimenTypeInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutSpecimenTypeInput | LabOrderUpdateManyWithWhereWithoutSpecimenTypeInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type TestCatalogUncheckedUpdateManyWithoutSpecimenTypeNestedInput = {
    create?: XOR<TestCatalogCreateWithoutSpecimenTypeInput, TestCatalogUncheckedCreateWithoutSpecimenTypeInput> | TestCatalogCreateWithoutSpecimenTypeInput[] | TestCatalogUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutSpecimenTypeInput | TestCatalogCreateOrConnectWithoutSpecimenTypeInput[]
    upsert?: TestCatalogUpsertWithWhereUniqueWithoutSpecimenTypeInput | TestCatalogUpsertWithWhereUniqueWithoutSpecimenTypeInput[]
    createMany?: TestCatalogCreateManySpecimenTypeInputEnvelope
    set?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    disconnect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    delete?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    update?: TestCatalogUpdateWithWhereUniqueWithoutSpecimenTypeInput | TestCatalogUpdateWithWhereUniqueWithoutSpecimenTypeInput[]
    updateMany?: TestCatalogUpdateManyWithWhereWithoutSpecimenTypeInput | TestCatalogUpdateManyWithWhereWithoutSpecimenTypeInput[]
    deleteMany?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutSpecimenTypeNestedInput = {
    create?: XOR<LabOrderCreateWithoutSpecimenTypeInput, LabOrderUncheckedCreateWithoutSpecimenTypeInput> | LabOrderCreateWithoutSpecimenTypeInput[] | LabOrderUncheckedCreateWithoutSpecimenTypeInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutSpecimenTypeInput | LabOrderCreateOrConnectWithoutSpecimenTypeInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutSpecimenTypeInput | LabOrderUpsertWithWhereUniqueWithoutSpecimenTypeInput[]
    createMany?: LabOrderCreateManySpecimenTypeInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutSpecimenTypeInput | LabOrderUpdateWithWhereUniqueWithoutSpecimenTypeInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutSpecimenTypeInput | LabOrderUpdateManyWithWhereWithoutSpecimenTypeInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type SpecimenTypeCreateNestedOneWithoutTestsInput = {
    create?: XOR<SpecimenTypeCreateWithoutTestsInput, SpecimenTypeUncheckedCreateWithoutTestsInput>
    connectOrCreate?: SpecimenTypeCreateOrConnectWithoutTestsInput
    connect?: SpecimenTypeWhereUniqueInput
  }

  export type LabInstrumentCreateNestedOneWithoutTestsDefaultInput = {
    create?: XOR<LabInstrumentCreateWithoutTestsDefaultInput, LabInstrumentUncheckedCreateWithoutTestsDefaultInput>
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutTestsDefaultInput
    connect?: LabInstrumentWhereUniqueInput
  }

  export type TestCatalogCreateNestedOneWithoutPanelMembersInput = {
    create?: XOR<TestCatalogCreateWithoutPanelMembersInput, TestCatalogUncheckedCreateWithoutPanelMembersInput>
    connectOrCreate?: TestCatalogCreateOrConnectWithoutPanelMembersInput
    connect?: TestCatalogWhereUniqueInput
  }

  export type TestCatalogCreateNestedManyWithoutParentPanelInput = {
    create?: XOR<TestCatalogCreateWithoutParentPanelInput, TestCatalogUncheckedCreateWithoutParentPanelInput> | TestCatalogCreateWithoutParentPanelInput[] | TestCatalogUncheckedCreateWithoutParentPanelInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutParentPanelInput | TestCatalogCreateOrConnectWithoutParentPanelInput[]
    createMany?: TestCatalogCreateManyParentPanelInputEnvelope
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
  }

  export type ReferenceRangeCreateNestedManyWithoutTestInput = {
    create?: XOR<ReferenceRangeCreateWithoutTestInput, ReferenceRangeUncheckedCreateWithoutTestInput> | ReferenceRangeCreateWithoutTestInput[] | ReferenceRangeUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ReferenceRangeCreateOrConnectWithoutTestInput | ReferenceRangeCreateOrConnectWithoutTestInput[]
    createMany?: ReferenceRangeCreateManyTestInputEnvelope
    connect?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
  }

  export type LabOrderTestCreateNestedManyWithoutTestInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput = {
    create?: XOR<TestCatalogCreateWithoutParentPanelInput, TestCatalogUncheckedCreateWithoutParentPanelInput> | TestCatalogCreateWithoutParentPanelInput[] | TestCatalogUncheckedCreateWithoutParentPanelInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutParentPanelInput | TestCatalogCreateOrConnectWithoutParentPanelInput[]
    createMany?: TestCatalogCreateManyParentPanelInputEnvelope
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
  }

  export type ReferenceRangeUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<ReferenceRangeCreateWithoutTestInput, ReferenceRangeUncheckedCreateWithoutTestInput> | ReferenceRangeCreateWithoutTestInput[] | ReferenceRangeUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ReferenceRangeCreateOrConnectWithoutTestInput | ReferenceRangeCreateOrConnectWithoutTestInput[]
    createMany?: ReferenceRangeCreateManyTestInputEnvelope
    connect?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type SpecimenTypeUpdateOneWithoutTestsNestedInput = {
    create?: XOR<SpecimenTypeCreateWithoutTestsInput, SpecimenTypeUncheckedCreateWithoutTestsInput>
    connectOrCreate?: SpecimenTypeCreateOrConnectWithoutTestsInput
    upsert?: SpecimenTypeUpsertWithoutTestsInput
    disconnect?: SpecimenTypeWhereInput | boolean
    delete?: SpecimenTypeWhereInput | boolean
    connect?: SpecimenTypeWhereUniqueInput
    update?: XOR<XOR<SpecimenTypeUpdateToOneWithWhereWithoutTestsInput, SpecimenTypeUpdateWithoutTestsInput>, SpecimenTypeUncheckedUpdateWithoutTestsInput>
  }

  export type LabInstrumentUpdateOneWithoutTestsDefaultNestedInput = {
    create?: XOR<LabInstrumentCreateWithoutTestsDefaultInput, LabInstrumentUncheckedCreateWithoutTestsDefaultInput>
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutTestsDefaultInput
    upsert?: LabInstrumentUpsertWithoutTestsDefaultInput
    disconnect?: LabInstrumentWhereInput | boolean
    delete?: LabInstrumentWhereInput | boolean
    connect?: LabInstrumentWhereUniqueInput
    update?: XOR<XOR<LabInstrumentUpdateToOneWithWhereWithoutTestsDefaultInput, LabInstrumentUpdateWithoutTestsDefaultInput>, LabInstrumentUncheckedUpdateWithoutTestsDefaultInput>
  }

  export type TestCatalogUpdateOneWithoutPanelMembersNestedInput = {
    create?: XOR<TestCatalogCreateWithoutPanelMembersInput, TestCatalogUncheckedCreateWithoutPanelMembersInput>
    connectOrCreate?: TestCatalogCreateOrConnectWithoutPanelMembersInput
    upsert?: TestCatalogUpsertWithoutPanelMembersInput
    disconnect?: TestCatalogWhereInput | boolean
    delete?: TestCatalogWhereInput | boolean
    connect?: TestCatalogWhereUniqueInput
    update?: XOR<XOR<TestCatalogUpdateToOneWithWhereWithoutPanelMembersInput, TestCatalogUpdateWithoutPanelMembersInput>, TestCatalogUncheckedUpdateWithoutPanelMembersInput>
  }

  export type TestCatalogUpdateManyWithoutParentPanelNestedInput = {
    create?: XOR<TestCatalogCreateWithoutParentPanelInput, TestCatalogUncheckedCreateWithoutParentPanelInput> | TestCatalogCreateWithoutParentPanelInput[] | TestCatalogUncheckedCreateWithoutParentPanelInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutParentPanelInput | TestCatalogCreateOrConnectWithoutParentPanelInput[]
    upsert?: TestCatalogUpsertWithWhereUniqueWithoutParentPanelInput | TestCatalogUpsertWithWhereUniqueWithoutParentPanelInput[]
    createMany?: TestCatalogCreateManyParentPanelInputEnvelope
    set?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    disconnect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    delete?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    update?: TestCatalogUpdateWithWhereUniqueWithoutParentPanelInput | TestCatalogUpdateWithWhereUniqueWithoutParentPanelInput[]
    updateMany?: TestCatalogUpdateManyWithWhereWithoutParentPanelInput | TestCatalogUpdateManyWithWhereWithoutParentPanelInput[]
    deleteMany?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
  }

  export type ReferenceRangeUpdateManyWithoutTestNestedInput = {
    create?: XOR<ReferenceRangeCreateWithoutTestInput, ReferenceRangeUncheckedCreateWithoutTestInput> | ReferenceRangeCreateWithoutTestInput[] | ReferenceRangeUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ReferenceRangeCreateOrConnectWithoutTestInput | ReferenceRangeCreateOrConnectWithoutTestInput[]
    upsert?: ReferenceRangeUpsertWithWhereUniqueWithoutTestInput | ReferenceRangeUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ReferenceRangeCreateManyTestInputEnvelope
    set?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    disconnect?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    delete?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    connect?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    update?: ReferenceRangeUpdateWithWhereUniqueWithoutTestInput | ReferenceRangeUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ReferenceRangeUpdateManyWithWhereWithoutTestInput | ReferenceRangeUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ReferenceRangeScalarWhereInput | ReferenceRangeScalarWhereInput[]
  }

  export type LabOrderTestUpdateManyWithoutTestNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutTestInput | LabOrderTestUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutTestInput | LabOrderTestUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutTestInput | LabOrderTestUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput = {
    create?: XOR<TestCatalogCreateWithoutParentPanelInput, TestCatalogUncheckedCreateWithoutParentPanelInput> | TestCatalogCreateWithoutParentPanelInput[] | TestCatalogUncheckedCreateWithoutParentPanelInput[]
    connectOrCreate?: TestCatalogCreateOrConnectWithoutParentPanelInput | TestCatalogCreateOrConnectWithoutParentPanelInput[]
    upsert?: TestCatalogUpsertWithWhereUniqueWithoutParentPanelInput | TestCatalogUpsertWithWhereUniqueWithoutParentPanelInput[]
    createMany?: TestCatalogCreateManyParentPanelInputEnvelope
    set?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    disconnect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    delete?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    connect?: TestCatalogWhereUniqueInput | TestCatalogWhereUniqueInput[]
    update?: TestCatalogUpdateWithWhereUniqueWithoutParentPanelInput | TestCatalogUpdateWithWhereUniqueWithoutParentPanelInput[]
    updateMany?: TestCatalogUpdateManyWithWhereWithoutParentPanelInput | TestCatalogUpdateManyWithWhereWithoutParentPanelInput[]
    deleteMany?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
  }

  export type ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<ReferenceRangeCreateWithoutTestInput, ReferenceRangeUncheckedCreateWithoutTestInput> | ReferenceRangeCreateWithoutTestInput[] | ReferenceRangeUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ReferenceRangeCreateOrConnectWithoutTestInput | ReferenceRangeCreateOrConnectWithoutTestInput[]
    upsert?: ReferenceRangeUpsertWithWhereUniqueWithoutTestInput | ReferenceRangeUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ReferenceRangeCreateManyTestInputEnvelope
    set?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    disconnect?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    delete?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    connect?: ReferenceRangeWhereUniqueInput | ReferenceRangeWhereUniqueInput[]
    update?: ReferenceRangeUpdateWithWhereUniqueWithoutTestInput | ReferenceRangeUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ReferenceRangeUpdateManyWithWhereWithoutTestInput | ReferenceRangeUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ReferenceRangeScalarWhereInput | ReferenceRangeScalarWhereInput[]
  }

  export type LabOrderTestUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutTestInput | LabOrderTestUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutTestInput | LabOrderTestUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutTestInput | LabOrderTestUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type TestCatalogCreateNestedOneWithoutRangesInput = {
    create?: XOR<TestCatalogCreateWithoutRangesInput, TestCatalogUncheckedCreateWithoutRangesInput>
    connectOrCreate?: TestCatalogCreateOrConnectWithoutRangesInput
    connect?: TestCatalogWhereUniqueInput
  }

  export type TestCatalogUpdateOneRequiredWithoutRangesNestedInput = {
    create?: XOR<TestCatalogCreateWithoutRangesInput, TestCatalogUncheckedCreateWithoutRangesInput>
    connectOrCreate?: TestCatalogCreateOrConnectWithoutRangesInput
    upsert?: TestCatalogUpsertWithoutRangesInput
    connect?: TestCatalogWhereUniqueInput
    update?: XOR<XOR<TestCatalogUpdateToOneWithWhereWithoutRangesInput, TestCatalogUpdateWithoutRangesInput>, TestCatalogUncheckedUpdateWithoutRangesInput>
  }

  export type PatientCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabOrdersInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLabOrdersOrderedInput = {
    create?: XOR<UserCreateWithoutLabOrdersOrderedInput, UserUncheckedCreateWithoutLabOrdersOrderedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabOrdersOrderedInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<InvoiceCreateWithoutLabOrdersInput, InvoiceUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLabOrdersInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PreclinicCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<PreclinicCreateWithoutLabOrdersInput, PreclinicUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: PreclinicCreateOrConnectWithoutLabOrdersInput
    connect?: PreclinicWhereUniqueInput
  }

  export type SpecimenTypeCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SpecimenTypeCreateWithoutOrdersInput, SpecimenTypeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SpecimenTypeCreateOrConnectWithoutOrdersInput
    connect?: SpecimenTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLabOrdersCollectedInput = {
    create?: XOR<UserCreateWithoutLabOrdersCollectedInput, UserUncheckedCreateWithoutLabOrdersCollectedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabOrdersCollectedInput
    connect?: UserWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<RequestContextCreateWithoutLabOrdersInput, RequestContextUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutLabOrdersInput
    connect?: RequestContextWhereUniqueInput
  }

  export type LabOrderTestCreateNestedManyWithoutOrderInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type LabDeviceMessageCreateNestedManyWithoutOrderInput = {
    create?: XOR<LabDeviceMessageCreateWithoutOrderInput, LabDeviceMessageUncheckedCreateWithoutOrderInput> | LabDeviceMessageCreateWithoutOrderInput[] | LabDeviceMessageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutOrderInput | LabDeviceMessageCreateOrConnectWithoutOrderInput[]
    createMany?: LabDeviceMessageCreateManyOrderInputEnvelope
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<LabDeviceMessageCreateWithoutOrderInput, LabDeviceMessageUncheckedCreateWithoutOrderInput> | LabDeviceMessageCreateWithoutOrderInput[] | LabDeviceMessageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutOrderInput | LabDeviceMessageCreateOrConnectWithoutOrderInput[]
    createMany?: LabDeviceMessageCreateManyOrderInputEnvelope
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
  }

  export type NullableEnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority | null
  }

  export type EnumLabOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabOrderStatus
  }

  export type PatientUpdateOneRequiredWithoutLabOrdersNestedInput = {
    create?: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabOrdersInput
    upsert?: PatientUpsertWithoutLabOrdersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLabOrdersInput, PatientUpdateWithoutLabOrdersInput>, PatientUncheckedUpdateWithoutLabOrdersInput>
  }

  export type UserUpdateOneWithoutLabOrdersOrderedNestedInput = {
    create?: XOR<UserCreateWithoutLabOrdersOrderedInput, UserUncheckedCreateWithoutLabOrdersOrderedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabOrdersOrderedInput
    upsert?: UserUpsertWithoutLabOrdersOrderedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabOrdersOrderedInput, UserUpdateWithoutLabOrdersOrderedInput>, UserUncheckedUpdateWithoutLabOrdersOrderedInput>
  }

  export type InvoiceUpdateOneWithoutLabOrdersNestedInput = {
    create?: XOR<InvoiceCreateWithoutLabOrdersInput, InvoiceUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLabOrdersInput
    upsert?: InvoiceUpsertWithoutLabOrdersInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLabOrdersInput, InvoiceUpdateWithoutLabOrdersInput>, InvoiceUncheckedUpdateWithoutLabOrdersInput>
  }

  export type PreclinicUpdateOneWithoutLabOrdersNestedInput = {
    create?: XOR<PreclinicCreateWithoutLabOrdersInput, PreclinicUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: PreclinicCreateOrConnectWithoutLabOrdersInput
    upsert?: PreclinicUpsertWithoutLabOrdersInput
    disconnect?: PreclinicWhereInput | boolean
    delete?: PreclinicWhereInput | boolean
    connect?: PreclinicWhereUniqueInput
    update?: XOR<XOR<PreclinicUpdateToOneWithWhereWithoutLabOrdersInput, PreclinicUpdateWithoutLabOrdersInput>, PreclinicUncheckedUpdateWithoutLabOrdersInput>
  }

  export type SpecimenTypeUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<SpecimenTypeCreateWithoutOrdersInput, SpecimenTypeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SpecimenTypeCreateOrConnectWithoutOrdersInput
    upsert?: SpecimenTypeUpsertWithoutOrdersInput
    disconnect?: SpecimenTypeWhereInput | boolean
    delete?: SpecimenTypeWhereInput | boolean
    connect?: SpecimenTypeWhereUniqueInput
    update?: XOR<XOR<SpecimenTypeUpdateToOneWithWhereWithoutOrdersInput, SpecimenTypeUpdateWithoutOrdersInput>, SpecimenTypeUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneWithoutLabOrdersCollectedNestedInput = {
    create?: XOR<UserCreateWithoutLabOrdersCollectedInput, UserUncheckedCreateWithoutLabOrdersCollectedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabOrdersCollectedInput
    upsert?: UserUpsertWithoutLabOrdersCollectedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabOrdersCollectedInput, UserUpdateWithoutLabOrdersCollectedInput>, UserUncheckedUpdateWithoutLabOrdersCollectedInput>
  }

  export type RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput = {
    create?: XOR<RequestContextCreateWithoutLabOrdersInput, RequestContextUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutLabOrdersInput
    upsert?: RequestContextUpsertWithoutLabOrdersInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutLabOrdersInput, RequestContextUpdateWithoutLabOrdersInput>, RequestContextUncheckedUpdateWithoutLabOrdersInput>
  }

  export type LabOrderTestUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutOrderInput | LabOrderTestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutOrderInput | LabOrderTestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutOrderInput | LabOrderTestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type LabDeviceMessageUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LabDeviceMessageCreateWithoutOrderInput, LabDeviceMessageUncheckedCreateWithoutOrderInput> | LabDeviceMessageCreateWithoutOrderInput[] | LabDeviceMessageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutOrderInput | LabDeviceMessageCreateOrConnectWithoutOrderInput[]
    upsert?: LabDeviceMessageUpsertWithWhereUniqueWithoutOrderInput | LabDeviceMessageUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LabDeviceMessageCreateManyOrderInputEnvelope
    set?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    disconnect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    delete?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    update?: LabDeviceMessageUpdateWithWhereUniqueWithoutOrderInput | LabDeviceMessageUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LabDeviceMessageUpdateManyWithWhereWithoutOrderInput | LabDeviceMessageUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LabDeviceMessageScalarWhereInput | LabDeviceMessageScalarWhereInput[]
  }

  export type LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutOrderInput | LabOrderTestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutOrderInput | LabOrderTestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutOrderInput | LabOrderTestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LabDeviceMessageCreateWithoutOrderInput, LabDeviceMessageUncheckedCreateWithoutOrderInput> | LabDeviceMessageCreateWithoutOrderInput[] | LabDeviceMessageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabDeviceMessageCreateOrConnectWithoutOrderInput | LabDeviceMessageCreateOrConnectWithoutOrderInput[]
    upsert?: LabDeviceMessageUpsertWithWhereUniqueWithoutOrderInput | LabDeviceMessageUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LabDeviceMessageCreateManyOrderInputEnvelope
    set?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    disconnect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    delete?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    connect?: LabDeviceMessageWhereUniqueInput | LabDeviceMessageWhereUniqueInput[]
    update?: LabDeviceMessageUpdateWithWhereUniqueWithoutOrderInput | LabDeviceMessageUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LabDeviceMessageUpdateManyWithWhereWithoutOrderInput | LabDeviceMessageUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LabDeviceMessageScalarWhereInput | LabDeviceMessageScalarWhereInput[]
  }

  export type LabOrderCreateNestedOneWithoutTestsInput = {
    create?: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
    connectOrCreate?: LabOrderCreateOrConnectWithoutTestsInput
    connect?: LabOrderWhereUniqueInput
  }

  export type TestCatalogCreateNestedOneWithoutOrderTestsInput = {
    create?: XOR<TestCatalogCreateWithoutOrderTestsInput, TestCatalogUncheckedCreateWithoutOrderTestsInput>
    connectOrCreate?: TestCatalogCreateOrConnectWithoutOrderTestsInput
    connect?: TestCatalogWhereUniqueInput
  }

  export type LabInstrumentCreateNestedOneWithoutOrderTestsInput = {
    create?: XOR<LabInstrumentCreateWithoutOrderTestsInput, LabInstrumentUncheckedCreateWithoutOrderTestsInput>
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutOrderTestsInput
    connect?: LabInstrumentWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutLabOrderTestsInput = {
    create?: XOR<RequestContextCreateWithoutLabOrderTestsInput, RequestContextUncheckedCreateWithoutLabOrderTestsInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutLabOrderTestsInput
    connect?: RequestContextWhereUniqueInput
  }

  export type EnumLabOrderTestStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabOrderTestStatus
  }

  export type NullableEnumAbnormalFlagFieldUpdateOperationsInput = {
    set?: $Enums.AbnormalFlag | null
  }

  export type NullableEnumOutOfRangeFlagFieldUpdateOperationsInput = {
    set?: $Enums.OutOfRangeFlag | null
  }

  export type LabOrderUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
    connectOrCreate?: LabOrderCreateOrConnectWithoutTestsInput
    upsert?: LabOrderUpsertWithoutTestsInput
    connect?: LabOrderWhereUniqueInput
    update?: XOR<XOR<LabOrderUpdateToOneWithWhereWithoutTestsInput, LabOrderUpdateWithoutTestsInput>, LabOrderUncheckedUpdateWithoutTestsInput>
  }

  export type TestCatalogUpdateOneRequiredWithoutOrderTestsNestedInput = {
    create?: XOR<TestCatalogCreateWithoutOrderTestsInput, TestCatalogUncheckedCreateWithoutOrderTestsInput>
    connectOrCreate?: TestCatalogCreateOrConnectWithoutOrderTestsInput
    upsert?: TestCatalogUpsertWithoutOrderTestsInput
    connect?: TestCatalogWhereUniqueInput
    update?: XOR<XOR<TestCatalogUpdateToOneWithWhereWithoutOrderTestsInput, TestCatalogUpdateWithoutOrderTestsInput>, TestCatalogUncheckedUpdateWithoutOrderTestsInput>
  }

  export type LabInstrumentUpdateOneWithoutOrderTestsNestedInput = {
    create?: XOR<LabInstrumentCreateWithoutOrderTestsInput, LabInstrumentUncheckedCreateWithoutOrderTestsInput>
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutOrderTestsInput
    upsert?: LabInstrumentUpsertWithoutOrderTestsInput
    disconnect?: LabInstrumentWhereInput | boolean
    delete?: LabInstrumentWhereInput | boolean
    connect?: LabInstrumentWhereUniqueInput
    update?: XOR<XOR<LabInstrumentUpdateToOneWithWhereWithoutOrderTestsInput, LabInstrumentUpdateWithoutOrderTestsInput>, LabInstrumentUncheckedUpdateWithoutOrderTestsInput>
  }

  export type RequestContextUpdateOneRequiredWithoutLabOrderTestsNestedInput = {
    create?: XOR<RequestContextCreateWithoutLabOrderTestsInput, RequestContextUncheckedCreateWithoutLabOrderTestsInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutLabOrderTestsInput
    upsert?: RequestContextUpsertWithoutLabOrderTestsInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutLabOrderTestsInput, RequestContextUpdateWithoutLabOrderTestsInput>, RequestContextUncheckedUpdateWithoutLabOrderTestsInput>
  }

  export type LabInstrumentCreateNestedOneWithoutMessagesInput = {
    create?: XOR<LabInstrumentCreateWithoutMessagesInput, LabInstrumentUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutMessagesInput
    connect?: LabInstrumentWhereUniqueInput
  }

  export type LabOrderCreateNestedOneWithoutMessagesInput = {
    create?: XOR<LabOrderCreateWithoutMessagesInput, LabOrderUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LabOrderCreateOrConnectWithoutMessagesInput
    connect?: LabOrderWhereUniqueInput
  }

  export type NullableEnumProtocolKindFieldUpdateOperationsInput = {
    set?: $Enums.ProtocolKind | null
  }

  export type LabInstrumentUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<LabInstrumentCreateWithoutMessagesInput, LabInstrumentUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LabInstrumentCreateOrConnectWithoutMessagesInput
    upsert?: LabInstrumentUpsertWithoutMessagesInput
    connect?: LabInstrumentWhereUniqueInput
    update?: XOR<XOR<LabInstrumentUpdateToOneWithWhereWithoutMessagesInput, LabInstrumentUpdateWithoutMessagesInput>, LabInstrumentUncheckedUpdateWithoutMessagesInput>
  }

  export type LabOrderUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<LabOrderCreateWithoutMessagesInput, LabOrderUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LabOrderCreateOrConnectWithoutMessagesInput
    upsert?: LabOrderUpsertWithoutMessagesInput
    disconnect?: LabOrderWhereInput | boolean
    delete?: LabOrderWhereInput | boolean
    connect?: LabOrderWhereUniqueInput
    update?: XOR<XOR<LabOrderUpdateToOneWithWhereWithoutMessagesInput, LabOrderUpdateWithoutMessagesInput>, LabOrderUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutActivityInput = {
    create?: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityInput
    connect?: UserWhereUniqueInput
  }

  export type RequestContextCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<RequestContextCreateWithoutActivitiesInput, RequestContextUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutActivitiesInput
    connect?: RequestContextWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityNestedInput = {
    create?: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityInput
    upsert?: UserUpsertWithoutActivityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityInput, UserUpdateWithoutActivityInput>, UserUncheckedUpdateWithoutActivityInput>
  }

  export type RequestContextUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<RequestContextCreateWithoutActivitiesInput, RequestContextUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: RequestContextCreateOrConnectWithoutActivitiesInput
    upsert?: RequestContextUpsertWithoutActivitiesInput
    connect?: RequestContextWhereUniqueInput
    update?: XOR<XOR<RequestContextUpdateToOneWithWhereWithoutActivitiesInput, RequestContextUpdateWithoutActivitiesInput>, RequestContextUncheckedUpdateWithoutActivitiesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumWorkstationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkstationType | EnumWorkstationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkstationTypeFilter<$PrismaModel> | $Enums.WorkstationType
  }

  export type NestedEnumWorkstationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkstationType | EnumWorkstationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkstationType[] | ListEnumWorkstationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkstationTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkstationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkstationTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkstationTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSexNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableFilter<$PrismaModel> | $Enums.Sex | null
  }

  export type NestedEnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSexNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sex | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexNullableFilter<$PrismaModel>
    _max?: NestedEnumSexNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumAllergySeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergySeverity | EnumAllergySeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAllergySeverityNullableFilter<$PrismaModel> | $Enums.AllergySeverity | null
  }

  export type NestedEnumAllergySeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergySeverity | EnumAllergySeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AllergySeverity[] | ListEnumAllergySeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAllergySeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.AllergySeverity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAllergySeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumAllergySeverityNullableFilter<$PrismaModel>
  }

  export type NestedEnumProblemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProblemStatus | EnumProblemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProblemStatusFilter<$PrismaModel> | $Enums.ProblemStatus
  }

  export type NestedEnumProblemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProblemStatus | EnumProblemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProblemStatus[] | ListEnumProblemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProblemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProblemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProblemStatusFilter<$PrismaModel>
    _max?: NestedEnumProblemStatusFilter<$PrismaModel>
  }

  export type NestedEnumRouteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Route | EnumRouteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRouteNullableFilter<$PrismaModel> | $Enums.Route | null
  }

  export type NestedEnumRouteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Route | EnumRouteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Route[] | ListEnumRouteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRouteNullableWithAggregatesFilter<$PrismaModel> | $Enums.Route | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRouteNullableFilter<$PrismaModel>
    _max?: NestedEnumRouteNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransferStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransferStatusNullableFilter<$PrismaModel> | $Enums.TransferStatus | null
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransferStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCashMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashMovementType | EnumCashMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashMovementTypeFilter<$PrismaModel> | $Enums.CashMovementType
  }

  export type NestedEnumCashMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashMovementType | EnumCashMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashMovementType[] | ListEnumCashMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumCashMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumStockReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.StockReason | EnumStockReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStockReasonFilter<$PrismaModel> | $Enums.StockReason
  }

  export type NestedEnumStockReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockReason | EnumStockReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockReason[] | ListEnumStockReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStockReasonWithAggregatesFilter<$PrismaModel> | $Enums.StockReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockReasonFilter<$PrismaModel>
    _max?: NestedEnumStockReasonFilter<$PrismaModel>
  }

  export type NestedEnumConnectionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConnectionTypeNullableFilter<$PrismaModel> | $Enums.ConnectionType | null
  }

  export type NestedEnumConnectionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConnectionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConnectionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumConnectionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type NestedEnumLabOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusFilter<$PrismaModel> | $Enums.LabOrderStatus
  }

  export type NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type NestedEnumLabOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumLabOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumLabOrderTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderTestStatus | EnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderTestStatusFilter<$PrismaModel> | $Enums.LabOrderTestStatus
  }

  export type NestedEnumAbnormalFlagNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AbnormalFlag | EnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbnormalFlagNullableFilter<$PrismaModel> | $Enums.AbnormalFlag | null
  }

  export type NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OutOfRangeFlag | EnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel> | $Enums.OutOfRangeFlag | null
  }

  export type NestedEnumLabOrderTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderTestStatus | EnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderTestStatus[] | ListEnumLabOrderTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabOrderTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabOrderTestStatusFilter<$PrismaModel>
    _max?: NestedEnumLabOrderTestStatusFilter<$PrismaModel>
  }

  export type NestedEnumAbnormalFlagNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbnormalFlag | EnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AbnormalFlag[] | ListEnumAbnormalFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbnormalFlagNullableWithAggregatesFilter<$PrismaModel> | $Enums.AbnormalFlag | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAbnormalFlagNullableFilter<$PrismaModel>
    _max?: NestedEnumAbnormalFlagNullableFilter<$PrismaModel>
  }

  export type NestedEnumOutOfRangeFlagNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutOfRangeFlag | EnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    in?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OutOfRangeFlag[] | ListEnumOutOfRangeFlagFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOutOfRangeFlagNullableWithAggregatesFilter<$PrismaModel> | $Enums.OutOfRangeFlag | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel>
    _max?: NestedEnumOutOfRangeFlagNullableFilter<$PrismaModel>
  }

  export type NestedEnumProtocolKindNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProtocolKind | EnumProtocolKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProtocolKindNullableFilter<$PrismaModel> | $Enums.ProtocolKind | null
  }

  export type NestedEnumProtocolKindNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProtocolKind | EnumProtocolKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProtocolKind[] | ListEnumProtocolKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProtocolKindNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProtocolKind | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProtocolKindNullableFilter<$PrismaModel>
    _max?: NestedEnumProtocolKindNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthSessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    workstation?: WorkstationCreateNestedOneWithoutSessionsInput
    contexts?: RequestContextCreateNestedManyWithoutSessionInput
  }

  export type AuthSessionUncheckedCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    contexts?: RequestContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AuthSessionCreateOrConnectWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionCreateManyUserInputEnvelope = {
    data: AuthSessionCreateManyUserInput | AuthSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutCreatedByInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutCreatedByInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput>
  }

  export type PatientCreateManyCreatedByInputEnvelope = {
    data: PatientCreateManyCreatedByInput | PatientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PreclinicCreateWithoutRecordedByInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    patient: PatientCreateNestedOneWithoutPreclinicsInput
    labOrders?: LabOrderCreateNestedManyWithoutPreclinicInput
    requestContext: RequestContextCreateNestedOneWithoutPreclinicsInput
    invoices?: InvoiceCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicUncheckedCreateWithoutRecordedByInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    requestContextId: string
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPreclinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicCreateOrConnectWithoutRecordedByInput = {
    where: PreclinicWhereUniqueInput
    create: XOR<PreclinicCreateWithoutRecordedByInput, PreclinicUncheckedCreateWithoutRecordedByInput>
  }

  export type PreclinicCreateManyRecordedByInputEnvelope = {
    data: PreclinicCreateManyRecordedByInput | PreclinicCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type ProblemCreateWithoutRecordedByInput = {
    id?: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutProblemsInput
  }

  export type ProblemUncheckedCreateWithoutRecordedByInput = {
    id?: string
    patientId: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
  }

  export type ProblemCreateOrConnectWithoutRecordedByInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutRecordedByInput, ProblemUncheckedCreateWithoutRecordedByInput>
  }

  export type ProblemCreateManyRecordedByInputEnvelope = {
    data: ProblemCreateManyRecordedByInput | ProblemCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type AllergyCreateWithoutRecordedByInput = {
    id?: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAllergiesInput
  }

  export type AllergyUncheckedCreateWithoutRecordedByInput = {
    id?: string
    patientId: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
  }

  export type AllergyCreateOrConnectWithoutRecordedByInput = {
    where: AllergyWhereUniqueInput
    create: XOR<AllergyCreateWithoutRecordedByInput, AllergyUncheckedCreateWithoutRecordedByInput>
  }

  export type AllergyCreateManyRecordedByInputEnvelope = {
    data: AllergyCreateManyRecordedByInput | AllergyCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type MedicationCreateWithoutPrescribedByInput = {
    id?: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationUncheckedCreateWithoutPrescribedByInput = {
    id?: string
    patientId: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
  }

  export type MedicationCreateOrConnectWithoutPrescribedByInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutPrescribedByInput, MedicationUncheckedCreateWithoutPrescribedByInput>
  }

  export type MedicationCreateManyPrescribedByInputEnvelope = {
    data: MedicationCreateManyPrescribedByInput | MedicationCreateManyPrescribedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCashierInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCashierInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCashierInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCashierInput, InvoiceUncheckedCreateWithoutCashierInput>
  }

  export type InvoiceCreateManyCashierInputEnvelope = {
    data: InvoiceCreateManyCashierInput | InvoiceCreateManyCashierInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCreatedByInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    posTerminal?: PosTerminalCreateNestedOneWithoutPaymentsInput
    requestContext: RequestContextCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    requestContextId: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput>
  }

  export type PaymentCreateManyCreatedByInputEnvelope = {
    data: PaymentCreateManyCreatedByInput | PaymentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CashSessionCreateWithoutOpenedByInput = {
    id?: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    register: CashRegisterCreateNestedOneWithoutSessionsInput
    closedBy?: UserCreateNestedOneWithoutCashSessionsCloseInput
    movements?: CashMovementCreateNestedManyWithoutSessionInput
  }

  export type CashSessionUncheckedCreateWithoutOpenedByInput = {
    id?: string
    registerId: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CashSessionCreateOrConnectWithoutOpenedByInput = {
    where: CashSessionWhereUniqueInput
    create: XOR<CashSessionCreateWithoutOpenedByInput, CashSessionUncheckedCreateWithoutOpenedByInput>
  }

  export type CashSessionCreateManyOpenedByInputEnvelope = {
    data: CashSessionCreateManyOpenedByInput | CashSessionCreateManyOpenedByInput[]
    skipDuplicates?: boolean
  }

  export type CashSessionCreateWithoutClosedByInput = {
    id?: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    register: CashRegisterCreateNestedOneWithoutSessionsInput
    openedBy: UserCreateNestedOneWithoutCashSessionsOpenInput
    movements?: CashMovementCreateNestedManyWithoutSessionInput
  }

  export type CashSessionUncheckedCreateWithoutClosedByInput = {
    id?: string
    registerId: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CashSessionCreateOrConnectWithoutClosedByInput = {
    where: CashSessionWhereUniqueInput
    create: XOR<CashSessionCreateWithoutClosedByInput, CashSessionUncheckedCreateWithoutClosedByInput>
  }

  export type CashSessionCreateManyClosedByInputEnvelope = {
    data: CashSessionCreateManyClosedByInput | CashSessionCreateManyClosedByInput[]
    skipDuplicates?: boolean
  }

  export type CashMovementCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    session: CashSessionCreateNestedOneWithoutMovementsInput
    requestContext: RequestContextCreateNestedOneWithoutCashMovesInput
  }

  export type CashMovementUncheckedCreateWithoutCreatedByInput = {
    id?: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    requestContextId: string
    createdAt?: Date | string
  }

  export type CashMovementCreateOrConnectWithoutCreatedByInput = {
    where: CashMovementWhereUniqueInput
    create: XOR<CashMovementCreateWithoutCreatedByInput, CashMovementUncheckedCreateWithoutCreatedByInput>
  }

  export type CashMovementCreateManyCreatedByInputEnvelope = {
    data: CashMovementCreateManyCreatedByInput | CashMovementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutOrderingProviderInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutOrderingProviderInput = {
    id?: string
    accessionNo: string
    patientId: string
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutOrderingProviderInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutOrderingProviderInput, LabOrderUncheckedCreateWithoutOrderingProviderInput>
  }

  export type LabOrderCreateManyOrderingProviderInputEnvelope = {
    data: LabOrderCreateManyOrderingProviderInput | LabOrderCreateManyOrderingProviderInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutCollectedByInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutCollectedByInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutCollectedByInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutCollectedByInput, LabOrderUncheckedCreateWithoutCollectedByInput>
  }

  export type LabOrderCreateManyCollectedByInputEnvelope = {
    data: LabOrderCreateManyCollectedByInput | LabOrderCreateManyCollectedByInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutActorInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    requestContext: RequestContextCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityLogUncheckedCreateWithoutActorInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    requestContextId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutActorInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutActorInput, ActivityLogUncheckedCreateWithoutActorInput>
  }

  export type ActivityLogCreateManyActorInputEnvelope = {
    data: ActivityLogCreateManyActorInput | ActivityLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    update: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    data: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
  }

  export type AuthSessionUpdateManyWithWhereWithoutUserInput = {
    where: AuthSessionScalarWhereInput
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthSessionScalarWhereInput = {
    AND?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    OR?: AuthSessionScalarWhereInput[]
    NOT?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    id?: UuidFilter<"AuthSession"> | string
    userId?: UuidFilter<"AuthSession"> | string
    startedAt?: DateTimeFilter<"AuthSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"AuthSession"> | Date | string | null
    ipAddress?: StringFilter<"AuthSession"> | string
    userAgent?: StringFilter<"AuthSession"> | string
    deviceFingerprint?: StringNullableFilter<"AuthSession"> | string | null
    workstationId?: UuidNullableFilter<"AuthSession"> | string | null
    geoCountry?: StringNullableFilter<"AuthSession"> | string | null
    geoRegion?: StringNullableFilter<"AuthSession"> | string | null
    geoCity?: StringNullableFilter<"AuthSession"> | string | null
    geoLat?: DecimalNullableFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableFilter<"AuthSession"> | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFilter<"AuthSession"> | boolean
  }

  export type PatientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutCreatedByInput, PatientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PatientCreateWithoutCreatedByInput, PatientUncheckedCreateWithoutCreatedByInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutCreatedByInput, PatientUncheckedUpdateWithoutCreatedByInput>
  }

  export type PatientUpdateManyWithWhereWithoutCreatedByInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: UuidFilter<"Patient"> | string
    mrn?: StringFilter<"Patient"> | string
    nationalId?: StringNullableFilter<"Patient"> | string | null
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    sex?: EnumSexNullableFilter<"Patient"> | $Enums.Sex | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    region?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    createdById?: UuidNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type PreclinicUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: PreclinicWhereUniqueInput
    update: XOR<PreclinicUpdateWithoutRecordedByInput, PreclinicUncheckedUpdateWithoutRecordedByInput>
    create: XOR<PreclinicCreateWithoutRecordedByInput, PreclinicUncheckedCreateWithoutRecordedByInput>
  }

  export type PreclinicUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: PreclinicWhereUniqueInput
    data: XOR<PreclinicUpdateWithoutRecordedByInput, PreclinicUncheckedUpdateWithoutRecordedByInput>
  }

  export type PreclinicUpdateManyWithWhereWithoutRecordedByInput = {
    where: PreclinicScalarWhereInput
    data: XOR<PreclinicUpdateManyMutationInput, PreclinicUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type PreclinicScalarWhereInput = {
    AND?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
    OR?: PreclinicScalarWhereInput[]
    NOT?: PreclinicScalarWhereInput | PreclinicScalarWhereInput[]
    id?: UuidFilter<"Preclinic"> | string
    patientId?: UuidFilter<"Preclinic"> | string
    visitDate?: DateTimeFilter<"Preclinic"> | Date | string
    bloodPressureSystolic?: IntNullableFilter<"Preclinic"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"Preclinic"> | number | null
    heartRate?: IntNullableFilter<"Preclinic"> | number | null
    respRate?: IntNullableFilter<"Preclinic"> | number | null
    temperatureC?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    weightKg?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    bmi?: DecimalNullableFilter<"Preclinic"> | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: StringNullableFilter<"Preclinic"> | string | null
    currentMedications?: StringNullableFilter<"Preclinic"> | string | null
    diabetes?: BoolNullableFilter<"Preclinic"> | boolean | null
    hypertension?: BoolNullableFilter<"Preclinic"> | boolean | null
    otherConditions?: StringNullableFilter<"Preclinic"> | string | null
    allergiesReported?: StringNullableFilter<"Preclinic"> | string | null
    recordedById?: UuidFilter<"Preclinic"> | string
    requestContextId?: UuidFilter<"Preclinic"> | string
  }

  export type ProblemUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: ProblemWhereUniqueInput
    update: XOR<ProblemUpdateWithoutRecordedByInput, ProblemUncheckedUpdateWithoutRecordedByInput>
    create: XOR<ProblemCreateWithoutRecordedByInput, ProblemUncheckedCreateWithoutRecordedByInput>
  }

  export type ProblemUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: ProblemWhereUniqueInput
    data: XOR<ProblemUpdateWithoutRecordedByInput, ProblemUncheckedUpdateWithoutRecordedByInput>
  }

  export type ProblemUpdateManyWithWhereWithoutRecordedByInput = {
    where: ProblemScalarWhereInput
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type ProblemScalarWhereInput = {
    AND?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
    OR?: ProblemScalarWhereInput[]
    NOT?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
    id?: UuidFilter<"Problem"> | string
    patientId?: UuidFilter<"Problem"> | string
    condition?: StringFilter<"Problem"> | string
    status?: EnumProblemStatusFilter<"Problem"> | $Enums.ProblemStatus
    diagnosedAt?: DateTimeNullableFilter<"Problem"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Problem"> | Date | string | null
    recordedById?: UuidNullableFilter<"Problem"> | string | null
  }

  export type AllergyUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: AllergyWhereUniqueInput
    update: XOR<AllergyUpdateWithoutRecordedByInput, AllergyUncheckedUpdateWithoutRecordedByInput>
    create: XOR<AllergyCreateWithoutRecordedByInput, AllergyUncheckedCreateWithoutRecordedByInput>
  }

  export type AllergyUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: AllergyWhereUniqueInput
    data: XOR<AllergyUpdateWithoutRecordedByInput, AllergyUncheckedUpdateWithoutRecordedByInput>
  }

  export type AllergyUpdateManyWithWhereWithoutRecordedByInput = {
    where: AllergyScalarWhereInput
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type AllergyScalarWhereInput = {
    AND?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
    OR?: AllergyScalarWhereInput[]
    NOT?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
    id?: UuidFilter<"Allergy"> | string
    patientId?: UuidFilter<"Allergy"> | string
    substance?: StringFilter<"Allergy"> | string
    reaction?: StringNullableFilter<"Allergy"> | string | null
    severity?: EnumAllergySeverityNullableFilter<"Allergy"> | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFilter<"Allergy"> | Date | string
    recordedById?: UuidNullableFilter<"Allergy"> | string | null
  }

  export type MedicationUpsertWithWhereUniqueWithoutPrescribedByInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutPrescribedByInput, MedicationUncheckedUpdateWithoutPrescribedByInput>
    create: XOR<MedicationCreateWithoutPrescribedByInput, MedicationUncheckedCreateWithoutPrescribedByInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutPrescribedByInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutPrescribedByInput, MedicationUncheckedUpdateWithoutPrescribedByInput>
  }

  export type MedicationUpdateManyWithWhereWithoutPrescribedByInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutPrescribedByInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: UuidFilter<"Medication"> | string
    patientId?: UuidFilter<"Medication"> | string
    drugName?: StringFilter<"Medication"> | string
    dose?: StringNullableFilter<"Medication"> | string | null
    frequency?: StringNullableFilter<"Medication"> | string | null
    route?: EnumRouteNullableFilter<"Medication"> | $Enums.Route | null
    startedAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    stoppedAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    prescribedById?: UuidNullableFilter<"Medication"> | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCashierInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCashierInput, InvoiceUncheckedUpdateWithoutCashierInput>
    create: XOR<InvoiceCreateWithoutCashierInput, InvoiceUncheckedCreateWithoutCashierInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCashierInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCashierInput, InvoiceUncheckedUpdateWithoutCashierInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCashierInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCashierInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    invoiceNo?: StringFilter<"Invoice"> | string
    patientId?: UuidNullableFilter<"Invoice"> | string | null
    preclinicId?: UuidNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFilter<"Invoice"> | Date | string
    locationId?: UuidFilter<"Invoice"> | string
    cashierId?: UuidFilter<"Invoice"> | string
    registerId?: UuidNullableFilter<"Invoice"> | string | null
    requestContextId?: UuidFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCreatedByInput, PaymentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCreatedByInput, PaymentUncheckedUpdateWithoutCreatedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCreatedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transferStatus?: EnumTransferStatusNullableFilter<"Payment"> | $Enums.TransferStatus | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    exchangeRate?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    posTerminalId?: UuidNullableFilter<"Payment"> | string | null
    createdById?: UuidFilter<"Payment"> | string
    requestContextId?: UuidFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type CashSessionUpsertWithWhereUniqueWithoutOpenedByInput = {
    where: CashSessionWhereUniqueInput
    update: XOR<CashSessionUpdateWithoutOpenedByInput, CashSessionUncheckedUpdateWithoutOpenedByInput>
    create: XOR<CashSessionCreateWithoutOpenedByInput, CashSessionUncheckedCreateWithoutOpenedByInput>
  }

  export type CashSessionUpdateWithWhereUniqueWithoutOpenedByInput = {
    where: CashSessionWhereUniqueInput
    data: XOR<CashSessionUpdateWithoutOpenedByInput, CashSessionUncheckedUpdateWithoutOpenedByInput>
  }

  export type CashSessionUpdateManyWithWhereWithoutOpenedByInput = {
    where: CashSessionScalarWhereInput
    data: XOR<CashSessionUpdateManyMutationInput, CashSessionUncheckedUpdateManyWithoutOpenedByInput>
  }

  export type CashSessionScalarWhereInput = {
    AND?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
    OR?: CashSessionScalarWhereInput[]
    NOT?: CashSessionScalarWhereInput | CashSessionScalarWhereInput[]
    id?: UuidFilter<"CashSession"> | string
    registerId?: UuidFilter<"CashSession"> | string
    openedById?: UuidFilter<"CashSession"> | string
    openedAt?: DateTimeFilter<"CashSession"> | Date | string
    openingFloat?: DecimalFilter<"CashSession"> | Decimal | DecimalJsLike | number | string
    closedById?: UuidNullableFilter<"CashSession"> | string | null
    closedAt?: DateTimeNullableFilter<"CashSession"> | Date | string | null
    declaredTotal?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    systemTotal?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"CashSession"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CashSessionUpsertWithWhereUniqueWithoutClosedByInput = {
    where: CashSessionWhereUniqueInput
    update: XOR<CashSessionUpdateWithoutClosedByInput, CashSessionUncheckedUpdateWithoutClosedByInput>
    create: XOR<CashSessionCreateWithoutClosedByInput, CashSessionUncheckedCreateWithoutClosedByInput>
  }

  export type CashSessionUpdateWithWhereUniqueWithoutClosedByInput = {
    where: CashSessionWhereUniqueInput
    data: XOR<CashSessionUpdateWithoutClosedByInput, CashSessionUncheckedUpdateWithoutClosedByInput>
  }

  export type CashSessionUpdateManyWithWhereWithoutClosedByInput = {
    where: CashSessionScalarWhereInput
    data: XOR<CashSessionUpdateManyMutationInput, CashSessionUncheckedUpdateManyWithoutClosedByInput>
  }

  export type CashMovementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CashMovementWhereUniqueInput
    update: XOR<CashMovementUpdateWithoutCreatedByInput, CashMovementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CashMovementCreateWithoutCreatedByInput, CashMovementUncheckedCreateWithoutCreatedByInput>
  }

  export type CashMovementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CashMovementWhereUniqueInput
    data: XOR<CashMovementUpdateWithoutCreatedByInput, CashMovementUncheckedUpdateWithoutCreatedByInput>
  }

  export type CashMovementUpdateManyWithWhereWithoutCreatedByInput = {
    where: CashMovementScalarWhereInput
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CashMovementScalarWhereInput = {
    AND?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
    OR?: CashMovementScalarWhereInput[]
    NOT?: CashMovementScalarWhereInput | CashMovementScalarWhereInput[]
    id?: UuidFilter<"CashMovement"> | string
    sessionId?: UuidFilter<"CashMovement"> | string
    type?: EnumCashMovementTypeFilter<"CashMovement"> | $Enums.CashMovementType
    amount?: DecimalFilter<"CashMovement"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"CashMovement"> | string | null
    createdById?: UuidFilter<"CashMovement"> | string
    requestContextId?: UuidFilter<"CashMovement"> | string
    createdAt?: DateTimeFilter<"CashMovement"> | Date | string
  }

  export type LabOrderUpsertWithWhereUniqueWithoutOrderingProviderInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutOrderingProviderInput, LabOrderUncheckedUpdateWithoutOrderingProviderInput>
    create: XOR<LabOrderCreateWithoutOrderingProviderInput, LabOrderUncheckedCreateWithoutOrderingProviderInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutOrderingProviderInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutOrderingProviderInput, LabOrderUncheckedUpdateWithoutOrderingProviderInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutOrderingProviderInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutOrderingProviderInput>
  }

  export type LabOrderScalarWhereInput = {
    AND?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
    OR?: LabOrderScalarWhereInput[]
    NOT?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
    id?: UuidFilter<"LabOrder"> | string
    accessionNo?: StringFilter<"LabOrder"> | string
    patientId?: UuidFilter<"LabOrder"> | string
    orderingProviderId?: UuidNullableFilter<"LabOrder"> | string | null
    invoiceId?: UuidNullableFilter<"LabOrder"> | string | null
    preclinicId?: UuidNullableFilter<"LabOrder"> | string | null
    specimenTypeId?: UuidNullableFilter<"LabOrder"> | string | null
    collectionTime?: DateTimeNullableFilter<"LabOrder"> | Date | string | null
    collectedById?: UuidNullableFilter<"LabOrder"> | string | null
    priority?: EnumPriorityNullableFilter<"LabOrder"> | $Enums.Priority | null
    status?: EnumLabOrderStatusFilter<"LabOrder"> | $Enums.LabOrderStatus
    notes?: StringNullableFilter<"LabOrder"> | string | null
    requestContextId?: UuidFilter<"LabOrder"> | string
  }

  export type LabOrderUpsertWithWhereUniqueWithoutCollectedByInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutCollectedByInput, LabOrderUncheckedUpdateWithoutCollectedByInput>
    create: XOR<LabOrderCreateWithoutCollectedByInput, LabOrderUncheckedCreateWithoutCollectedByInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutCollectedByInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutCollectedByInput, LabOrderUncheckedUpdateWithoutCollectedByInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutCollectedByInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutCollectedByInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutActorInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutActorInput, ActivityLogUncheckedUpdateWithoutActorInput>
    create: XOR<ActivityLogCreateWithoutActorInput, ActivityLogUncheckedCreateWithoutActorInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutActorInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutActorInput, ActivityLogUncheckedUpdateWithoutActorInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutActorInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutActorInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: UuidFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: UuidFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    actorId?: UuidFilter<"ActivityLog"> | string
    requestContextId?: UuidFilter<"ActivityLog"> | string
    metadata?: JsonNullableFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashRegisterCreateWithoutLocationInput = {
    id?: string
    name: string
    sessions?: CashSessionCreateNestedManyWithoutRegisterInput
    invoices?: InvoiceCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    sessions?: CashSessionUncheckedCreateNestedManyWithoutRegisterInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutLocationInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutLocationInput, CashRegisterUncheckedCreateWithoutLocationInput>
  }

  export type CashRegisterCreateManyLocationInputEnvelope = {
    data: CashRegisterCreateManyLocationInput | CashRegisterCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type PosTerminalCreateWithoutLocationInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    payments?: PaymentCreateNestedManyWithoutPosTerminalInput
  }

  export type PosTerminalUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutPosTerminalInput
  }

  export type PosTerminalCreateOrConnectWithoutLocationInput = {
    where: PosTerminalWhereUniqueInput
    create: XOR<PosTerminalCreateWithoutLocationInput, PosTerminalUncheckedCreateWithoutLocationInput>
  }

  export type PosTerminalCreateManyLocationInputEnvelope = {
    data: PosTerminalCreateManyLocationInput | PosTerminalCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type WorkstationCreateWithoutLocationInput = {
    id?: string
    name: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    sessions?: AuthSessionCreateNestedManyWithoutWorkstationInput
    contexts?: RequestContextCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutWorkstationInput
    contexts?: RequestContextUncheckedCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationCreateOrConnectWithoutLocationInput = {
    where: WorkstationWhereUniqueInput
    create: XOR<WorkstationCreateWithoutLocationInput, WorkstationUncheckedCreateWithoutLocationInput>
  }

  export type WorkstationCreateManyLocationInputEnvelope = {
    data: WorkstationCreateManyLocationInput | WorkstationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockCreateWithoutLocationInput = {
    id?: string
    onHand: number
    product: InventoryProductCreateNestedOneWithoutStockInput
  }

  export type ProductStockUncheckedCreateWithoutLocationInput = {
    id?: string
    productId: string
    onHand: number
  }

  export type ProductStockCreateOrConnectWithoutLocationInput = {
    where: ProductStockWhereUniqueInput
    create: XOR<ProductStockCreateWithoutLocationInput, ProductStockUncheckedCreateWithoutLocationInput>
  }

  export type ProductStockCreateManyLocationInputEnvelope = {
    data: ProductStockCreateManyLocationInput | ProductStockCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutLocationInput = {
    id?: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
    product: InventoryProductCreateNestedOneWithoutStockMovesInput
  }

  export type StockMovementUncheckedCreateWithoutLocationInput = {
    id?: string
    productId: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutLocationInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutLocationInput, StockMovementUncheckedCreateWithoutLocationInput>
  }

  export type StockMovementCreateManyLocationInputEnvelope = {
    data: StockMovementCreateManyLocationInput | StockMovementCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type LabInstrumentCreateWithoutLocationInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
    testsDefault?: TestCatalogCreateNestedManyWithoutDefaultInstrumentInput
    orderTests?: LabOrderTestCreateNestedManyWithoutInstrumentInput
    messages?: LabDeviceMessageCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
    testsDefault?: TestCatalogUncheckedCreateNestedManyWithoutDefaultInstrumentInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutInstrumentInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentCreateOrConnectWithoutLocationInput = {
    where: LabInstrumentWhereUniqueInput
    create: XOR<LabInstrumentCreateWithoutLocationInput, LabInstrumentUncheckedCreateWithoutLocationInput>
  }

  export type LabInstrumentCreateManyLocationInputEnvelope = {
    data: LabInstrumentCreateManyLocationInput | LabInstrumentCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutLocationInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLocationInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLocationInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLocationInput, InvoiceUncheckedCreateWithoutLocationInput>
  }

  export type InvoiceCreateManyLocationInputEnvelope = {
    data: InvoiceCreateManyLocationInput | InvoiceCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type CashRegisterUpsertWithWhereUniqueWithoutLocationInput = {
    where: CashRegisterWhereUniqueInput
    update: XOR<CashRegisterUpdateWithoutLocationInput, CashRegisterUncheckedUpdateWithoutLocationInput>
    create: XOR<CashRegisterCreateWithoutLocationInput, CashRegisterUncheckedCreateWithoutLocationInput>
  }

  export type CashRegisterUpdateWithWhereUniqueWithoutLocationInput = {
    where: CashRegisterWhereUniqueInput
    data: XOR<CashRegisterUpdateWithoutLocationInput, CashRegisterUncheckedUpdateWithoutLocationInput>
  }

  export type CashRegisterUpdateManyWithWhereWithoutLocationInput = {
    where: CashRegisterScalarWhereInput
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyWithoutLocationInput>
  }

  export type CashRegisterScalarWhereInput = {
    AND?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
    OR?: CashRegisterScalarWhereInput[]
    NOT?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
    id?: UuidFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    locationId?: UuidFilter<"CashRegister"> | string
  }

  export type PosTerminalUpsertWithWhereUniqueWithoutLocationInput = {
    where: PosTerminalWhereUniqueInput
    update: XOR<PosTerminalUpdateWithoutLocationInput, PosTerminalUncheckedUpdateWithoutLocationInput>
    create: XOR<PosTerminalCreateWithoutLocationInput, PosTerminalUncheckedCreateWithoutLocationInput>
  }

  export type PosTerminalUpdateWithWhereUniqueWithoutLocationInput = {
    where: PosTerminalWhereUniqueInput
    data: XOR<PosTerminalUpdateWithoutLocationInput, PosTerminalUncheckedUpdateWithoutLocationInput>
  }

  export type PosTerminalUpdateManyWithWhereWithoutLocationInput = {
    where: PosTerminalScalarWhereInput
    data: XOR<PosTerminalUpdateManyMutationInput, PosTerminalUncheckedUpdateManyWithoutLocationInput>
  }

  export type PosTerminalScalarWhereInput = {
    AND?: PosTerminalScalarWhereInput | PosTerminalScalarWhereInput[]
    OR?: PosTerminalScalarWhereInput[]
    NOT?: PosTerminalScalarWhereInput | PosTerminalScalarWhereInput[]
    id?: UuidFilter<"PosTerminal"> | string
    name?: StringFilter<"PosTerminal"> | string
    provider?: StringFilter<"PosTerminal"> | string
    merchantId?: StringNullableFilter<"PosTerminal"> | string | null
    locationId?: UuidFilter<"PosTerminal"> | string
  }

  export type WorkstationUpsertWithWhereUniqueWithoutLocationInput = {
    where: WorkstationWhereUniqueInput
    update: XOR<WorkstationUpdateWithoutLocationInput, WorkstationUncheckedUpdateWithoutLocationInput>
    create: XOR<WorkstationCreateWithoutLocationInput, WorkstationUncheckedCreateWithoutLocationInput>
  }

  export type WorkstationUpdateWithWhereUniqueWithoutLocationInput = {
    where: WorkstationWhereUniqueInput
    data: XOR<WorkstationUpdateWithoutLocationInput, WorkstationUncheckedUpdateWithoutLocationInput>
  }

  export type WorkstationUpdateManyWithWhereWithoutLocationInput = {
    where: WorkstationScalarWhereInput
    data: XOR<WorkstationUpdateManyMutationInput, WorkstationUncheckedUpdateManyWithoutLocationInput>
  }

  export type WorkstationScalarWhereInput = {
    AND?: WorkstationScalarWhereInput | WorkstationScalarWhereInput[]
    OR?: WorkstationScalarWhereInput[]
    NOT?: WorkstationScalarWhereInput | WorkstationScalarWhereInput[]
    id?: UuidFilter<"Workstation"> | string
    name?: StringFilter<"Workstation"> | string
    locationId?: UuidFilter<"Workstation"> | string
    type?: EnumWorkstationTypeFilter<"Workstation"> | $Enums.WorkstationType
    macAddress?: StringNullableFilter<"Workstation"> | string | null
    allowedIpCidr?: StringNullableFilter<"Workstation"> | string | null
    isActive?: BoolFilter<"Workstation"> | boolean
  }

  export type ProductStockUpsertWithWhereUniqueWithoutLocationInput = {
    where: ProductStockWhereUniqueInput
    update: XOR<ProductStockUpdateWithoutLocationInput, ProductStockUncheckedUpdateWithoutLocationInput>
    create: XOR<ProductStockCreateWithoutLocationInput, ProductStockUncheckedCreateWithoutLocationInput>
  }

  export type ProductStockUpdateWithWhereUniqueWithoutLocationInput = {
    where: ProductStockWhereUniqueInput
    data: XOR<ProductStockUpdateWithoutLocationInput, ProductStockUncheckedUpdateWithoutLocationInput>
  }

  export type ProductStockUpdateManyWithWhereWithoutLocationInput = {
    where: ProductStockScalarWhereInput
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProductStockScalarWhereInput = {
    AND?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
    OR?: ProductStockScalarWhereInput[]
    NOT?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
    id?: UuidFilter<"ProductStock"> | string
    productId?: UuidFilter<"ProductStock"> | string
    locationId?: UuidFilter<"ProductStock"> | string
    onHand?: IntFilter<"ProductStock"> | number
  }

  export type StockMovementUpsertWithWhereUniqueWithoutLocationInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutLocationInput, StockMovementUncheckedUpdateWithoutLocationInput>
    create: XOR<StockMovementCreateWithoutLocationInput, StockMovementUncheckedCreateWithoutLocationInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutLocationInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutLocationInput, StockMovementUncheckedUpdateWithoutLocationInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutLocationInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutLocationInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: UuidFilter<"StockMovement"> | string
    productId?: UuidFilter<"StockMovement"> | string
    locationId?: UuidFilter<"StockMovement"> | string
    qty?: IntFilter<"StockMovement"> | number
    reason?: EnumStockReasonFilter<"StockMovement"> | $Enums.StockReason
    reference?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type LabInstrumentUpsertWithWhereUniqueWithoutLocationInput = {
    where: LabInstrumentWhereUniqueInput
    update: XOR<LabInstrumentUpdateWithoutLocationInput, LabInstrumentUncheckedUpdateWithoutLocationInput>
    create: XOR<LabInstrumentCreateWithoutLocationInput, LabInstrumentUncheckedCreateWithoutLocationInput>
  }

  export type LabInstrumentUpdateWithWhereUniqueWithoutLocationInput = {
    where: LabInstrumentWhereUniqueInput
    data: XOR<LabInstrumentUpdateWithoutLocationInput, LabInstrumentUncheckedUpdateWithoutLocationInput>
  }

  export type LabInstrumentUpdateManyWithWhereWithoutLocationInput = {
    where: LabInstrumentScalarWhereInput
    data: XOR<LabInstrumentUpdateManyMutationInput, LabInstrumentUncheckedUpdateManyWithoutLocationInput>
  }

  export type LabInstrumentScalarWhereInput = {
    AND?: LabInstrumentScalarWhereInput | LabInstrumentScalarWhereInput[]
    OR?: LabInstrumentScalarWhereInput[]
    NOT?: LabInstrumentScalarWhereInput | LabInstrumentScalarWhereInput[]
    id?: UuidFilter<"LabInstrument"> | string
    name?: StringFilter<"LabInstrument"> | string
    vendor?: StringNullableFilter<"LabInstrument"> | string | null
    model?: StringNullableFilter<"LabInstrument"> | string | null
    serialNo?: StringNullableFilter<"LabInstrument"> | string | null
    connectionType?: EnumConnectionTypeNullableFilter<"LabInstrument"> | $Enums.ConnectionType | null
    locationId?: UuidNullableFilter<"LabInstrument"> | string | null
    isActive?: BoolFilter<"LabInstrument"> | boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutLocationInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutLocationInput, InvoiceUncheckedUpdateWithoutLocationInput>
    create: XOR<InvoiceCreateWithoutLocationInput, InvoiceUncheckedCreateWithoutLocationInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutLocationInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutLocationInput, InvoiceUncheckedUpdateWithoutLocationInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutLocationInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutLocationInput>
  }

  export type LocationCreateWithoutRegistersInput = {
    id?: string
    name: string
    address?: string | null
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutRegistersInput = {
    id?: string
    name: string
    address?: string | null
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutRegistersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRegistersInput, LocationUncheckedCreateWithoutRegistersInput>
  }

  export type CashSessionCreateWithoutRegisterInput = {
    id?: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    openedBy: UserCreateNestedOneWithoutCashSessionsOpenInput
    closedBy?: UserCreateNestedOneWithoutCashSessionsCloseInput
    movements?: CashMovementCreateNestedManyWithoutSessionInput
  }

  export type CashSessionUncheckedCreateWithoutRegisterInput = {
    id?: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CashSessionCreateOrConnectWithoutRegisterInput = {
    where: CashSessionWhereUniqueInput
    create: XOR<CashSessionCreateWithoutRegisterInput, CashSessionUncheckedCreateWithoutRegisterInput>
  }

  export type CashSessionCreateManyRegisterInputEnvelope = {
    data: CashSessionCreateManyRegisterInput | CashSessionCreateManyRegisterInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutRegisterInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutRegisterInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRegisterInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRegisterInput, InvoiceUncheckedCreateWithoutRegisterInput>
  }

  export type InvoiceCreateManyRegisterInputEnvelope = {
    data: InvoiceCreateManyRegisterInput | InvoiceCreateManyRegisterInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutRegistersInput = {
    update: XOR<LocationUpdateWithoutRegistersInput, LocationUncheckedUpdateWithoutRegistersInput>
    create: XOR<LocationCreateWithoutRegistersInput, LocationUncheckedCreateWithoutRegistersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRegistersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRegistersInput, LocationUncheckedUpdateWithoutRegistersInput>
  }

  export type LocationUpdateWithoutRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CashSessionUpsertWithWhereUniqueWithoutRegisterInput = {
    where: CashSessionWhereUniqueInput
    update: XOR<CashSessionUpdateWithoutRegisterInput, CashSessionUncheckedUpdateWithoutRegisterInput>
    create: XOR<CashSessionCreateWithoutRegisterInput, CashSessionUncheckedCreateWithoutRegisterInput>
  }

  export type CashSessionUpdateWithWhereUniqueWithoutRegisterInput = {
    where: CashSessionWhereUniqueInput
    data: XOR<CashSessionUpdateWithoutRegisterInput, CashSessionUncheckedUpdateWithoutRegisterInput>
  }

  export type CashSessionUpdateManyWithWhereWithoutRegisterInput = {
    where: CashSessionScalarWhereInput
    data: XOR<CashSessionUpdateManyMutationInput, CashSessionUncheckedUpdateManyWithoutRegisterInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutRegisterInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutRegisterInput, InvoiceUncheckedUpdateWithoutRegisterInput>
    create: XOR<InvoiceCreateWithoutRegisterInput, InvoiceUncheckedCreateWithoutRegisterInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutRegisterInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutRegisterInput, InvoiceUncheckedUpdateWithoutRegisterInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutRegisterInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutRegisterInput>
  }

  export type LocationCreateWithoutPosTerminalsInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutPosTerminalsInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutPosTerminalsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPosTerminalsInput, LocationUncheckedCreateWithoutPosTerminalsInput>
  }

  export type PaymentCreateWithoutPosTerminalInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
    requestContext: RequestContextCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPosTerminalInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPosTerminalInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPosTerminalInput, PaymentUncheckedCreateWithoutPosTerminalInput>
  }

  export type PaymentCreateManyPosTerminalInputEnvelope = {
    data: PaymentCreateManyPosTerminalInput | PaymentCreateManyPosTerminalInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutPosTerminalsInput = {
    update: XOR<LocationUpdateWithoutPosTerminalsInput, LocationUncheckedUpdateWithoutPosTerminalsInput>
    create: XOR<LocationCreateWithoutPosTerminalsInput, LocationUncheckedCreateWithoutPosTerminalsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPosTerminalsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPosTerminalsInput, LocationUncheckedUpdateWithoutPosTerminalsInput>
  }

  export type LocationUpdateWithoutPosTerminalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPosTerminalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutPosTerminalInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPosTerminalInput, PaymentUncheckedUpdateWithoutPosTerminalInput>
    create: XOR<PaymentCreateWithoutPosTerminalInput, PaymentUncheckedCreateWithoutPosTerminalInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPosTerminalInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPosTerminalInput, PaymentUncheckedUpdateWithoutPosTerminalInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPosTerminalInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPosTerminalInput>
  }

  export type LocationCreateWithoutWorkstationsInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutWorkstationsInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutWorkstationsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutWorkstationsInput, LocationUncheckedCreateWithoutWorkstationsInput>
  }

  export type AuthSessionCreateWithoutWorkstationInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
    contexts?: RequestContextCreateNestedManyWithoutSessionInput
  }

  export type AuthSessionUncheckedCreateWithoutWorkstationInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    contexts?: RequestContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AuthSessionCreateOrConnectWithoutWorkstationInput = {
    where: AuthSessionWhereUniqueInput
    create: XOR<AuthSessionCreateWithoutWorkstationInput, AuthSessionUncheckedCreateWithoutWorkstationInput>
  }

  export type AuthSessionCreateManyWorkstationInputEnvelope = {
    data: AuthSessionCreateManyWorkstationInput | AuthSessionCreateManyWorkstationInput[]
    skipDuplicates?: boolean
  }

  export type RequestContextCreateWithoutWorkstationInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutWorkstationInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutWorkstationInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutWorkstationInput, RequestContextUncheckedCreateWithoutWorkstationInput>
  }

  export type RequestContextCreateManyWorkstationInputEnvelope = {
    data: RequestContextCreateManyWorkstationInput | RequestContextCreateManyWorkstationInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutWorkstationsInput = {
    update: XOR<LocationUpdateWithoutWorkstationsInput, LocationUncheckedUpdateWithoutWorkstationsInput>
    create: XOR<LocationCreateWithoutWorkstationsInput, LocationUncheckedCreateWithoutWorkstationsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutWorkstationsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutWorkstationsInput, LocationUncheckedUpdateWithoutWorkstationsInput>
  }

  export type LocationUpdateWithoutWorkstationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutWorkstationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AuthSessionUpsertWithWhereUniqueWithoutWorkstationInput = {
    where: AuthSessionWhereUniqueInput
    update: XOR<AuthSessionUpdateWithoutWorkstationInput, AuthSessionUncheckedUpdateWithoutWorkstationInput>
    create: XOR<AuthSessionCreateWithoutWorkstationInput, AuthSessionUncheckedCreateWithoutWorkstationInput>
  }

  export type AuthSessionUpdateWithWhereUniqueWithoutWorkstationInput = {
    where: AuthSessionWhereUniqueInput
    data: XOR<AuthSessionUpdateWithoutWorkstationInput, AuthSessionUncheckedUpdateWithoutWorkstationInput>
  }

  export type AuthSessionUpdateManyWithWhereWithoutWorkstationInput = {
    where: AuthSessionScalarWhereInput
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyWithoutWorkstationInput>
  }

  export type RequestContextUpsertWithWhereUniqueWithoutWorkstationInput = {
    where: RequestContextWhereUniqueInput
    update: XOR<RequestContextUpdateWithoutWorkstationInput, RequestContextUncheckedUpdateWithoutWorkstationInput>
    create: XOR<RequestContextCreateWithoutWorkstationInput, RequestContextUncheckedCreateWithoutWorkstationInput>
  }

  export type RequestContextUpdateWithWhereUniqueWithoutWorkstationInput = {
    where: RequestContextWhereUniqueInput
    data: XOR<RequestContextUpdateWithoutWorkstationInput, RequestContextUncheckedUpdateWithoutWorkstationInput>
  }

  export type RequestContextUpdateManyWithWhereWithoutWorkstationInput = {
    where: RequestContextScalarWhereInput
    data: XOR<RequestContextUpdateManyMutationInput, RequestContextUncheckedUpdateManyWithoutWorkstationInput>
  }

  export type RequestContextScalarWhereInput = {
    AND?: RequestContextScalarWhereInput | RequestContextScalarWhereInput[]
    OR?: RequestContextScalarWhereInput[]
    NOT?: RequestContextScalarWhereInput | RequestContextScalarWhereInput[]
    id?: UuidFilter<"RequestContext"> | string
    sessionId?: UuidFilter<"RequestContext"> | string
    occurredAt?: DateTimeFilter<"RequestContext"> | Date | string
    ipAddress?: StringFilter<"RequestContext"> | string
    userAgent?: StringFilter<"RequestContext"> | string
    deviceFingerprint?: StringNullableFilter<"RequestContext"> | string | null
    workstationId?: UuidNullableFilter<"RequestContext"> | string | null
    geoCountry?: StringNullableFilter<"RequestContext"> | string | null
    geoRegion?: StringNullableFilter<"RequestContext"> | string | null
    geoCity?: StringNullableFilter<"RequestContext"> | string | null
    geoLat?: DecimalNullableFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
    geoLon?: DecimalNullableFilter<"RequestContext"> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserCreateWithoutPatientsCreatedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPatientsCreatedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPatientsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientsCreatedInput, UserUncheckedCreateWithoutPatientsCreatedInput>
  }

  export type PreclinicCreateWithoutPatientInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    labOrders?: LabOrderCreateNestedManyWithoutPreclinicInput
    recordedBy: UserCreateNestedOneWithoutPreclinicsInput
    requestContext: RequestContextCreateNestedOneWithoutPreclinicsInput
    invoices?: InvoiceCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicUncheckedCreateWithoutPatientInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    requestContextId: string
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPreclinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicCreateOrConnectWithoutPatientInput = {
    where: PreclinicWhereUniqueInput
    create: XOR<PreclinicCreateWithoutPatientInput, PreclinicUncheckedCreateWithoutPatientInput>
  }

  export type PreclinicCreateManyPatientInputEnvelope = {
    data: PreclinicCreateManyPatientInput | PreclinicCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AllergyCreateWithoutPatientInput = {
    id?: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    recordedBy?: UserCreateNestedOneWithoutAllergiesRecordedInput
  }

  export type AllergyUncheckedCreateWithoutPatientInput = {
    id?: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    recordedById?: string | null
  }

  export type AllergyCreateOrConnectWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    create: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput>
  }

  export type AllergyCreateManyPatientInputEnvelope = {
    data: AllergyCreateManyPatientInput | AllergyCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ProblemCreateWithoutPatientInput = {
    id?: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    recordedBy?: UserCreateNestedOneWithoutProblemsRecordedInput
  }

  export type ProblemUncheckedCreateWithoutPatientInput = {
    id?: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    recordedById?: string | null
  }

  export type ProblemCreateOrConnectWithoutPatientInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutPatientInput, ProblemUncheckedCreateWithoutPatientInput>
  }

  export type ProblemCreateManyPatientInputEnvelope = {
    data: ProblemCreateManyPatientInput | ProblemCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicationCreateWithoutPatientInput = {
    id?: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    prescribedBy?: UserCreateNestedOneWithoutMedicationsRxInput
  }

  export type MedicationUncheckedCreateWithoutPatientInput = {
    id?: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    prescribedById?: string | null
  }

  export type MedicationCreateOrConnectWithoutPatientInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput>
  }

  export type MedicationCreateManyPatientInputEnvelope = {
    data: MedicationCreateManyPatientInput | MedicationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: string
    invoiceNo: string
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutPatientInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutPatientInput = {
    id?: string
    accessionNo: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutPatientInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput>
  }

  export type LabOrderCreateManyPatientInputEnvelope = {
    data: LabOrderCreateManyPatientInput | LabOrderCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatientsCreatedInput = {
    update: XOR<UserUpdateWithoutPatientsCreatedInput, UserUncheckedUpdateWithoutPatientsCreatedInput>
    create: XOR<UserCreateWithoutPatientsCreatedInput, UserUncheckedCreateWithoutPatientsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientsCreatedInput, UserUncheckedUpdateWithoutPatientsCreatedInput>
  }

  export type UserUpdateWithoutPatientsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type PreclinicUpsertWithWhereUniqueWithoutPatientInput = {
    where: PreclinicWhereUniqueInput
    update: XOR<PreclinicUpdateWithoutPatientInput, PreclinicUncheckedUpdateWithoutPatientInput>
    create: XOR<PreclinicCreateWithoutPatientInput, PreclinicUncheckedCreateWithoutPatientInput>
  }

  export type PreclinicUpdateWithWhereUniqueWithoutPatientInput = {
    where: PreclinicWhereUniqueInput
    data: XOR<PreclinicUpdateWithoutPatientInput, PreclinicUncheckedUpdateWithoutPatientInput>
  }

  export type PreclinicUpdateManyWithWhereWithoutPatientInput = {
    where: PreclinicScalarWhereInput
    data: XOR<PreclinicUpdateManyMutationInput, PreclinicUncheckedUpdateManyWithoutPatientInput>
  }

  export type AllergyUpsertWithWhereUniqueWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    update: XOR<AllergyUpdateWithoutPatientInput, AllergyUncheckedUpdateWithoutPatientInput>
    create: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput>
  }

  export type AllergyUpdateWithWhereUniqueWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    data: XOR<AllergyUpdateWithoutPatientInput, AllergyUncheckedUpdateWithoutPatientInput>
  }

  export type AllergyUpdateManyWithWhereWithoutPatientInput = {
    where: AllergyScalarWhereInput
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyWithoutPatientInput>
  }

  export type ProblemUpsertWithWhereUniqueWithoutPatientInput = {
    where: ProblemWhereUniqueInput
    update: XOR<ProblemUpdateWithoutPatientInput, ProblemUncheckedUpdateWithoutPatientInput>
    create: XOR<ProblemCreateWithoutPatientInput, ProblemUncheckedCreateWithoutPatientInput>
  }

  export type ProblemUpdateWithWhereUniqueWithoutPatientInput = {
    where: ProblemWhereUniqueInput
    data: XOR<ProblemUpdateWithoutPatientInput, ProblemUncheckedUpdateWithoutPatientInput>
  }

  export type ProblemUpdateManyWithWhereWithoutPatientInput = {
    where: ProblemScalarWhereInput
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicationUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutPatientInput, MedicationUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutPatientInput, MedicationUncheckedUpdateWithoutPatientInput>
  }

  export type MedicationUpdateManyWithWhereWithoutPatientInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type LabOrderUpsertWithWhereUniqueWithoutPatientInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutPatientInput, LabOrderUncheckedUpdateWithoutPatientInput>
    create: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutPatientInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutPatientInput, LabOrderUncheckedUpdateWithoutPatientInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutPatientInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutPatientInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type WorkstationCreateWithoutSessionsInput = {
    id?: string
    name: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    location: LocationCreateNestedOneWithoutWorkstationsInput
    contexts?: RequestContextCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    locationId: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    contexts?: RequestContextUncheckedCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationCreateOrConnectWithoutSessionsInput = {
    where: WorkstationWhereUniqueInput
    create: XOR<WorkstationCreateWithoutSessionsInput, WorkstationUncheckedCreateWithoutSessionsInput>
  }

  export type RequestContextCreateWithoutSessionInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutSessionInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutSessionInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutSessionInput, RequestContextUncheckedCreateWithoutSessionInput>
  }

  export type RequestContextCreateManySessionInputEnvelope = {
    data: RequestContextCreateManySessionInput | RequestContextCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type WorkstationUpsertWithoutSessionsInput = {
    update: XOR<WorkstationUpdateWithoutSessionsInput, WorkstationUncheckedUpdateWithoutSessionsInput>
    create: XOR<WorkstationCreateWithoutSessionsInput, WorkstationUncheckedCreateWithoutSessionsInput>
    where?: WorkstationWhereInput
  }

  export type WorkstationUpdateToOneWithWhereWithoutSessionsInput = {
    where?: WorkstationWhereInput
    data: XOR<WorkstationUpdateWithoutSessionsInput, WorkstationUncheckedUpdateWithoutSessionsInput>
  }

  export type WorkstationUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutWorkstationsNestedInput
    contexts?: RequestContextUpdateManyWithoutWorkstationNestedInput
  }

  export type WorkstationUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contexts?: RequestContextUncheckedUpdateManyWithoutWorkstationNestedInput
  }

  export type RequestContextUpsertWithWhereUniqueWithoutSessionInput = {
    where: RequestContextWhereUniqueInput
    update: XOR<RequestContextUpdateWithoutSessionInput, RequestContextUncheckedUpdateWithoutSessionInput>
    create: XOR<RequestContextCreateWithoutSessionInput, RequestContextUncheckedCreateWithoutSessionInput>
  }

  export type RequestContextUpdateWithWhereUniqueWithoutSessionInput = {
    where: RequestContextWhereUniqueInput
    data: XOR<RequestContextUpdateWithoutSessionInput, RequestContextUncheckedUpdateWithoutSessionInput>
  }

  export type RequestContextUpdateManyWithWhereWithoutSessionInput = {
    where: RequestContextScalarWhereInput
    data: XOR<RequestContextUpdateManyMutationInput, RequestContextUncheckedUpdateManyWithoutSessionInput>
  }

  export type AuthSessionCreateWithoutContextsInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
    workstation?: WorkstationCreateNestedOneWithoutSessionsInput
  }

  export type AuthSessionUncheckedCreateWithoutContextsInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
  }

  export type AuthSessionCreateOrConnectWithoutContextsInput = {
    where: AuthSessionWhereUniqueInput
    create: XOR<AuthSessionCreateWithoutContextsInput, AuthSessionUncheckedCreateWithoutContextsInput>
  }

  export type WorkstationCreateWithoutContextsInput = {
    id?: string
    name: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    location: LocationCreateNestedOneWithoutWorkstationsInput
    sessions?: AuthSessionCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationUncheckedCreateWithoutContextsInput = {
    id?: string
    name: string
    locationId: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutWorkstationInput
  }

  export type WorkstationCreateOrConnectWithoutContextsInput = {
    where: WorkstationWhereUniqueInput
    create: XOR<WorkstationCreateWithoutContextsInput, WorkstationUncheckedCreateWithoutContextsInput>
  }

  export type InvoiceCreateWithoutRequestContextInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutRequestContextInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRequestContextInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRequestContextInput, InvoiceUncheckedCreateWithoutRequestContextInput>
  }

  export type InvoiceCreateManyRequestContextInputEnvelope = {
    data: InvoiceCreateManyRequestContextInput | InvoiceCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutRequestContextInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    posTerminal?: PosTerminalCreateNestedOneWithoutPaymentsInput
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
  }

  export type PaymentUncheckedCreateWithoutRequestContextInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutRequestContextInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRequestContextInput, PaymentUncheckedCreateWithoutRequestContextInput>
  }

  export type PaymentCreateManyRequestContextInputEnvelope = {
    data: PaymentCreateManyRequestContextInput | PaymentCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type CashMovementCreateWithoutRequestContextInput = {
    id?: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    session: CashSessionCreateNestedOneWithoutMovementsInput
    createdBy: UserCreateNestedOneWithoutCashMovementsInput
  }

  export type CashMovementUncheckedCreateWithoutRequestContextInput = {
    id?: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type CashMovementCreateOrConnectWithoutRequestContextInput = {
    where: CashMovementWhereUniqueInput
    create: XOR<CashMovementCreateWithoutRequestContextInput, CashMovementUncheckedCreateWithoutRequestContextInput>
  }

  export type CashMovementCreateManyRequestContextInputEnvelope = {
    data: CashMovementCreateManyRequestContextInput | CashMovementCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type PreclinicCreateWithoutRequestContextInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    patient: PatientCreateNestedOneWithoutPreclinicsInput
    labOrders?: LabOrderCreateNestedManyWithoutPreclinicInput
    recordedBy: UserCreateNestedOneWithoutPreclinicsInput
    invoices?: InvoiceCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicUncheckedCreateWithoutRequestContextInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPreclinicInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicCreateOrConnectWithoutRequestContextInput = {
    where: PreclinicWhereUniqueInput
    create: XOR<PreclinicCreateWithoutRequestContextInput, PreclinicUncheckedCreateWithoutRequestContextInput>
  }

  export type PreclinicCreateManyRequestContextInputEnvelope = {
    data: PreclinicCreateManyRequestContextInput | PreclinicCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutRequestContextInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutRequestContextInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutRequestContextInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutRequestContextInput, LabOrderUncheckedCreateWithoutRequestContextInput>
  }

  export type LabOrderCreateManyRequestContextInputEnvelope = {
    data: LabOrderCreateManyRequestContextInput | LabOrderCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderTestCreateWithoutRequestContextInput = {
    id?: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    order: LabOrderCreateNestedOneWithoutTestsInput
    test: TestCatalogCreateNestedOneWithoutOrderTestsInput
    instrument?: LabInstrumentCreateNestedOneWithoutOrderTestsInput
  }

  export type LabOrderTestUncheckedCreateWithoutRequestContextInput = {
    id?: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
  }

  export type LabOrderTestCreateOrConnectWithoutRequestContextInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutRequestContextInput, LabOrderTestUncheckedCreateWithoutRequestContextInput>
  }

  export type LabOrderTestCreateManyRequestContextInputEnvelope = {
    data: LabOrderTestCreateManyRequestContextInput | LabOrderTestCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutRequestContextInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor: UserCreateNestedOneWithoutActivityInput
  }

  export type ActivityLogUncheckedCreateWithoutRequestContextInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    actorId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutRequestContextInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutRequestContextInput, ActivityLogUncheckedCreateWithoutRequestContextInput>
  }

  export type ActivityLogCreateManyRequestContextInputEnvelope = {
    data: ActivityLogCreateManyRequestContextInput | ActivityLogCreateManyRequestContextInput[]
    skipDuplicates?: boolean
  }

  export type AuthSessionUpsertWithoutContextsInput = {
    update: XOR<AuthSessionUpdateWithoutContextsInput, AuthSessionUncheckedUpdateWithoutContextsInput>
    create: XOR<AuthSessionCreateWithoutContextsInput, AuthSessionUncheckedCreateWithoutContextsInput>
    where?: AuthSessionWhereInput
  }

  export type AuthSessionUpdateToOneWithWhereWithoutContextsInput = {
    where?: AuthSessionWhereInput
    data: XOR<AuthSessionUpdateWithoutContextsInput, AuthSessionUncheckedUpdateWithoutContextsInput>
  }

  export type AuthSessionUpdateWithoutContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    workstation?: WorkstationUpdateOneWithoutSessionsNestedInput
  }

  export type AuthSessionUncheckedUpdateWithoutContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkstationUpsertWithoutContextsInput = {
    update: XOR<WorkstationUpdateWithoutContextsInput, WorkstationUncheckedUpdateWithoutContextsInput>
    create: XOR<WorkstationCreateWithoutContextsInput, WorkstationUncheckedCreateWithoutContextsInput>
    where?: WorkstationWhereInput
  }

  export type WorkstationUpdateToOneWithWhereWithoutContextsInput = {
    where?: WorkstationWhereInput
    data: XOR<WorkstationUpdateWithoutContextsInput, WorkstationUncheckedUpdateWithoutContextsInput>
  }

  export type WorkstationUpdateWithoutContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutWorkstationsNestedInput
    sessions?: AuthSessionUpdateManyWithoutWorkstationNestedInput
  }

  export type WorkstationUncheckedUpdateWithoutContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sessions?: AuthSessionUncheckedUpdateManyWithoutWorkstationNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutRequestContextInput, InvoiceUncheckedUpdateWithoutRequestContextInput>
    create: XOR<InvoiceCreateWithoutRequestContextInput, InvoiceUncheckedCreateWithoutRequestContextInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutRequestContextInput, InvoiceUncheckedUpdateWithoutRequestContextInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutRequestContextInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutRequestContextInput, PaymentUncheckedUpdateWithoutRequestContextInput>
    create: XOR<PaymentCreateWithoutRequestContextInput, PaymentUncheckedCreateWithoutRequestContextInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutRequestContextInput, PaymentUncheckedUpdateWithoutRequestContextInput>
  }

  export type PaymentUpdateManyWithWhereWithoutRequestContextInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type CashMovementUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: CashMovementWhereUniqueInput
    update: XOR<CashMovementUpdateWithoutRequestContextInput, CashMovementUncheckedUpdateWithoutRequestContextInput>
    create: XOR<CashMovementCreateWithoutRequestContextInput, CashMovementUncheckedCreateWithoutRequestContextInput>
  }

  export type CashMovementUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: CashMovementWhereUniqueInput
    data: XOR<CashMovementUpdateWithoutRequestContextInput, CashMovementUncheckedUpdateWithoutRequestContextInput>
  }

  export type CashMovementUpdateManyWithWhereWithoutRequestContextInput = {
    where: CashMovementScalarWhereInput
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type PreclinicUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: PreclinicWhereUniqueInput
    update: XOR<PreclinicUpdateWithoutRequestContextInput, PreclinicUncheckedUpdateWithoutRequestContextInput>
    create: XOR<PreclinicCreateWithoutRequestContextInput, PreclinicUncheckedCreateWithoutRequestContextInput>
  }

  export type PreclinicUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: PreclinicWhereUniqueInput
    data: XOR<PreclinicUpdateWithoutRequestContextInput, PreclinicUncheckedUpdateWithoutRequestContextInput>
  }

  export type PreclinicUpdateManyWithWhereWithoutRequestContextInput = {
    where: PreclinicScalarWhereInput
    data: XOR<PreclinicUpdateManyMutationInput, PreclinicUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type LabOrderUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutRequestContextInput, LabOrderUncheckedUpdateWithoutRequestContextInput>
    create: XOR<LabOrderCreateWithoutRequestContextInput, LabOrderUncheckedCreateWithoutRequestContextInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutRequestContextInput, LabOrderUncheckedUpdateWithoutRequestContextInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutRequestContextInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutRequestContextInput, LabOrderTestUncheckedUpdateWithoutRequestContextInput>
    create: XOR<LabOrderTestCreateWithoutRequestContextInput, LabOrderTestUncheckedCreateWithoutRequestContextInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutRequestContextInput, LabOrderTestUncheckedUpdateWithoutRequestContextInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutRequestContextInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type LabOrderTestScalarWhereInput = {
    AND?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
    OR?: LabOrderTestScalarWhereInput[]
    NOT?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
    id?: UuidFilter<"LabOrderTest"> | string
    orderId?: UuidFilter<"LabOrderTest"> | string
    testId?: UuidFilter<"LabOrderTest"> | string
    status?: EnumLabOrderTestStatusFilter<"LabOrderTest"> | $Enums.LabOrderTestStatus
    instrumentId?: UuidNullableFilter<"LabOrderTest"> | string | null
    analyteCodeInstrument?: StringNullableFilter<"LabOrderTest"> | string | null
    resultValue?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    resultText?: StringNullableFilter<"LabOrderTest"> | string | null
    units?: StringNullableFilter<"LabOrderTest"> | string | null
    flagAbnormal?: EnumAbnormalFlagNullableFilter<"LabOrderTest"> | $Enums.AbnormalFlag | null
    outOfRange?: EnumOutOfRangeFlagNullableFilter<"LabOrderTest"> | $Enums.OutOfRangeFlag | null
    referenceLow?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"LabOrderTest"> | Decimal | DecimalJsLike | number | string | null
    completedAt?: DateTimeNullableFilter<"LabOrderTest"> | Date | string | null
    resultNotes?: StringNullableFilter<"LabOrderTest"> | string | null
    requestContextId?: UuidFilter<"LabOrderTest"> | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutRequestContextInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutRequestContextInput, ActivityLogUncheckedUpdateWithoutRequestContextInput>
    create: XOR<ActivityLogCreateWithoutRequestContextInput, ActivityLogUncheckedCreateWithoutRequestContextInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutRequestContextInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutRequestContextInput, ActivityLogUncheckedUpdateWithoutRequestContextInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutRequestContextInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutRequestContextInput>
  }

  export type PatientCreateWithoutPreclinicsInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPreclinicsInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPreclinicsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPreclinicsInput, PatientUncheckedCreateWithoutPreclinicsInput>
  }

  export type LabOrderCreateWithoutPreclinicInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutPreclinicInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutPreclinicInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutPreclinicInput, LabOrderUncheckedCreateWithoutPreclinicInput>
  }

  export type LabOrderCreateManyPreclinicInputEnvelope = {
    data: LabOrderCreateManyPreclinicInput | LabOrderCreateManyPreclinicInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPreclinicsInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPreclinicsInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPreclinicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreclinicsInput, UserUncheckedCreateWithoutPreclinicsInput>
  }

  export type RequestContextCreateWithoutPreclinicsInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutPreclinicsInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutPreclinicsInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutPreclinicsInput, RequestContextUncheckedCreateWithoutPreclinicsInput>
  }

  export type InvoiceCreateWithoutPreclinicInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPreclinicInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPreclinicInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPreclinicInput, InvoiceUncheckedCreateWithoutPreclinicInput>
  }

  export type InvoiceCreateManyPreclinicInputEnvelope = {
    data: InvoiceCreateManyPreclinicInput | InvoiceCreateManyPreclinicInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPreclinicsInput = {
    update: XOR<PatientUpdateWithoutPreclinicsInput, PatientUncheckedUpdateWithoutPreclinicsInput>
    create: XOR<PatientCreateWithoutPreclinicsInput, PatientUncheckedCreateWithoutPreclinicsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPreclinicsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPreclinicsInput, PatientUncheckedUpdateWithoutPreclinicsInput>
  }

  export type PatientUpdateWithoutPreclinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPreclinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LabOrderUpsertWithWhereUniqueWithoutPreclinicInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutPreclinicInput, LabOrderUncheckedUpdateWithoutPreclinicInput>
    create: XOR<LabOrderCreateWithoutPreclinicInput, LabOrderUncheckedCreateWithoutPreclinicInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutPreclinicInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutPreclinicInput, LabOrderUncheckedUpdateWithoutPreclinicInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutPreclinicInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutPreclinicInput>
  }

  export type UserUpsertWithoutPreclinicsInput = {
    update: XOR<UserUpdateWithoutPreclinicsInput, UserUncheckedUpdateWithoutPreclinicsInput>
    create: XOR<UserCreateWithoutPreclinicsInput, UserUncheckedCreateWithoutPreclinicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreclinicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreclinicsInput, UserUncheckedUpdateWithoutPreclinicsInput>
  }

  export type UserUpdateWithoutPreclinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPreclinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type RequestContextUpsertWithoutPreclinicsInput = {
    update: XOR<RequestContextUpdateWithoutPreclinicsInput, RequestContextUncheckedUpdateWithoutPreclinicsInput>
    create: XOR<RequestContextCreateWithoutPreclinicsInput, RequestContextUncheckedCreateWithoutPreclinicsInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutPreclinicsInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutPreclinicsInput, RequestContextUncheckedUpdateWithoutPreclinicsInput>
  }

  export type RequestContextUpdateWithoutPreclinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutPreclinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPreclinicInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPreclinicInput, InvoiceUncheckedUpdateWithoutPreclinicInput>
    create: XOR<InvoiceCreateWithoutPreclinicInput, InvoiceUncheckedCreateWithoutPreclinicInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPreclinicInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPreclinicInput, InvoiceUncheckedUpdateWithoutPreclinicInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPreclinicInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPreclinicInput>
  }

  export type PatientCreateWithoutAllergiesInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAllergiesInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAllergiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
  }

  export type UserCreateWithoutAllergiesRecordedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutAllergiesRecordedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutAllergiesRecordedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAllergiesRecordedInput, UserUncheckedCreateWithoutAllergiesRecordedInput>
  }

  export type PatientUpsertWithoutAllergiesInput = {
    update: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAllergiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutAllergiesRecordedInput = {
    update: XOR<UserUpdateWithoutAllergiesRecordedInput, UserUncheckedUpdateWithoutAllergiesRecordedInput>
    create: XOR<UserCreateWithoutAllergiesRecordedInput, UserUncheckedCreateWithoutAllergiesRecordedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAllergiesRecordedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAllergiesRecordedInput, UserUncheckedUpdateWithoutAllergiesRecordedInput>
  }

  export type UserUpdateWithoutAllergiesRecordedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutAllergiesRecordedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type PatientCreateWithoutProblemsInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutProblemsInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutProblemsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutProblemsInput, PatientUncheckedCreateWithoutProblemsInput>
  }

  export type UserCreateWithoutProblemsRecordedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutProblemsRecordedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutProblemsRecordedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProblemsRecordedInput, UserUncheckedCreateWithoutProblemsRecordedInput>
  }

  export type PatientUpsertWithoutProblemsInput = {
    update: XOR<PatientUpdateWithoutProblemsInput, PatientUncheckedUpdateWithoutProblemsInput>
    create: XOR<PatientCreateWithoutProblemsInput, PatientUncheckedCreateWithoutProblemsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutProblemsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutProblemsInput, PatientUncheckedUpdateWithoutProblemsInput>
  }

  export type PatientUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutProblemsRecordedInput = {
    update: XOR<UserUpdateWithoutProblemsRecordedInput, UserUncheckedUpdateWithoutProblemsRecordedInput>
    create: XOR<UserCreateWithoutProblemsRecordedInput, UserUncheckedCreateWithoutProblemsRecordedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProblemsRecordedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProblemsRecordedInput, UserUncheckedUpdateWithoutProblemsRecordedInput>
  }

  export type UserUpdateWithoutProblemsRecordedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutProblemsRecordedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type PatientCreateWithoutMedicationsInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicationsInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
  }

  export type UserCreateWithoutMedicationsRxInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutMedicationsRxInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutMedicationsRxInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicationsRxInput, UserUncheckedCreateWithoutMedicationsRxInput>
  }

  export type PatientUpsertWithoutMedicationsInput = {
    update: XOR<PatientUpdateWithoutMedicationsInput, PatientUncheckedUpdateWithoutMedicationsInput>
    create: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicationsInput, PatientUncheckedUpdateWithoutMedicationsInput>
  }

  export type PatientUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutMedicationsRxInput = {
    update: XOR<UserUpdateWithoutMedicationsRxInput, UserUncheckedUpdateWithoutMedicationsRxInput>
    create: XOR<UserCreateWithoutMedicationsRxInput, UserUncheckedCreateWithoutMedicationsRxInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicationsRxInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicationsRxInput, UserUncheckedUpdateWithoutMedicationsRxInput>
  }

  export type UserUpdateWithoutMedicationsRxInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicationsRxInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type ServiceCreateWithoutCategoryInput = {
    id?: string
    code: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
    lines?: InvoiceLineCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string
    code: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: UuidFilter<"Service"> | string
    code?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    categoryId?: UuidFilter<"Service"> | string
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    commissionPct?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFilter<"Service"> | boolean
  }

  export type ServiceCategoryCreateWithoutServicesInput = {
    id?: string
    name: string
  }

  export type ServiceCategoryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
  }

  export type ServiceCategoryCreateOrConnectWithoutServicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type InvoiceLineCreateWithoutServiceInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
    product?: InventoryProductCreateNestedOneWithoutLinesInput
    provider?: ProviderCreateNestedOneWithoutLinesInput
    commission?: ProviderCommissionCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineUncheckedCreateWithoutServiceInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
    commission?: ProviderCommissionUncheckedCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineCreateOrConnectWithoutServiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutServiceInput, InvoiceLineUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceLineCreateManyServiceInputEnvelope = {
    data: InvoiceLineCreateManyServiceInput | InvoiceLineCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCategoryUpsertWithoutServicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceCategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutServiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutServiceInput, InvoiceLineUncheckedUpdateWithoutServiceInput>
    create: XOR<InvoiceLineCreateWithoutServiceInput, InvoiceLineUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutServiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutServiceInput, InvoiceLineUncheckedUpdateWithoutServiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutServiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    id?: UuidFilter<"InvoiceLine"> | string
    invoiceId?: UuidFilter<"InvoiceLine"> | string
    lineNo?: IntFilter<"InvoiceLine"> | number
    itemType?: EnumItemTypeFilter<"InvoiceLine"> | $Enums.ItemType
    serviceId?: UuidNullableFilter<"InvoiceLine"> | string | null
    productId?: UuidNullableFilter<"InvoiceLine"> | string | null
    description?: StringFilter<"InvoiceLine"> | string
    qty?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    providerId?: UuidNullableFilter<"InvoiceLine"> | string | null
  }

  export type InvoiceLineCreateWithoutProviderInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
    service?: ServiceCreateNestedOneWithoutLinesInput
    product?: InventoryProductCreateNestedOneWithoutLinesInput
    commission?: ProviderCommissionCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineUncheckedCreateWithoutProviderInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    commission?: ProviderCommissionUncheckedCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineCreateOrConnectWithoutProviderInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutProviderInput, InvoiceLineUncheckedCreateWithoutProviderInput>
  }

  export type InvoiceLineCreateManyProviderInputEnvelope = {
    data: InvoiceLineCreateManyProviderInput | InvoiceLineCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ProviderCommissionCreateWithoutProviderInput = {
    id?: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    invoiceLine: InvoiceLineCreateNestedOneWithoutCommissionInput
  }

  export type ProviderCommissionUncheckedCreateWithoutProviderInput = {
    id?: string
    invoiceLineId: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
  }

  export type ProviderCommissionCreateOrConnectWithoutProviderInput = {
    where: ProviderCommissionWhereUniqueInput
    create: XOR<ProviderCommissionCreateWithoutProviderInput, ProviderCommissionUncheckedCreateWithoutProviderInput>
  }

  export type ProviderCommissionCreateManyProviderInputEnvelope = {
    data: ProviderCommissionCreateManyProviderInput | ProviderCommissionCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutProviderInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutProviderInput, InvoiceLineUncheckedUpdateWithoutProviderInput>
    create: XOR<InvoiceLineCreateWithoutProviderInput, InvoiceLineUncheckedCreateWithoutProviderInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutProviderInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutProviderInput, InvoiceLineUncheckedUpdateWithoutProviderInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutProviderInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderCommissionUpsertWithWhereUniqueWithoutProviderInput = {
    where: ProviderCommissionWhereUniqueInput
    update: XOR<ProviderCommissionUpdateWithoutProviderInput, ProviderCommissionUncheckedUpdateWithoutProviderInput>
    create: XOR<ProviderCommissionCreateWithoutProviderInput, ProviderCommissionUncheckedCreateWithoutProviderInput>
  }

  export type ProviderCommissionUpdateWithWhereUniqueWithoutProviderInput = {
    where: ProviderCommissionWhereUniqueInput
    data: XOR<ProviderCommissionUpdateWithoutProviderInput, ProviderCommissionUncheckedUpdateWithoutProviderInput>
  }

  export type ProviderCommissionUpdateManyWithWhereWithoutProviderInput = {
    where: ProviderCommissionScalarWhereInput
    data: XOR<ProviderCommissionUpdateManyMutationInput, ProviderCommissionUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderCommissionScalarWhereInput = {
    AND?: ProviderCommissionScalarWhereInput | ProviderCommissionScalarWhereInput[]
    OR?: ProviderCommissionScalarWhereInput[]
    NOT?: ProviderCommissionScalarWhereInput | ProviderCommissionScalarWhereInput[]
    id?: UuidFilter<"ProviderCommission"> | string
    invoiceLineId?: UuidFilter<"ProviderCommission"> | string
    providerId?: UuidFilter<"ProviderCommission"> | string
    baseAmount?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFilter<"ProviderCommission"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"ProviderCommission"> | boolean
  }

  export type PatientCreateWithoutInvoicesInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type PreclinicCreateWithoutInvoicesInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    patient: PatientCreateNestedOneWithoutPreclinicsInput
    labOrders?: LabOrderCreateNestedManyWithoutPreclinicInput
    recordedBy: UserCreateNestedOneWithoutPreclinicsInput
    requestContext: RequestContextCreateNestedOneWithoutPreclinicsInput
  }

  export type PreclinicUncheckedCreateWithoutInvoicesInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    requestContextId: string
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicCreateOrConnectWithoutInvoicesInput = {
    where: PreclinicWhereUniqueInput
    create: XOR<PreclinicCreateWithoutInvoicesInput, PreclinicUncheckedCreateWithoutInvoicesInput>
  }

  export type LocationCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutInvoicesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInvoicesInput, LocationUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutInvoicesCashierInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutInvoicesCashierInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutInvoicesCashierInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesCashierInput, UserUncheckedCreateWithoutInvoicesCashierInput>
  }

  export type CashRegisterCreateWithoutInvoicesInput = {
    id?: string
    name: string
    location: LocationCreateNestedOneWithoutRegistersInput
    sessions?: CashSessionCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    locationId: string
    sessions?: CashSessionUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutInvoicesInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutInvoicesInput, CashRegisterUncheckedCreateWithoutInvoicesInput>
  }

  export type RequestContextCreateWithoutInvoicesInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutInvoicesInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutInvoicesInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutInvoicesInput, RequestContextUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    service?: ServiceCreateNestedOneWithoutLinesInput
    product?: InventoryProductCreateNestedOneWithoutLinesInput
    provider?: ProviderCreateNestedOneWithoutLinesInput
    commission?: ProviderCommissionCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
    commission?: ProviderCommissionUncheckedCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdAt?: Date | string
    posTerminal?: PosTerminalCreateNestedOneWithoutPaymentsInput
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
    requestContext: RequestContextCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutInvoiceInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutInvoiceInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutInvoiceInput, LabOrderUncheckedCreateWithoutInvoiceInput>
  }

  export type LabOrderCreateManyInvoiceInputEnvelope = {
    data: LabOrderCreateManyInvoiceInput | LabOrderCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PreclinicUpsertWithoutInvoicesInput = {
    update: XOR<PreclinicUpdateWithoutInvoicesInput, PreclinicUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PreclinicCreateWithoutInvoicesInput, PreclinicUncheckedCreateWithoutInvoicesInput>
    where?: PreclinicWhereInput
  }

  export type PreclinicUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PreclinicWhereInput
    data: XOR<PreclinicUpdateWithoutInvoicesInput, PreclinicUncheckedUpdateWithoutInvoicesInput>
  }

  export type PreclinicUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutPreclinicsNestedInput
    labOrders?: LabOrderUpdateManyWithoutPreclinicNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutPreclinicsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPreclinicsNestedInput
  }

  export type PreclinicUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    labOrders?: LabOrderUncheckedUpdateManyWithoutPreclinicNestedInput
  }

  export type LocationUpsertWithoutInvoicesInput = {
    update: XOR<LocationUpdateWithoutInvoicesInput, LocationUncheckedUpdateWithoutInvoicesInput>
    create: XOR<LocationCreateWithoutInvoicesInput, LocationUncheckedCreateWithoutInvoicesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutInvoicesInput, LocationUncheckedUpdateWithoutInvoicesInput>
  }

  export type LocationUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserUpsertWithoutInvoicesCashierInput = {
    update: XOR<UserUpdateWithoutInvoicesCashierInput, UserUncheckedUpdateWithoutInvoicesCashierInput>
    create: XOR<UserCreateWithoutInvoicesCashierInput, UserUncheckedCreateWithoutInvoicesCashierInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesCashierInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesCashierInput, UserUncheckedUpdateWithoutInvoicesCashierInput>
  }

  export type UserUpdateWithoutInvoicesCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CashRegisterUpsertWithoutInvoicesInput = {
    update: XOR<CashRegisterUpdateWithoutInvoicesInput, CashRegisterUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CashRegisterCreateWithoutInvoicesInput, CashRegisterUncheckedCreateWithoutInvoicesInput>
    where?: CashRegisterWhereInput
  }

  export type CashRegisterUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CashRegisterWhereInput
    data: XOR<CashRegisterUpdateWithoutInvoicesInput, CashRegisterUncheckedUpdateWithoutInvoicesInput>
  }

  export type CashRegisterUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutRegistersNestedInput
    sessions?: CashSessionUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sessions?: CashSessionUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type RequestContextUpsertWithoutInvoicesInput = {
    update: XOR<RequestContextUpdateWithoutInvoicesInput, RequestContextUncheckedUpdateWithoutInvoicesInput>
    create: XOR<RequestContextCreateWithoutInvoicesInput, RequestContextUncheckedCreateWithoutInvoicesInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutInvoicesInput, RequestContextUncheckedUpdateWithoutInvoicesInput>
  }

  export type RequestContextUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type LabOrderUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutInvoiceInput, LabOrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<LabOrderCreateWithoutInvoiceInput, LabOrderUncheckedCreateWithoutInvoiceInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutInvoiceInput, LabOrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutInvoiceInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutLinesInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLinesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
  }

  export type ServiceCreateWithoutLinesInput = {
    id?: string
    code: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutLinesInput = {
    id?: string
    code: string
    name: string
    categoryId: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
  }

  export type ServiceCreateOrConnectWithoutLinesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutLinesInput, ServiceUncheckedCreateWithoutLinesInput>
  }

  export type InventoryProductCreateWithoutLinesInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stock?: ProductStockCreateNestedManyWithoutProductInput
    stockMoves?: StockMovementCreateNestedManyWithoutProductInput
  }

  export type InventoryProductUncheckedCreateWithoutLinesInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stock?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type InventoryProductCreateOrConnectWithoutLinesInput = {
    where: InventoryProductWhereUniqueInput
    create: XOR<InventoryProductCreateWithoutLinesInput, InventoryProductUncheckedCreateWithoutLinesInput>
  }

  export type ProviderCreateWithoutLinesInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    commissions?: ProviderCommissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutLinesInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    commissions?: ProviderCommissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutLinesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutLinesInput, ProviderUncheckedCreateWithoutLinesInput>
  }

  export type ProviderCommissionCreateWithoutInvoiceLineInput = {
    id?: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    provider: ProviderCreateNestedOneWithoutCommissionsInput
  }

  export type ProviderCommissionUncheckedCreateWithoutInvoiceLineInput = {
    id?: string
    providerId: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
  }

  export type ProviderCommissionCreateOrConnectWithoutInvoiceLineInput = {
    where: ProviderCommissionWhereUniqueInput
    create: XOR<ProviderCommissionCreateWithoutInvoiceLineInput, ProviderCommissionUncheckedCreateWithoutInvoiceLineInput>
  }

  export type InvoiceUpsertWithoutLinesInput = {
    update: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceUpsertWithoutLinesInput = {
    update: XOR<ServiceUpdateWithoutLinesInput, ServiceUncheckedUpdateWithoutLinesInput>
    create: XOR<ServiceCreateWithoutLinesInput, ServiceUncheckedCreateWithoutLinesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutLinesInput, ServiceUncheckedUpdateWithoutLinesInput>
  }

  export type ServiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryProductUpsertWithoutLinesInput = {
    update: XOR<InventoryProductUpdateWithoutLinesInput, InventoryProductUncheckedUpdateWithoutLinesInput>
    create: XOR<InventoryProductCreateWithoutLinesInput, InventoryProductUncheckedCreateWithoutLinesInput>
    where?: InventoryProductWhereInput
  }

  export type InventoryProductUpdateToOneWithWhereWithoutLinesInput = {
    where?: InventoryProductWhereInput
    data: XOR<InventoryProductUpdateWithoutLinesInput, InventoryProductUncheckedUpdateWithoutLinesInput>
  }

  export type InventoryProductUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stock?: ProductStockUpdateManyWithoutProductNestedInput
    stockMoves?: StockMovementUpdateManyWithoutProductNestedInput
  }

  export type InventoryProductUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stock?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProviderUpsertWithoutLinesInput = {
    update: XOR<ProviderUpdateWithoutLinesInput, ProviderUncheckedUpdateWithoutLinesInput>
    create: XOR<ProviderCreateWithoutLinesInput, ProviderUncheckedCreateWithoutLinesInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutLinesInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutLinesInput, ProviderUncheckedUpdateWithoutLinesInput>
  }

  export type ProviderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    commissions?: ProviderCommissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    commissions?: ProviderCommissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCommissionUpsertWithoutInvoiceLineInput = {
    update: XOR<ProviderCommissionUpdateWithoutInvoiceLineInput, ProviderCommissionUncheckedUpdateWithoutInvoiceLineInput>
    create: XOR<ProviderCommissionCreateWithoutInvoiceLineInput, ProviderCommissionUncheckedCreateWithoutInvoiceLineInput>
    where?: ProviderCommissionWhereInput
  }

  export type ProviderCommissionUpdateToOneWithWhereWithoutInvoiceLineInput = {
    where?: ProviderCommissionWhereInput
    data: XOR<ProviderCommissionUpdateWithoutInvoiceLineInput, ProviderCommissionUncheckedUpdateWithoutInvoiceLineInput>
  }

  export type ProviderCommissionUpdateWithoutInvoiceLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type ProviderCommissionUncheckedUpdateWithoutInvoiceLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateWithoutCommissionInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
    service?: ServiceCreateNestedOneWithoutLinesInput
    product?: InventoryProductCreateNestedOneWithoutLinesInput
    provider?: ProviderCreateNestedOneWithoutLinesInput
  }

  export type InvoiceLineUncheckedCreateWithoutCommissionInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
  }

  export type InvoiceLineCreateOrConnectWithoutCommissionInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutCommissionInput, InvoiceLineUncheckedCreateWithoutCommissionInput>
  }

  export type ProviderCreateWithoutCommissionsInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    lines?: InvoiceLineCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutCommissionsInput = {
    id?: string
    fullName: string
    specialty?: string | null
    defaultCommissionPct?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutCommissionsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutCommissionsInput, ProviderUncheckedCreateWithoutCommissionsInput>
  }

  export type InvoiceLineUpsertWithoutCommissionInput = {
    update: XOR<InvoiceLineUpdateWithoutCommissionInput, InvoiceLineUncheckedUpdateWithoutCommissionInput>
    create: XOR<InvoiceLineCreateWithoutCommissionInput, InvoiceLineUncheckedCreateWithoutCommissionInput>
    where?: InvoiceLineWhereInput
  }

  export type InvoiceLineUpdateToOneWithWhereWithoutCommissionInput = {
    where?: InvoiceLineWhereInput
    data: XOR<InvoiceLineUpdateWithoutCommissionInput, InvoiceLineUncheckedUpdateWithoutCommissionInput>
  }

  export type InvoiceLineUpdateWithoutCommissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
    service?: ServiceUpdateOneWithoutLinesNestedInput
    product?: InventoryProductUpdateOneWithoutLinesNestedInput
    provider?: ProviderUpdateOneWithoutLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutCommissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderUpsertWithoutCommissionsInput = {
    update: XOR<ProviderUpdateWithoutCommissionsInput, ProviderUncheckedUpdateWithoutCommissionsInput>
    create: XOR<ProviderCreateWithoutCommissionsInput, ProviderUncheckedCreateWithoutCommissionsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutCommissionsInput, ProviderUncheckedUpdateWithoutCommissionsInput>
  }

  export type ProviderUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type PosTerminalCreateWithoutPaymentsInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    location: LocationCreateNestedOneWithoutPosTerminalsInput
  }

  export type PosTerminalUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
    locationId: string
  }

  export type PosTerminalCreateOrConnectWithoutPaymentsInput = {
    where: PosTerminalWhereUniqueInput
    create: XOR<PosTerminalCreateWithoutPaymentsInput, PosTerminalUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsCreatedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPaymentsCreatedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPaymentsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
  }

  export type RequestContextCreateWithoutPaymentsInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutPaymentsInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutPaymentsInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutPaymentsInput, RequestContextUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PosTerminalUpsertWithoutPaymentsInput = {
    update: XOR<PosTerminalUpdateWithoutPaymentsInput, PosTerminalUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PosTerminalCreateWithoutPaymentsInput, PosTerminalUncheckedCreateWithoutPaymentsInput>
    where?: PosTerminalWhereInput
  }

  export type PosTerminalUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PosTerminalWhereInput
    data: XOR<PosTerminalUpdateWithoutPaymentsInput, PosTerminalUncheckedUpdateWithoutPaymentsInput>
  }

  export type PosTerminalUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutPosTerminalsNestedInput
  }

  export type PosTerminalUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutPaymentsCreatedInput = {
    update: XOR<UserUpdateWithoutPaymentsCreatedInput, UserUncheckedUpdateWithoutPaymentsCreatedInput>
    create: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsCreatedInput, UserUncheckedUpdateWithoutPaymentsCreatedInput>
  }

  export type UserUpdateWithoutPaymentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type RequestContextUpsertWithoutPaymentsInput = {
    update: XOR<RequestContextUpdateWithoutPaymentsInput, RequestContextUncheckedUpdateWithoutPaymentsInput>
    create: XOR<RequestContextCreateWithoutPaymentsInput, RequestContextUncheckedCreateWithoutPaymentsInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutPaymentsInput, RequestContextUncheckedUpdateWithoutPaymentsInput>
  }

  export type RequestContextUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type CashRegisterCreateWithoutSessionsInput = {
    id?: string
    name: string
    location: LocationCreateNestedOneWithoutRegistersInput
    invoices?: InvoiceCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    locationId: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutSessionsInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutSessionsInput, CashRegisterUncheckedCreateWithoutSessionsInput>
  }

  export type UserCreateWithoutCashSessionsOpenInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCashSessionsOpenInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCashSessionsOpenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashSessionsOpenInput, UserUncheckedCreateWithoutCashSessionsOpenInput>
  }

  export type UserCreateWithoutCashSessionsCloseInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCashSessionsCloseInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCashSessionsCloseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashSessionsCloseInput, UserUncheckedCreateWithoutCashSessionsCloseInput>
  }

  export type CashMovementCreateWithoutSessionInput = {
    id?: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCashMovementsInput
    requestContext: RequestContextCreateNestedOneWithoutCashMovesInput
  }

  export type CashMovementUncheckedCreateWithoutSessionInput = {
    id?: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type CashMovementCreateOrConnectWithoutSessionInput = {
    where: CashMovementWhereUniqueInput
    create: XOR<CashMovementCreateWithoutSessionInput, CashMovementUncheckedCreateWithoutSessionInput>
  }

  export type CashMovementCreateManySessionInputEnvelope = {
    data: CashMovementCreateManySessionInput | CashMovementCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CashRegisterUpsertWithoutSessionsInput = {
    update: XOR<CashRegisterUpdateWithoutSessionsInput, CashRegisterUncheckedUpdateWithoutSessionsInput>
    create: XOR<CashRegisterCreateWithoutSessionsInput, CashRegisterUncheckedCreateWithoutSessionsInput>
    where?: CashRegisterWhereInput
  }

  export type CashRegisterUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CashRegisterWhereInput
    data: XOR<CashRegisterUpdateWithoutSessionsInput, CashRegisterUncheckedUpdateWithoutSessionsInput>
  }

  export type CashRegisterUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutRegistersNestedInput
    invoices?: InvoiceUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type UserUpsertWithoutCashSessionsOpenInput = {
    update: XOR<UserUpdateWithoutCashSessionsOpenInput, UserUncheckedUpdateWithoutCashSessionsOpenInput>
    create: XOR<UserCreateWithoutCashSessionsOpenInput, UserUncheckedCreateWithoutCashSessionsOpenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashSessionsOpenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashSessionsOpenInput, UserUncheckedUpdateWithoutCashSessionsOpenInput>
  }

  export type UserUpdateWithoutCashSessionsOpenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCashSessionsOpenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutCashSessionsCloseInput = {
    update: XOR<UserUpdateWithoutCashSessionsCloseInput, UserUncheckedUpdateWithoutCashSessionsCloseInput>
    create: XOR<UserCreateWithoutCashSessionsCloseInput, UserUncheckedCreateWithoutCashSessionsCloseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashSessionsCloseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashSessionsCloseInput, UserUncheckedUpdateWithoutCashSessionsCloseInput>
  }

  export type UserUpdateWithoutCashSessionsCloseInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCashSessionsCloseInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CashMovementUpsertWithWhereUniqueWithoutSessionInput = {
    where: CashMovementWhereUniqueInput
    update: XOR<CashMovementUpdateWithoutSessionInput, CashMovementUncheckedUpdateWithoutSessionInput>
    create: XOR<CashMovementCreateWithoutSessionInput, CashMovementUncheckedCreateWithoutSessionInput>
  }

  export type CashMovementUpdateWithWhereUniqueWithoutSessionInput = {
    where: CashMovementWhereUniqueInput
    data: XOR<CashMovementUpdateWithoutSessionInput, CashMovementUncheckedUpdateWithoutSessionInput>
  }

  export type CashMovementUpdateManyWithWhereWithoutSessionInput = {
    where: CashMovementScalarWhereInput
    data: XOR<CashMovementUpdateManyMutationInput, CashMovementUncheckedUpdateManyWithoutSessionInput>
  }

  export type CashSessionCreateWithoutMovementsInput = {
    id?: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    register: CashRegisterCreateNestedOneWithoutSessionsInput
    openedBy: UserCreateNestedOneWithoutCashSessionsOpenInput
    closedBy?: UserCreateNestedOneWithoutCashSessionsCloseInput
  }

  export type CashSessionUncheckedCreateWithoutMovementsInput = {
    id?: string
    registerId: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashSessionCreateOrConnectWithoutMovementsInput = {
    where: CashSessionWhereUniqueInput
    create: XOR<CashSessionCreateWithoutMovementsInput, CashSessionUncheckedCreateWithoutMovementsInput>
  }

  export type UserCreateWithoutCashMovementsInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCashMovementsInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCashMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
  }

  export type RequestContextCreateWithoutCashMovesInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutCashMovesInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutCashMovesInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutCashMovesInput, RequestContextUncheckedCreateWithoutCashMovesInput>
  }

  export type CashSessionUpsertWithoutMovementsInput = {
    update: XOR<CashSessionUpdateWithoutMovementsInput, CashSessionUncheckedUpdateWithoutMovementsInput>
    create: XOR<CashSessionCreateWithoutMovementsInput, CashSessionUncheckedCreateWithoutMovementsInput>
    where?: CashSessionWhereInput
  }

  export type CashSessionUpdateToOneWithWhereWithoutMovementsInput = {
    where?: CashSessionWhereInput
    data: XOR<CashSessionUpdateWithoutMovementsInput, CashSessionUncheckedUpdateWithoutMovementsInput>
  }

  export type CashSessionUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    register?: CashRegisterUpdateOneRequiredWithoutSessionsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutCashSessionsOpenNestedInput
    closedBy?: UserUpdateOneWithoutCashSessionsCloseNestedInput
  }

  export type CashSessionUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type UserUpsertWithoutCashMovementsInput = {
    update: XOR<UserUpdateWithoutCashMovementsInput, UserUncheckedUpdateWithoutCashMovementsInput>
    create: XOR<UserCreateWithoutCashMovementsInput, UserUncheckedCreateWithoutCashMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashMovementsInput, UserUncheckedUpdateWithoutCashMovementsInput>
  }

  export type UserUpdateWithoutCashMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCashMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type RequestContextUpsertWithoutCashMovesInput = {
    update: XOR<RequestContextUpdateWithoutCashMovesInput, RequestContextUncheckedUpdateWithoutCashMovesInput>
    create: XOR<RequestContextCreateWithoutCashMovesInput, RequestContextUncheckedCreateWithoutCashMovesInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutCashMovesInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutCashMovesInput, RequestContextUncheckedUpdateWithoutCashMovesInput>
  }

  export type RequestContextUpdateWithoutCashMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutCashMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type ProductStockCreateWithoutProductInput = {
    id?: string
    onHand: number
    location: LocationCreateNestedOneWithoutProductStockInput
  }

  export type ProductStockUncheckedCreateWithoutProductInput = {
    id?: string
    locationId: string
    onHand: number
  }

  export type ProductStockCreateOrConnectWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    create: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
  }

  export type ProductStockCreateManyProductInputEnvelope = {
    data: ProductStockCreateManyProductInput | ProductStockCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutProductInput = {
    id?: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutStockMovesInput
  }

  export type StockMovementUncheckedCreateWithoutProductInput = {
    id?: string
    locationId: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementCreateManyProductInputEnvelope = {
    data: StockMovementCreateManyProductInput | StockMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineCreateWithoutProductInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
    service?: ServiceCreateNestedOneWithoutLinesInput
    provider?: ProviderCreateNestedOneWithoutLinesInput
    commission?: ProviderCommissionCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineUncheckedCreateWithoutProductInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
    commission?: ProviderCommissionUncheckedCreateNestedOneWithoutInvoiceLineInput
  }

  export type InvoiceLineCreateOrConnectWithoutProductInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutProductInput, InvoiceLineUncheckedCreateWithoutProductInput>
  }

  export type InvoiceLineCreateManyProductInputEnvelope = {
    data: InvoiceLineCreateManyProductInput | InvoiceLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    update: XOR<ProductStockUpdateWithoutProductInput, ProductStockUncheckedUpdateWithoutProductInput>
    create: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
  }

  export type ProductStockUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    data: XOR<ProductStockUpdateWithoutProductInput, ProductStockUncheckedUpdateWithoutProductInput>
  }

  export type ProductStockUpdateManyWithWhereWithoutProductInput = {
    where: ProductStockScalarWhereInput
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyWithoutProductInput>
  }

  export type StockMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutProductInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutProductInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutProductInput, InvoiceLineUncheckedUpdateWithoutProductInput>
    create: XOR<InvoiceLineCreateWithoutProductInput, InvoiceLineUncheckedCreateWithoutProductInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutProductInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutProductInput, InvoiceLineUncheckedUpdateWithoutProductInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutProductInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryProductCreateWithoutStockInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stockMoves?: StockMovementCreateNestedManyWithoutProductInput
    lines?: InvoiceLineCreateNestedManyWithoutProductInput
  }

  export type InventoryProductUncheckedCreateWithoutStockInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutProductInput
  }

  export type InventoryProductCreateOrConnectWithoutStockInput = {
    where: InventoryProductWhereUniqueInput
    create: XOR<InventoryProductCreateWithoutStockInput, InventoryProductUncheckedCreateWithoutStockInput>
  }

  export type LocationCreateWithoutProductStockInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutProductStockInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutProductStockInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProductStockInput, LocationUncheckedCreateWithoutProductStockInput>
  }

  export type InventoryProductUpsertWithoutStockInput = {
    update: XOR<InventoryProductUpdateWithoutStockInput, InventoryProductUncheckedUpdateWithoutStockInput>
    create: XOR<InventoryProductCreateWithoutStockInput, InventoryProductUncheckedCreateWithoutStockInput>
    where?: InventoryProductWhereInput
  }

  export type InventoryProductUpdateToOneWithWhereWithoutStockInput = {
    where?: InventoryProductWhereInput
    data: XOR<InventoryProductUpdateWithoutStockInput, InventoryProductUncheckedUpdateWithoutStockInput>
  }

  export type InventoryProductUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stockMoves?: StockMovementUpdateManyWithoutProductNestedInput
    lines?: InvoiceLineUpdateManyWithoutProductNestedInput
  }

  export type InventoryProductUncheckedUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stockMoves?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    lines?: InvoiceLineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type LocationUpsertWithoutProductStockInput = {
    update: XOR<LocationUpdateWithoutProductStockInput, LocationUncheckedUpdateWithoutProductStockInput>
    create: XOR<LocationCreateWithoutProductStockInput, LocationUncheckedCreateWithoutProductStockInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProductStockInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProductStockInput, LocationUncheckedUpdateWithoutProductStockInput>
  }

  export type LocationUpdateWithoutProductStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutProductStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type InventoryProductCreateWithoutStockMovesInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stock?: ProductStockCreateNestedManyWithoutProductInput
    lines?: InvoiceLineCreateNestedManyWithoutProductInput
  }

  export type InventoryProductUncheckedCreateWithoutStockMovesInput = {
    id?: string
    sku: string
    name: string
    unit?: string | null
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    stock?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutProductInput
  }

  export type InventoryProductCreateOrConnectWithoutStockMovesInput = {
    where: InventoryProductWhereUniqueInput
    create: XOR<InventoryProductCreateWithoutStockMovesInput, InventoryProductUncheckedCreateWithoutStockMovesInput>
  }

  export type LocationCreateWithoutStockMovesInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutStockMovesInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    labInstruments?: LabInstrumentUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutStockMovesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockMovesInput, LocationUncheckedCreateWithoutStockMovesInput>
  }

  export type InventoryProductUpsertWithoutStockMovesInput = {
    update: XOR<InventoryProductUpdateWithoutStockMovesInput, InventoryProductUncheckedUpdateWithoutStockMovesInput>
    create: XOR<InventoryProductCreateWithoutStockMovesInput, InventoryProductUncheckedCreateWithoutStockMovesInput>
    where?: InventoryProductWhereInput
  }

  export type InventoryProductUpdateToOneWithWhereWithoutStockMovesInput = {
    where?: InventoryProductWhereInput
    data: XOR<InventoryProductUpdateWithoutStockMovesInput, InventoryProductUncheckedUpdateWithoutStockMovesInput>
  }

  export type InventoryProductUpdateWithoutStockMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stock?: ProductStockUpdateManyWithoutProductNestedInput
    lines?: InvoiceLineUpdateManyWithoutProductNestedInput
  }

  export type InventoryProductUncheckedUpdateWithoutStockMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stock?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    lines?: InvoiceLineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type LocationUpsertWithoutStockMovesInput = {
    update: XOR<LocationUpdateWithoutStockMovesInput, LocationUncheckedUpdateWithoutStockMovesInput>
    create: XOR<LocationCreateWithoutStockMovesInput, LocationUncheckedCreateWithoutStockMovesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockMovesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockMovesInput, LocationUncheckedUpdateWithoutStockMovesInput>
  }

  export type LocationUpdateWithoutStockMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockMovesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    labInstruments?: LabInstrumentUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateWithoutLabInstrumentsInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalCreateNestedManyWithoutLocationInput
    workstations?: WorkstationCreateNestedManyWithoutLocationInput
    productStock?: ProductStockCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementCreateNestedManyWithoutLocationInput
    invoices?: InvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutLabInstrumentsInput = {
    id?: string
    name: string
    address?: string | null
    registers?: CashRegisterUncheckedCreateNestedManyWithoutLocationInput
    posTerminals?: PosTerminalUncheckedCreateNestedManyWithoutLocationInput
    workstations?: WorkstationUncheckedCreateNestedManyWithoutLocationInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutLocationInput
    stockMoves?: StockMovementUncheckedCreateNestedManyWithoutLocationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutLabInstrumentsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutLabInstrumentsInput, LocationUncheckedCreateWithoutLabInstrumentsInput>
  }

  export type TestCatalogCreateWithoutDefaultInstrumentInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    specimenType?: SpecimenTypeCreateNestedOneWithoutTestsInput
    parentPanel?: TestCatalogCreateNestedOneWithoutPanelMembersInput
    panelMembers?: TestCatalogCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateWithoutDefaultInstrumentInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
    panelMembers?: TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeUncheckedCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogCreateOrConnectWithoutDefaultInstrumentInput = {
    where: TestCatalogWhereUniqueInput
    create: XOR<TestCatalogCreateWithoutDefaultInstrumentInput, TestCatalogUncheckedCreateWithoutDefaultInstrumentInput>
  }

  export type TestCatalogCreateManyDefaultInstrumentInputEnvelope = {
    data: TestCatalogCreateManyDefaultInstrumentInput | TestCatalogCreateManyDefaultInstrumentInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderTestCreateWithoutInstrumentInput = {
    id?: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    order: LabOrderCreateNestedOneWithoutTestsInput
    test: TestCatalogCreateNestedOneWithoutOrderTestsInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrderTestsInput
  }

  export type LabOrderTestUncheckedCreateWithoutInstrumentInput = {
    id?: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabOrderTestCreateOrConnectWithoutInstrumentInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutInstrumentInput, LabOrderTestUncheckedCreateWithoutInstrumentInput>
  }

  export type LabOrderTestCreateManyInstrumentInputEnvelope = {
    data: LabOrderTestCreateManyInstrumentInput | LabOrderTestCreateManyInstrumentInput[]
    skipDuplicates?: boolean
  }

  export type LabDeviceMessageCreateWithoutInstrumentInput = {
    id?: string
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
    order?: LabOrderCreateNestedOneWithoutMessagesInput
  }

  export type LabDeviceMessageUncheckedCreateWithoutInstrumentInput = {
    id?: string
    orderId?: string | null
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
  }

  export type LabDeviceMessageCreateOrConnectWithoutInstrumentInput = {
    where: LabDeviceMessageWhereUniqueInput
    create: XOR<LabDeviceMessageCreateWithoutInstrumentInput, LabDeviceMessageUncheckedCreateWithoutInstrumentInput>
  }

  export type LabDeviceMessageCreateManyInstrumentInputEnvelope = {
    data: LabDeviceMessageCreateManyInstrumentInput | LabDeviceMessageCreateManyInstrumentInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutLabInstrumentsInput = {
    update: XOR<LocationUpdateWithoutLabInstrumentsInput, LocationUncheckedUpdateWithoutLabInstrumentsInput>
    create: XOR<LocationCreateWithoutLabInstrumentsInput, LocationUncheckedCreateWithoutLabInstrumentsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutLabInstrumentsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutLabInstrumentsInput, LocationUncheckedUpdateWithoutLabInstrumentsInput>
  }

  export type LocationUpdateWithoutLabInstrumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutLabInstrumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    registers?: CashRegisterUncheckedUpdateManyWithoutLocationNestedInput
    posTerminals?: PosTerminalUncheckedUpdateManyWithoutLocationNestedInput
    workstations?: WorkstationUncheckedUpdateManyWithoutLocationNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutLocationNestedInput
    stockMoves?: StockMovementUncheckedUpdateManyWithoutLocationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type TestCatalogUpsertWithWhereUniqueWithoutDefaultInstrumentInput = {
    where: TestCatalogWhereUniqueInput
    update: XOR<TestCatalogUpdateWithoutDefaultInstrumentInput, TestCatalogUncheckedUpdateWithoutDefaultInstrumentInput>
    create: XOR<TestCatalogCreateWithoutDefaultInstrumentInput, TestCatalogUncheckedCreateWithoutDefaultInstrumentInput>
  }

  export type TestCatalogUpdateWithWhereUniqueWithoutDefaultInstrumentInput = {
    where: TestCatalogWhereUniqueInput
    data: XOR<TestCatalogUpdateWithoutDefaultInstrumentInput, TestCatalogUncheckedUpdateWithoutDefaultInstrumentInput>
  }

  export type TestCatalogUpdateManyWithWhereWithoutDefaultInstrumentInput = {
    where: TestCatalogScalarWhereInput
    data: XOR<TestCatalogUpdateManyMutationInput, TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentInput>
  }

  export type TestCatalogScalarWhereInput = {
    AND?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
    OR?: TestCatalogScalarWhereInput[]
    NOT?: TestCatalogScalarWhereInput | TestCatalogScalarWhereInput[]
    id?: UuidFilter<"TestCatalog"> | string
    code?: StringFilter<"TestCatalog"> | string
    name?: StringFilter<"TestCatalog"> | string
    loincCode?: StringNullableFilter<"TestCatalog"> | string | null
    units?: StringNullableFilter<"TestCatalog"> | string | null
    specimenTypeId?: UuidNullableFilter<"TestCatalog"> | string | null
    defaultInstrumentId?: UuidNullableFilter<"TestCatalog"> | string | null
    isPanel?: BoolFilter<"TestCatalog"> | boolean
    parentPanelId?: UuidNullableFilter<"TestCatalog"> | string | null
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutInstrumentInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutInstrumentInput, LabOrderTestUncheckedUpdateWithoutInstrumentInput>
    create: XOR<LabOrderTestCreateWithoutInstrumentInput, LabOrderTestUncheckedCreateWithoutInstrumentInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutInstrumentInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutInstrumentInput, LabOrderTestUncheckedUpdateWithoutInstrumentInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutInstrumentInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutInstrumentInput>
  }

  export type LabDeviceMessageUpsertWithWhereUniqueWithoutInstrumentInput = {
    where: LabDeviceMessageWhereUniqueInput
    update: XOR<LabDeviceMessageUpdateWithoutInstrumentInput, LabDeviceMessageUncheckedUpdateWithoutInstrumentInput>
    create: XOR<LabDeviceMessageCreateWithoutInstrumentInput, LabDeviceMessageUncheckedCreateWithoutInstrumentInput>
  }

  export type LabDeviceMessageUpdateWithWhereUniqueWithoutInstrumentInput = {
    where: LabDeviceMessageWhereUniqueInput
    data: XOR<LabDeviceMessageUpdateWithoutInstrumentInput, LabDeviceMessageUncheckedUpdateWithoutInstrumentInput>
  }

  export type LabDeviceMessageUpdateManyWithWhereWithoutInstrumentInput = {
    where: LabDeviceMessageScalarWhereInput
    data: XOR<LabDeviceMessageUpdateManyMutationInput, LabDeviceMessageUncheckedUpdateManyWithoutInstrumentInput>
  }

  export type LabDeviceMessageScalarWhereInput = {
    AND?: LabDeviceMessageScalarWhereInput | LabDeviceMessageScalarWhereInput[]
    OR?: LabDeviceMessageScalarWhereInput[]
    NOT?: LabDeviceMessageScalarWhereInput | LabDeviceMessageScalarWhereInput[]
    id?: UuidFilter<"LabDeviceMessage"> | string
    instrumentId?: UuidFilter<"LabDeviceMessage"> | string
    orderId?: UuidNullableFilter<"LabDeviceMessage"> | string | null
    receivedAt?: DateTimeFilter<"LabDeviceMessage"> | Date | string
    protocol?: EnumProtocolKindNullableFilter<"LabDeviceMessage"> | $Enums.ProtocolKind | null
    rawContent?: StringFilter<"LabDeviceMessage"> | string
    parsedOk?: BoolFilter<"LabDeviceMessage"> | boolean
  }

  export type TestCatalogCreateWithoutSpecimenTypeInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    defaultInstrument?: LabInstrumentCreateNestedOneWithoutTestsDefaultInput
    parentPanel?: TestCatalogCreateNestedOneWithoutPanelMembersInput
    panelMembers?: TestCatalogCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateWithoutSpecimenTypeInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
    panelMembers?: TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeUncheckedCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogCreateOrConnectWithoutSpecimenTypeInput = {
    where: TestCatalogWhereUniqueInput
    create: XOR<TestCatalogCreateWithoutSpecimenTypeInput, TestCatalogUncheckedCreateWithoutSpecimenTypeInput>
  }

  export type TestCatalogCreateManySpecimenTypeInputEnvelope = {
    data: TestCatalogCreateManySpecimenTypeInput | TestCatalogCreateManySpecimenTypeInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutSpecimenTypeInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutSpecimenTypeInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutSpecimenTypeInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutSpecimenTypeInput, LabOrderUncheckedCreateWithoutSpecimenTypeInput>
  }

  export type LabOrderCreateManySpecimenTypeInputEnvelope = {
    data: LabOrderCreateManySpecimenTypeInput | LabOrderCreateManySpecimenTypeInput[]
    skipDuplicates?: boolean
  }

  export type TestCatalogUpsertWithWhereUniqueWithoutSpecimenTypeInput = {
    where: TestCatalogWhereUniqueInput
    update: XOR<TestCatalogUpdateWithoutSpecimenTypeInput, TestCatalogUncheckedUpdateWithoutSpecimenTypeInput>
    create: XOR<TestCatalogCreateWithoutSpecimenTypeInput, TestCatalogUncheckedCreateWithoutSpecimenTypeInput>
  }

  export type TestCatalogUpdateWithWhereUniqueWithoutSpecimenTypeInput = {
    where: TestCatalogWhereUniqueInput
    data: XOR<TestCatalogUpdateWithoutSpecimenTypeInput, TestCatalogUncheckedUpdateWithoutSpecimenTypeInput>
  }

  export type TestCatalogUpdateManyWithWhereWithoutSpecimenTypeInput = {
    where: TestCatalogScalarWhereInput
    data: XOR<TestCatalogUpdateManyMutationInput, TestCatalogUncheckedUpdateManyWithoutSpecimenTypeInput>
  }

  export type LabOrderUpsertWithWhereUniqueWithoutSpecimenTypeInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutSpecimenTypeInput, LabOrderUncheckedUpdateWithoutSpecimenTypeInput>
    create: XOR<LabOrderCreateWithoutSpecimenTypeInput, LabOrderUncheckedCreateWithoutSpecimenTypeInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutSpecimenTypeInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutSpecimenTypeInput, LabOrderUncheckedUpdateWithoutSpecimenTypeInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutSpecimenTypeInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutSpecimenTypeInput>
  }

  export type SpecimenTypeCreateWithoutTestsInput = {
    id?: string
    name: string
    orders?: LabOrderCreateNestedManyWithoutSpecimenTypeInput
  }

  export type SpecimenTypeUncheckedCreateWithoutTestsInput = {
    id?: string
    name: string
    orders?: LabOrderUncheckedCreateNestedManyWithoutSpecimenTypeInput
  }

  export type SpecimenTypeCreateOrConnectWithoutTestsInput = {
    where: SpecimenTypeWhereUniqueInput
    create: XOR<SpecimenTypeCreateWithoutTestsInput, SpecimenTypeUncheckedCreateWithoutTestsInput>
  }

  export type LabInstrumentCreateWithoutTestsDefaultInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
    location?: LocationCreateNestedOneWithoutLabInstrumentsInput
    orderTests?: LabOrderTestCreateNestedManyWithoutInstrumentInput
    messages?: LabDeviceMessageCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentUncheckedCreateWithoutTestsDefaultInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    locationId?: string | null
    isActive?: boolean
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutInstrumentInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentCreateOrConnectWithoutTestsDefaultInput = {
    where: LabInstrumentWhereUniqueInput
    create: XOR<LabInstrumentCreateWithoutTestsDefaultInput, LabInstrumentUncheckedCreateWithoutTestsDefaultInput>
  }

  export type TestCatalogCreateWithoutPanelMembersInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    specimenType?: SpecimenTypeCreateNestedOneWithoutTestsInput
    defaultInstrument?: LabInstrumentCreateNestedOneWithoutTestsDefaultInput
    parentPanel?: TestCatalogCreateNestedOneWithoutPanelMembersInput
    ranges?: ReferenceRangeCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateWithoutPanelMembersInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
    ranges?: ReferenceRangeUncheckedCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogCreateOrConnectWithoutPanelMembersInput = {
    where: TestCatalogWhereUniqueInput
    create: XOR<TestCatalogCreateWithoutPanelMembersInput, TestCatalogUncheckedCreateWithoutPanelMembersInput>
  }

  export type TestCatalogCreateWithoutParentPanelInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    specimenType?: SpecimenTypeCreateNestedOneWithoutTestsInput
    defaultInstrument?: LabInstrumentCreateNestedOneWithoutTestsDefaultInput
    panelMembers?: TestCatalogCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateWithoutParentPanelInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    panelMembers?: TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeUncheckedCreateNestedManyWithoutTestInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogCreateOrConnectWithoutParentPanelInput = {
    where: TestCatalogWhereUniqueInput
    create: XOR<TestCatalogCreateWithoutParentPanelInput, TestCatalogUncheckedCreateWithoutParentPanelInput>
  }

  export type TestCatalogCreateManyParentPanelInputEnvelope = {
    data: TestCatalogCreateManyParentPanelInput | TestCatalogCreateManyParentPanelInput[]
    skipDuplicates?: boolean
  }

  export type ReferenceRangeCreateWithoutTestInput = {
    id?: string
    sex?: $Enums.Sex | null
    ageMinYears?: Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: Decimal | DecimalJsLike | number | string | null
    lowValue?: Decimal | DecimalJsLike | number | string | null
    highValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type ReferenceRangeUncheckedCreateWithoutTestInput = {
    id?: string
    sex?: $Enums.Sex | null
    ageMinYears?: Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: Decimal | DecimalJsLike | number | string | null
    lowValue?: Decimal | DecimalJsLike | number | string | null
    highValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type ReferenceRangeCreateOrConnectWithoutTestInput = {
    where: ReferenceRangeWhereUniqueInput
    create: XOR<ReferenceRangeCreateWithoutTestInput, ReferenceRangeUncheckedCreateWithoutTestInput>
  }

  export type ReferenceRangeCreateManyTestInputEnvelope = {
    data: ReferenceRangeCreateManyTestInput | ReferenceRangeCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderTestCreateWithoutTestInput = {
    id?: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    order: LabOrderCreateNestedOneWithoutTestsInput
    instrument?: LabInstrumentCreateNestedOneWithoutOrderTestsInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrderTestsInput
  }

  export type LabOrderTestUncheckedCreateWithoutTestInput = {
    id?: string
    orderId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabOrderTestCreateOrConnectWithoutTestInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput>
  }

  export type LabOrderTestCreateManyTestInputEnvelope = {
    data: LabOrderTestCreateManyTestInput | LabOrderTestCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type SpecimenTypeUpsertWithoutTestsInput = {
    update: XOR<SpecimenTypeUpdateWithoutTestsInput, SpecimenTypeUncheckedUpdateWithoutTestsInput>
    create: XOR<SpecimenTypeCreateWithoutTestsInput, SpecimenTypeUncheckedCreateWithoutTestsInput>
    where?: SpecimenTypeWhereInput
  }

  export type SpecimenTypeUpdateToOneWithWhereWithoutTestsInput = {
    where?: SpecimenTypeWhereInput
    data: XOR<SpecimenTypeUpdateWithoutTestsInput, SpecimenTypeUncheckedUpdateWithoutTestsInput>
  }

  export type SpecimenTypeUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orders?: LabOrderUpdateManyWithoutSpecimenTypeNestedInput
  }

  export type SpecimenTypeUncheckedUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orders?: LabOrderUncheckedUpdateManyWithoutSpecimenTypeNestedInput
  }

  export type LabInstrumentUpsertWithoutTestsDefaultInput = {
    update: XOR<LabInstrumentUpdateWithoutTestsDefaultInput, LabInstrumentUncheckedUpdateWithoutTestsDefaultInput>
    create: XOR<LabInstrumentCreateWithoutTestsDefaultInput, LabInstrumentUncheckedCreateWithoutTestsDefaultInput>
    where?: LabInstrumentWhereInput
  }

  export type LabInstrumentUpdateToOneWithWhereWithoutTestsDefaultInput = {
    where?: LabInstrumentWhereInput
    data: XOR<LabInstrumentUpdateWithoutTestsDefaultInput, LabInstrumentUncheckedUpdateWithoutTestsDefaultInput>
  }

  export type LabInstrumentUpdateWithoutTestsDefaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutLabInstrumentsNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutInstrumentNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentUncheckedUpdateWithoutTestsDefaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutInstrumentNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type TestCatalogUpsertWithoutPanelMembersInput = {
    update: XOR<TestCatalogUpdateWithoutPanelMembersInput, TestCatalogUncheckedUpdateWithoutPanelMembersInput>
    create: XOR<TestCatalogCreateWithoutPanelMembersInput, TestCatalogUncheckedCreateWithoutPanelMembersInput>
    where?: TestCatalogWhereInput
  }

  export type TestCatalogUpdateToOneWithWhereWithoutPanelMembersInput = {
    where?: TestCatalogWhereInput
    data: XOR<TestCatalogUpdateWithoutPanelMembersInput, TestCatalogUncheckedUpdateWithoutPanelMembersInput>
  }

  export type TestCatalogUpdateWithoutPanelMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    specimenType?: SpecimenTypeUpdateOneWithoutTestsNestedInput
    defaultInstrument?: LabInstrumentUpdateOneWithoutTestsDefaultNestedInput
    parentPanel?: TestCatalogUpdateOneWithoutPanelMembersNestedInput
    ranges?: ReferenceRangeUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateWithoutPanelMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    ranges?: ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUpsertWithWhereUniqueWithoutParentPanelInput = {
    where: TestCatalogWhereUniqueInput
    update: XOR<TestCatalogUpdateWithoutParentPanelInput, TestCatalogUncheckedUpdateWithoutParentPanelInput>
    create: XOR<TestCatalogCreateWithoutParentPanelInput, TestCatalogUncheckedCreateWithoutParentPanelInput>
  }

  export type TestCatalogUpdateWithWhereUniqueWithoutParentPanelInput = {
    where: TestCatalogWhereUniqueInput
    data: XOR<TestCatalogUpdateWithoutParentPanelInput, TestCatalogUncheckedUpdateWithoutParentPanelInput>
  }

  export type TestCatalogUpdateManyWithWhereWithoutParentPanelInput = {
    where: TestCatalogScalarWhereInput
    data: XOR<TestCatalogUpdateManyMutationInput, TestCatalogUncheckedUpdateManyWithoutParentPanelInput>
  }

  export type ReferenceRangeUpsertWithWhereUniqueWithoutTestInput = {
    where: ReferenceRangeWhereUniqueInput
    update: XOR<ReferenceRangeUpdateWithoutTestInput, ReferenceRangeUncheckedUpdateWithoutTestInput>
    create: XOR<ReferenceRangeCreateWithoutTestInput, ReferenceRangeUncheckedCreateWithoutTestInput>
  }

  export type ReferenceRangeUpdateWithWhereUniqueWithoutTestInput = {
    where: ReferenceRangeWhereUniqueInput
    data: XOR<ReferenceRangeUpdateWithoutTestInput, ReferenceRangeUncheckedUpdateWithoutTestInput>
  }

  export type ReferenceRangeUpdateManyWithWhereWithoutTestInput = {
    where: ReferenceRangeScalarWhereInput
    data: XOR<ReferenceRangeUpdateManyMutationInput, ReferenceRangeUncheckedUpdateManyWithoutTestInput>
  }

  export type ReferenceRangeScalarWhereInput = {
    AND?: ReferenceRangeScalarWhereInput | ReferenceRangeScalarWhereInput[]
    OR?: ReferenceRangeScalarWhereInput[]
    NOT?: ReferenceRangeScalarWhereInput | ReferenceRangeScalarWhereInput[]
    id?: UuidFilter<"ReferenceRange"> | string
    testId?: UuidFilter<"ReferenceRange"> | string
    sex?: EnumSexNullableFilter<"ReferenceRange"> | $Enums.Sex | null
    ageMinYears?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    lowValue?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    highValue?: DecimalNullableFilter<"ReferenceRange"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"ReferenceRange"> | string | null
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutTestInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutTestInput, LabOrderTestUncheckedUpdateWithoutTestInput>
    create: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutTestInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutTestInput, LabOrderTestUncheckedUpdateWithoutTestInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutTestInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutTestInput>
  }

  export type TestCatalogCreateWithoutRangesInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    specimenType?: SpecimenTypeCreateNestedOneWithoutTestsInput
    defaultInstrument?: LabInstrumentCreateNestedOneWithoutTestsDefaultInput
    parentPanel?: TestCatalogCreateNestedOneWithoutPanelMembersInput
    panelMembers?: TestCatalogCreateNestedManyWithoutParentPanelInput
    orderTests?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateWithoutRangesInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
    panelMembers?: TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogCreateOrConnectWithoutRangesInput = {
    where: TestCatalogWhereUniqueInput
    create: XOR<TestCatalogCreateWithoutRangesInput, TestCatalogUncheckedCreateWithoutRangesInput>
  }

  export type TestCatalogUpsertWithoutRangesInput = {
    update: XOR<TestCatalogUpdateWithoutRangesInput, TestCatalogUncheckedUpdateWithoutRangesInput>
    create: XOR<TestCatalogCreateWithoutRangesInput, TestCatalogUncheckedCreateWithoutRangesInput>
    where?: TestCatalogWhereInput
  }

  export type TestCatalogUpdateToOneWithWhereWithoutRangesInput = {
    where?: TestCatalogWhereInput
    data: XOR<TestCatalogUpdateWithoutRangesInput, TestCatalogUncheckedUpdateWithoutRangesInput>
  }

  export type TestCatalogUpdateWithoutRangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    specimenType?: SpecimenTypeUpdateOneWithoutTestsNestedInput
    defaultInstrument?: LabInstrumentUpdateOneWithoutTestsDefaultNestedInput
    parentPanel?: TestCatalogUpdateOneWithoutPanelMembersNestedInput
    panelMembers?: TestCatalogUpdateManyWithoutParentPanelNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateWithoutRangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    panelMembers?: TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type PatientCreateWithoutLabOrdersInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPatientsCreatedInput
    preclinics?: PreclinicCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
    problems?: ProblemCreateNestedManyWithoutPatientInput
    medications?: MedicationCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
    problems?: ProblemUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLabOrdersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
  }

  export type UserCreateWithoutLabOrdersOrderedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutLabOrdersOrderedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutLabOrdersOrderedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabOrdersOrderedInput, UserUncheckedCreateWithoutLabOrdersOrderedInput>
  }

  export type InvoiceCreateWithoutLabOrdersInput = {
    id?: string
    invoiceNo: string
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    preclinic?: PreclinicCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutInvoicesInput
    cashier: UserCreateNestedOneWithoutInvoicesCashierInput
    register?: CashRegisterCreateNestedOneWithoutInvoicesInput
    requestContext: RequestContextCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLabOrdersInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLabOrdersInput, InvoiceUncheckedCreateWithoutLabOrdersInput>
  }

  export type PreclinicCreateWithoutLabOrdersInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    patient: PatientCreateNestedOneWithoutPreclinicsInput
    recordedBy: UserCreateNestedOneWithoutPreclinicsInput
    requestContext: RequestContextCreateNestedOneWithoutPreclinicsInput
    invoices?: InvoiceCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    requestContextId: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPreclinicInput
  }

  export type PreclinicCreateOrConnectWithoutLabOrdersInput = {
    where: PreclinicWhereUniqueInput
    create: XOR<PreclinicCreateWithoutLabOrdersInput, PreclinicUncheckedCreateWithoutLabOrdersInput>
  }

  export type SpecimenTypeCreateWithoutOrdersInput = {
    id?: string
    name: string
    tests?: TestCatalogCreateNestedManyWithoutSpecimenTypeInput
  }

  export type SpecimenTypeUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    tests?: TestCatalogUncheckedCreateNestedManyWithoutSpecimenTypeInput
  }

  export type SpecimenTypeCreateOrConnectWithoutOrdersInput = {
    where: SpecimenTypeWhereUniqueInput
    create: XOR<SpecimenTypeCreateWithoutOrdersInput, SpecimenTypeUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutLabOrdersCollectedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    activity?: ActivityLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutLabOrdersCollectedInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    activity?: ActivityLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutLabOrdersCollectedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabOrdersCollectedInput, UserUncheckedCreateWithoutLabOrdersCollectedInput>
  }

  export type RequestContextCreateWithoutLabOrdersInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutLabOrdersInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutLabOrdersInput, RequestContextUncheckedCreateWithoutLabOrdersInput>
  }

  export type LabOrderTestCreateWithoutOrderInput = {
    id?: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    test: TestCatalogCreateNestedOneWithoutOrderTestsInput
    instrument?: LabInstrumentCreateNestedOneWithoutOrderTestsInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrderTestsInput
  }

  export type LabOrderTestUncheckedCreateWithoutOrderInput = {
    id?: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabOrderTestCreateOrConnectWithoutOrderInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput>
  }

  export type LabOrderTestCreateManyOrderInputEnvelope = {
    data: LabOrderTestCreateManyOrderInput | LabOrderTestCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type LabDeviceMessageCreateWithoutOrderInput = {
    id?: string
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
    instrument: LabInstrumentCreateNestedOneWithoutMessagesInput
  }

  export type LabDeviceMessageUncheckedCreateWithoutOrderInput = {
    id?: string
    instrumentId: string
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
  }

  export type LabDeviceMessageCreateOrConnectWithoutOrderInput = {
    where: LabDeviceMessageWhereUniqueInput
    create: XOR<LabDeviceMessageCreateWithoutOrderInput, LabDeviceMessageUncheckedCreateWithoutOrderInput>
  }

  export type LabDeviceMessageCreateManyOrderInputEnvelope = {
    data: LabDeviceMessageCreateManyOrderInput | LabDeviceMessageCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutLabOrdersInput = {
    update: XOR<PatientUpdateWithoutLabOrdersInput, PatientUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLabOrdersInput, PatientUncheckedUpdateWithoutLabOrdersInput>
  }

  export type PatientUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPatientsCreatedNestedInput
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutLabOrdersOrderedInput = {
    update: XOR<UserUpdateWithoutLabOrdersOrderedInput, UserUncheckedUpdateWithoutLabOrdersOrderedInput>
    create: XOR<UserCreateWithoutLabOrdersOrderedInput, UserUncheckedCreateWithoutLabOrdersOrderedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabOrdersOrderedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabOrdersOrderedInput, UserUncheckedUpdateWithoutLabOrdersOrderedInput>
  }

  export type UserUpdateWithoutLabOrdersOrderedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutLabOrdersOrderedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type InvoiceUpsertWithoutLabOrdersInput = {
    update: XOR<InvoiceUpdateWithoutLabOrdersInput, InvoiceUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<InvoiceCreateWithoutLabOrdersInput, InvoiceUncheckedCreateWithoutLabOrdersInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLabOrdersInput, InvoiceUncheckedUpdateWithoutLabOrdersInput>
  }

  export type InvoiceUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PreclinicUpsertWithoutLabOrdersInput = {
    update: XOR<PreclinicUpdateWithoutLabOrdersInput, PreclinicUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<PreclinicCreateWithoutLabOrdersInput, PreclinicUncheckedCreateWithoutLabOrdersInput>
    where?: PreclinicWhereInput
  }

  export type PreclinicUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: PreclinicWhereInput
    data: XOR<PreclinicUpdateWithoutLabOrdersInput, PreclinicUncheckedUpdateWithoutLabOrdersInput>
  }

  export type PreclinicUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutPreclinicsNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutPreclinicsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPreclinicsNestedInput
    invoices?: InvoiceUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutPreclinicNestedInput
  }

  export type SpecimenTypeUpsertWithoutOrdersInput = {
    update: XOR<SpecimenTypeUpdateWithoutOrdersInput, SpecimenTypeUncheckedUpdateWithoutOrdersInput>
    create: XOR<SpecimenTypeCreateWithoutOrdersInput, SpecimenTypeUncheckedCreateWithoutOrdersInput>
    where?: SpecimenTypeWhereInput
  }

  export type SpecimenTypeUpdateToOneWithWhereWithoutOrdersInput = {
    where?: SpecimenTypeWhereInput
    data: XOR<SpecimenTypeUpdateWithoutOrdersInput, SpecimenTypeUncheckedUpdateWithoutOrdersInput>
  }

  export type SpecimenTypeUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tests?: TestCatalogUpdateManyWithoutSpecimenTypeNestedInput
  }

  export type SpecimenTypeUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tests?: TestCatalogUncheckedUpdateManyWithoutSpecimenTypeNestedInput
  }

  export type UserUpsertWithoutLabOrdersCollectedInput = {
    update: XOR<UserUpdateWithoutLabOrdersCollectedInput, UserUncheckedUpdateWithoutLabOrdersCollectedInput>
    create: XOR<UserCreateWithoutLabOrdersCollectedInput, UserUncheckedCreateWithoutLabOrdersCollectedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabOrdersCollectedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabOrdersCollectedInput, UserUncheckedUpdateWithoutLabOrdersCollectedInput>
  }

  export type UserUpdateWithoutLabOrdersCollectedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    activity?: ActivityLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutLabOrdersCollectedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    activity?: ActivityLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type RequestContextUpsertWithoutLabOrdersInput = {
    update: XOR<RequestContextUpdateWithoutLabOrdersInput, RequestContextUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<RequestContextCreateWithoutLabOrdersInput, RequestContextUncheckedCreateWithoutLabOrdersInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutLabOrdersInput, RequestContextUncheckedUpdateWithoutLabOrdersInput>
  }

  export type RequestContextUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutOrderInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutOrderInput, LabOrderTestUncheckedUpdateWithoutOrderInput>
    create: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutOrderInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutOrderInput, LabOrderTestUncheckedUpdateWithoutOrderInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutOrderInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutOrderInput>
  }

  export type LabDeviceMessageUpsertWithWhereUniqueWithoutOrderInput = {
    where: LabDeviceMessageWhereUniqueInput
    update: XOR<LabDeviceMessageUpdateWithoutOrderInput, LabDeviceMessageUncheckedUpdateWithoutOrderInput>
    create: XOR<LabDeviceMessageCreateWithoutOrderInput, LabDeviceMessageUncheckedCreateWithoutOrderInput>
  }

  export type LabDeviceMessageUpdateWithWhereUniqueWithoutOrderInput = {
    where: LabDeviceMessageWhereUniqueInput
    data: XOR<LabDeviceMessageUpdateWithoutOrderInput, LabDeviceMessageUncheckedUpdateWithoutOrderInput>
  }

  export type LabDeviceMessageUpdateManyWithWhereWithoutOrderInput = {
    where: LabDeviceMessageScalarWhereInput
    data: XOR<LabDeviceMessageUpdateManyMutationInput, LabDeviceMessageUncheckedUpdateManyWithoutOrderInput>
  }

  export type LabOrderCreateWithoutTestsInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    messages?: LabDeviceMessageCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutTestsInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutTestsInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
  }

  export type TestCatalogCreateWithoutOrderTestsInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    isPanel?: boolean
    specimenType?: SpecimenTypeCreateNestedOneWithoutTestsInput
    defaultInstrument?: LabInstrumentCreateNestedOneWithoutTestsDefaultInput
    parentPanel?: TestCatalogCreateNestedOneWithoutPanelMembersInput
    panelMembers?: TestCatalogCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeCreateNestedManyWithoutTestInput
  }

  export type TestCatalogUncheckedCreateWithoutOrderTestsInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
    panelMembers?: TestCatalogUncheckedCreateNestedManyWithoutParentPanelInput
    ranges?: ReferenceRangeUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCatalogCreateOrConnectWithoutOrderTestsInput = {
    where: TestCatalogWhereUniqueInput
    create: XOR<TestCatalogCreateWithoutOrderTestsInput, TestCatalogUncheckedCreateWithoutOrderTestsInput>
  }

  export type LabInstrumentCreateWithoutOrderTestsInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
    location?: LocationCreateNestedOneWithoutLabInstrumentsInput
    testsDefault?: TestCatalogCreateNestedManyWithoutDefaultInstrumentInput
    messages?: LabDeviceMessageCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentUncheckedCreateWithoutOrderTestsInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    locationId?: string | null
    isActive?: boolean
    testsDefault?: TestCatalogUncheckedCreateNestedManyWithoutDefaultInstrumentInput
    messages?: LabDeviceMessageUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentCreateOrConnectWithoutOrderTestsInput = {
    where: LabInstrumentWhereUniqueInput
    create: XOR<LabInstrumentCreateWithoutOrderTestsInput, LabInstrumentUncheckedCreateWithoutOrderTestsInput>
  }

  export type RequestContextCreateWithoutLabOrderTestsInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutLabOrderTestsInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutLabOrderTestsInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutLabOrderTestsInput, RequestContextUncheckedCreateWithoutLabOrderTestsInput>
  }

  export type LabOrderUpsertWithoutTestsInput = {
    update: XOR<LabOrderUpdateWithoutTestsInput, LabOrderUncheckedUpdateWithoutTestsInput>
    create: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
    where?: LabOrderWhereInput
  }

  export type LabOrderUpdateToOneWithWhereWithoutTestsInput = {
    where?: LabOrderWhereInput
    data: XOR<LabOrderUpdateWithoutTestsInput, LabOrderUncheckedUpdateWithoutTestsInput>
  }

  export type LabOrderUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type TestCatalogUpsertWithoutOrderTestsInput = {
    update: XOR<TestCatalogUpdateWithoutOrderTestsInput, TestCatalogUncheckedUpdateWithoutOrderTestsInput>
    create: XOR<TestCatalogCreateWithoutOrderTestsInput, TestCatalogUncheckedCreateWithoutOrderTestsInput>
    where?: TestCatalogWhereInput
  }

  export type TestCatalogUpdateToOneWithWhereWithoutOrderTestsInput = {
    where?: TestCatalogWhereInput
    data: XOR<TestCatalogUpdateWithoutOrderTestsInput, TestCatalogUncheckedUpdateWithoutOrderTestsInput>
  }

  export type TestCatalogUpdateWithoutOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    specimenType?: SpecimenTypeUpdateOneWithoutTestsNestedInput
    defaultInstrument?: LabInstrumentUpdateOneWithoutTestsDefaultNestedInput
    parentPanel?: TestCatalogUpdateOneWithoutPanelMembersNestedInput
    panelMembers?: TestCatalogUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateWithoutOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    panelMembers?: TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput
  }

  export type LabInstrumentUpsertWithoutOrderTestsInput = {
    update: XOR<LabInstrumentUpdateWithoutOrderTestsInput, LabInstrumentUncheckedUpdateWithoutOrderTestsInput>
    create: XOR<LabInstrumentCreateWithoutOrderTestsInput, LabInstrumentUncheckedCreateWithoutOrderTestsInput>
    where?: LabInstrumentWhereInput
  }

  export type LabInstrumentUpdateToOneWithWhereWithoutOrderTestsInput = {
    where?: LabInstrumentWhereInput
    data: XOR<LabInstrumentUpdateWithoutOrderTestsInput, LabInstrumentUncheckedUpdateWithoutOrderTestsInput>
  }

  export type LabInstrumentUpdateWithoutOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutLabInstrumentsNestedInput
    testsDefault?: TestCatalogUpdateManyWithoutDefaultInstrumentNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentUncheckedUpdateWithoutOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    testsDefault?: TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type RequestContextUpsertWithoutLabOrderTestsInput = {
    update: XOR<RequestContextUpdateWithoutLabOrderTestsInput, RequestContextUncheckedUpdateWithoutLabOrderTestsInput>
    create: XOR<RequestContextCreateWithoutLabOrderTestsInput, RequestContextUncheckedCreateWithoutLabOrderTestsInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutLabOrderTestsInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutLabOrderTestsInput, RequestContextUncheckedUpdateWithoutLabOrderTestsInput>
  }

  export type RequestContextUpdateWithoutLabOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutLabOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type LabInstrumentCreateWithoutMessagesInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
    location?: LocationCreateNestedOneWithoutLabInstrumentsInput
    testsDefault?: TestCatalogCreateNestedManyWithoutDefaultInstrumentInput
    orderTests?: LabOrderTestCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    locationId?: string | null
    isActive?: boolean
    testsDefault?: TestCatalogUncheckedCreateNestedManyWithoutDefaultInstrumentInput
    orderTests?: LabOrderTestUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type LabInstrumentCreateOrConnectWithoutMessagesInput = {
    where: LabInstrumentWhereUniqueInput
    create: XOR<LabInstrumentCreateWithoutMessagesInput, LabInstrumentUncheckedCreateWithoutMessagesInput>
  }

  export type LabOrderCreateWithoutMessagesInput = {
    id?: string
    accessionNo: string
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    orderingProvider?: UserCreateNestedOneWithoutLabOrdersOrderedInput
    invoice?: InvoiceCreateNestedOneWithoutLabOrdersInput
    preclinic?: PreclinicCreateNestedOneWithoutLabOrdersInput
    specimenType?: SpecimenTypeCreateNestedOneWithoutOrdersInput
    collectedBy?: UserCreateNestedOneWithoutLabOrdersCollectedInput
    requestContext: RequestContextCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutMessagesInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutMessagesInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutMessagesInput, LabOrderUncheckedCreateWithoutMessagesInput>
  }

  export type LabInstrumentUpsertWithoutMessagesInput = {
    update: XOR<LabInstrumentUpdateWithoutMessagesInput, LabInstrumentUncheckedUpdateWithoutMessagesInput>
    create: XOR<LabInstrumentCreateWithoutMessagesInput, LabInstrumentUncheckedCreateWithoutMessagesInput>
    where?: LabInstrumentWhereInput
  }

  export type LabInstrumentUpdateToOneWithWhereWithoutMessagesInput = {
    where?: LabInstrumentWhereInput
    data: XOR<LabInstrumentUpdateWithoutMessagesInput, LabInstrumentUncheckedUpdateWithoutMessagesInput>
  }

  export type LabInstrumentUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutLabInstrumentsNestedInput
    testsDefault?: TestCatalogUpdateManyWithoutDefaultInstrumentNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    testsDefault?: TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type LabOrderUpsertWithoutMessagesInput = {
    update: XOR<LabOrderUpdateWithoutMessagesInput, LabOrderUncheckedUpdateWithoutMessagesInput>
    create: XOR<LabOrderCreateWithoutMessagesInput, LabOrderUncheckedCreateWithoutMessagesInput>
    where?: LabOrderWhereInput
  }

  export type LabOrderUpdateToOneWithWhereWithoutMessagesInput = {
    where?: LabOrderWhereInput
    data: XOR<LabOrderUpdateWithoutMessagesInput, LabOrderUncheckedUpdateWithoutMessagesInput>
  }

  export type LabOrderUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutActivityInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: AuthSessionCreateNestedManyWithoutUserInput
    patientsCreated?: PatientCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderCreateNestedManyWithoutCollectedByInput
  }

  export type UserUncheckedCreateWithoutActivityInput = {
    id?: string
    username: string
    fullName: string
    email: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    patientsCreated?: PatientUncheckedCreateNestedManyWithoutCreatedByInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRecordedByInput
    problemsRecorded?: ProblemUncheckedCreateNestedManyWithoutRecordedByInput
    allergiesRecorded?: AllergyUncheckedCreateNestedManyWithoutRecordedByInput
    medicationsRx?: MedicationUncheckedCreateNestedManyWithoutPrescribedByInput
    invoicesCashier?: InvoiceUncheckedCreateNestedManyWithoutCashierInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    cashSessionsOpen?: CashSessionUncheckedCreateNestedManyWithoutOpenedByInput
    cashSessionsClose?: CashSessionUncheckedCreateNestedManyWithoutClosedByInput
    cashMovements?: CashMovementUncheckedCreateNestedManyWithoutCreatedByInput
    labOrdersOrdered?: LabOrderUncheckedCreateNestedManyWithoutOrderingProviderInput
    labOrdersCollected?: LabOrderUncheckedCreateNestedManyWithoutCollectedByInput
  }

  export type UserCreateOrConnectWithoutActivityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
  }

  export type RequestContextCreateWithoutActivitiesInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    session: AuthSessionCreateNestedOneWithoutContextsInput
    workstation?: WorkstationCreateNestedOneWithoutContextsInput
    invoices?: InvoiceCreateNestedManyWithoutRequestContextInput
    payments?: PaymentCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextUncheckedCreateWithoutActivitiesInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRequestContextInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRequestContextInput
    cashMoves?: CashMovementUncheckedCreateNestedManyWithoutRequestContextInput
    preclinics?: PreclinicUncheckedCreateNestedManyWithoutRequestContextInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutRequestContextInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutRequestContextInput
  }

  export type RequestContextCreateOrConnectWithoutActivitiesInput = {
    where: RequestContextWhereUniqueInput
    create: XOR<RequestContextCreateWithoutActivitiesInput, RequestContextUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivityInput = {
    update: XOR<UserUpdateWithoutActivityInput, UserUncheckedUpdateWithoutActivityInput>
    create: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityInput, UserUncheckedUpdateWithoutActivityInput>
  }

  export type UserUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUpdateManyWithoutCollectedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    patientsCreated?: PatientUncheckedUpdateManyWithoutCreatedByNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRecordedByNestedInput
    problemsRecorded?: ProblemUncheckedUpdateManyWithoutRecordedByNestedInput
    allergiesRecorded?: AllergyUncheckedUpdateManyWithoutRecordedByNestedInput
    medicationsRx?: MedicationUncheckedUpdateManyWithoutPrescribedByNestedInput
    invoicesCashier?: InvoiceUncheckedUpdateManyWithoutCashierNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    cashSessionsOpen?: CashSessionUncheckedUpdateManyWithoutOpenedByNestedInput
    cashSessionsClose?: CashSessionUncheckedUpdateManyWithoutClosedByNestedInput
    cashMovements?: CashMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    labOrdersOrdered?: LabOrderUncheckedUpdateManyWithoutOrderingProviderNestedInput
    labOrdersCollected?: LabOrderUncheckedUpdateManyWithoutCollectedByNestedInput
  }

  export type RequestContextUpsertWithoutActivitiesInput = {
    update: XOR<RequestContextUpdateWithoutActivitiesInput, RequestContextUncheckedUpdateWithoutActivitiesInput>
    create: XOR<RequestContextCreateWithoutActivitiesInput, RequestContextUncheckedCreateWithoutActivitiesInput>
    where?: RequestContextWhereInput
  }

  export type RequestContextUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: RequestContextWhereInput
    data: XOR<RequestContextUpdateWithoutActivitiesInput, RequestContextUncheckedUpdateWithoutActivitiesInput>
  }

  export type RequestContextUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: string
  }

  export type AuthSessionCreateManyUserInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
  }

  export type PatientCreateManyCreatedByInput = {
    id?: string
    mrn: string
    nationalId?: string | null
    firstName: string
    lastName: string
    dob?: Date | string | null
    sex?: $Enums.Sex | null
    maritalStatus?: $Enums.MaritalStatus | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    region?: string | null
    country?: string | null
    bloodType?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreclinicCreateManyRecordedByInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    requestContextId: string
  }

  export type ProblemCreateManyRecordedByInput = {
    id?: string
    patientId: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
  }

  export type AllergyCreateManyRecordedByInput = {
    id?: string
    patientId: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
  }

  export type MedicationCreateManyPrescribedByInput = {
    id?: string
    patientId: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
  }

  export type InvoiceCreateManyCashierInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyCreatedByInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    requestContextId: string
    createdAt?: Date | string
  }

  export type CashSessionCreateManyOpenedByInput = {
    id?: string
    registerId: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashSessionCreateManyClosedByInput = {
    id?: string
    registerId: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashMovementCreateManyCreatedByInput = {
    id?: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    requestContextId: string
    createdAt?: Date | string
  }

  export type LabOrderCreateManyOrderingProviderInput = {
    id?: string
    accessionNo: string
    patientId: string
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type LabOrderCreateManyCollectedByInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type ActivityLogCreateManyActorInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    requestContextId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    workstation?: WorkstationUpdateOneWithoutSessionsNestedInput
    contexts?: RequestContextUpdateManyWithoutSessionNestedInput
  }

  export type AuthSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    contexts?: RequestContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PatientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
    problems?: ProblemUpdateManyWithoutPatientNestedInput
    medications?: MedicationUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preclinics?: PreclinicUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
    problems?: ProblemUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreclinicUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutPreclinicsNestedInput
    labOrders?: LabOrderUpdateManyWithoutPreclinicNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPreclinicsNestedInput
    invoices?: InvoiceUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    labOrders?: LabOrderUncheckedUpdateManyWithoutPreclinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type ProblemUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type ProblemUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProblemUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllergyUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAllergiesNestedInput
  }

  export type AllergyUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergyUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUpdateWithoutPrescribedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type MedicationUncheckedUpdateWithoutPrescribedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MedicationUncheckedUpdateManyWithoutPrescribedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCashierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    posTerminal?: PosTerminalUpdateOneWithoutPaymentsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashSessionUpdateWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    register?: CashRegisterUpdateOneRequiredWithoutSessionsNestedInput
    closedBy?: UserUpdateOneWithoutCashSessionsCloseNestedInput
    movements?: CashMovementUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateManyWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashSessionUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    register?: CashRegisterUpdateOneRequiredWithoutSessionsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutCashSessionsOpenNestedInput
    movements?: CashMovementUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateManyWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashMovementUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CashSessionUpdateOneRequiredWithoutMovementsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutCashMovesNestedInput
  }

  export type CashMovementUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderUpdateWithoutOrderingProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutOrderingProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutOrderingProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderUpdateWithoutCollectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutCollectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutCollectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestContext?: RequestContextUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterCreateManyLocationInput = {
    id?: string
    name: string
  }

  export type PosTerminalCreateManyLocationInput = {
    id?: string
    name: string
    provider: string
    merchantId?: string | null
  }

  export type WorkstationCreateManyLocationInput = {
    id?: string
    name: string
    type: $Enums.WorkstationType
    macAddress?: string | null
    allowedIpCidr?: string | null
    isActive?: boolean
  }

  export type ProductStockCreateManyLocationInput = {
    id?: string
    productId: string
    onHand: number
  }

  export type StockMovementCreateManyLocationInput = {
    id?: string
    productId: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
  }

  export type LabInstrumentCreateManyLocationInput = {
    id?: string
    name: string
    vendor?: string | null
    model?: string | null
    serialNo?: string | null
    connectionType?: $Enums.ConnectionType | null
    isActive?: boolean
  }

  export type InvoiceCreateManyLocationInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type CashRegisterUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sessions?: CashSessionUpdateManyWithoutRegisterNestedInput
    invoices?: InvoiceUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sessions?: CashSessionUncheckedUpdateManyWithoutRegisterNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PosTerminalUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUpdateManyWithoutPosTerminalNestedInput
  }

  export type PosTerminalUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutPosTerminalNestedInput
  }

  export type PosTerminalUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkstationUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sessions?: AuthSessionUpdateManyWithoutWorkstationNestedInput
    contexts?: RequestContextUpdateManyWithoutWorkstationNestedInput
  }

  export type WorkstationUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sessions?: AuthSessionUncheckedUpdateManyWithoutWorkstationNestedInput
    contexts?: RequestContextUncheckedUpdateManyWithoutWorkstationNestedInput
  }

  export type WorkstationUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkstationTypeFieldUpdateOperationsInput | $Enums.WorkstationType
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpCidr?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductStockUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
    product?: InventoryProductUpdateOneRequiredWithoutStockNestedInput
  }

  export type ProductStockUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type ProductStockUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type StockMovementUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: InventoryProductUpdateOneRequiredWithoutStockMovesNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabInstrumentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    testsDefault?: TestCatalogUpdateManyWithoutDefaultInstrumentNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutInstrumentNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    testsDefault?: TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutInstrumentNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type LabInstrumentUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    connectionType?: NullableEnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CashSessionCreateManyRegisterInput = {
    id?: string
    openedById: string
    openedAt?: Date | string
    openingFloat: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    declaredTotal?: Decimal | DecimalJsLike | number | string | null
    systemTotal?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
  }

  export type InvoiceCreateManyRegisterInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type CashSessionUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    openedBy?: UserUpdateOneRequiredWithoutCashSessionsOpenNestedInput
    closedBy?: UserUpdateOneWithoutCashSessionsCloseNestedInput
    movements?: CashMovementUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    movements?: CashMovementUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CashSessionUncheckedUpdateManyWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedById?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingFloat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declaredTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    systemTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type InvoiceUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyPosTerminalInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type PaymentUpdateWithoutPosTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPosTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPosTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateManyWorkstationInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
    mfaPassed?: boolean
  }

  export type RequestContextCreateManyWorkstationInput = {
    id?: string
    sessionId: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
  }

  export type AuthSessionUpdateWithoutWorkstationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    contexts?: RequestContextUpdateManyWithoutSessionNestedInput
  }

  export type AuthSessionUncheckedUpdateWithoutWorkstationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
    contexts?: RequestContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AuthSessionUncheckedUpdateManyWithoutWorkstationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mfaPassed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestContextUpdateWithoutWorkstationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session?: AuthSessionUpdateOneRequiredWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutWorkstationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateManyWithoutWorkstationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PreclinicCreateManyPatientInput = {
    id?: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
    requestContextId: string
  }

  export type AllergyCreateManyPatientInput = {
    id?: string
    substance: string
    reaction?: string | null
    severity?: $Enums.AllergySeverity | null
    recordedAt?: Date | string
    recordedById?: string | null
  }

  export type ProblemCreateManyPatientInput = {
    id?: string
    condition: string
    status: $Enums.ProblemStatus
    diagnosedAt?: Date | string | null
    resolvedAt?: Date | string | null
    recordedById?: string | null
  }

  export type MedicationCreateManyPatientInput = {
    id?: string
    drugName: string
    dose?: string | null
    frequency?: string | null
    route?: $Enums.Route | null
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    prescribedById?: string | null
  }

  export type InvoiceCreateManyPatientInput = {
    id?: string
    invoiceNo: string
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type LabOrderCreateManyPatientInput = {
    id?: string
    accessionNo: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type PreclinicUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    labOrders?: LabOrderUpdateManyWithoutPreclinicNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutPreclinicsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPreclinicsNestedInput
    invoices?: InvoiceUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    labOrders?: LabOrderUncheckedUpdateManyWithoutPreclinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: UserUpdateOneWithoutAllergiesRecordedNestedInput
  }

  export type AllergyUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumAllergySeverityFieldUpdateOperationsInput | $Enums.AllergySeverity | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProblemUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: UserUpdateOneWithoutProblemsRecordedNestedInput
  }

  export type ProblemUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProblemUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    status?: EnumProblemStatusFieldUpdateOperationsInput | $Enums.ProblemStatus
    diagnosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedBy?: UserUpdateOneWithoutMedicationsRxNestedInput
  }

  export type MedicationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableEnumRouteFieldUpdateOperationsInput | $Enums.Route | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LabOrderUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type RequestContextCreateManySessionInput = {
    id?: string
    occurredAt?: Date | string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    workstationId?: string | null
    geoCountry?: string | null
    geoRegion?: string | null
    geoCity?: string | null
    geoLat?: Decimal | DecimalJsLike | number | string | null
    geoLon?: Decimal | DecimalJsLike | number | string | null
  }

  export type RequestContextUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    workstation?: WorkstationUpdateOneWithoutContextsNestedInput
    invoices?: InvoiceUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutRequestContextNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRequestContextNestedInput
    cashMoves?: CashMovementUncheckedUpdateManyWithoutRequestContextNestedInput
    preclinics?: PreclinicUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutRequestContextNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutRequestContextNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutRequestContextNestedInput
  }

  export type RequestContextUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    workstationId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoLat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLon?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type InvoiceCreateManyRequestContextInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    preclinicId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyRequestContextInput = {
    id?: string
    invoiceId: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type CashMovementCreateManyRequestContextInput = {
    id?: string
    sessionId: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type PreclinicCreateManyRequestContextInput = {
    id?: string
    patientId: string
    visitDate: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    respRate?: number | null
    temperatureC?: Decimal | DecimalJsLike | number | string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    bmi?: Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: string | null
    currentMedications?: string | null
    diabetes?: boolean | null
    hypertension?: boolean | null
    otherConditions?: string | null
    allergiesReported?: string | null
    recordedById: string
  }

  export type LabOrderCreateManyRequestContextInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
  }

  export type LabOrderTestCreateManyRequestContextInput = {
    id?: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
  }

  export type ActivityLogCreateManyRequestContextInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    actorId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InvoiceUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    preclinic?: PreclinicUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    posTerminal?: PosTerminalUpdateOneWithoutPaymentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: CashSessionUpdateOneRequiredWithoutMovementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCashMovementsNestedInput
  }

  export type CashMovementUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreclinicUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutPreclinicsNestedInput
    labOrders?: LabOrderUpdateManyWithoutPreclinicNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutPreclinicsNestedInput
    invoices?: InvoiceUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
    labOrders?: LabOrderUncheckedUpdateManyWithoutPreclinicNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPreclinicNestedInput
  }

  export type PreclinicUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bmi?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    diabetes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypertension?: NullableBoolFieldUpdateOperationsInput | boolean | null
    otherConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergiesReported?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
    test?: TestCatalogUpdateOneRequiredWithoutOrderTestsNestedInput
    instrument?: LabInstrumentUpdateOneWithoutOrderTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutActivityNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutRequestContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderCreateManyPreclinicInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type InvoiceCreateManyPreclinicInput = {
    id?: string
    invoiceNo: string
    patientId?: string | null
    status: $Enums.InvoiceStatus
    invoiceAt: Date | string
    locationId: string
    cashierId: string
    registerId?: string | null
    requestContextId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type LabOrderUpdateWithoutPreclinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutPreclinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutPreclinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpdateWithoutPreclinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutInvoicesNestedInput
    cashier?: UserUpdateOneRequiredWithoutInvoicesCashierNestedInput
    register?: CashRegisterUpdateOneWithoutInvoicesNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPreclinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPreclinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    cashierId?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceCreateManyCategoryInput = {
    id?: string
    code: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    commissionPct?: Decimal | DecimalJsLike | number | string | null
    requiresProvider?: boolean
  }

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresProvider?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateManyServiceInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
  }

  export type InvoiceLineUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
    product?: InventoryProductUpdateOneWithoutLinesNestedInput
    provider?: ProviderUpdateOneWithoutLinesNestedInput
    commission?: ProviderCommissionUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: ProviderCommissionUncheckedUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceLineCreateManyProviderInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type ProviderCommissionCreateManyProviderInput = {
    id?: string
    invoiceLineId: string
    baseAmount: Decimal | DecimalJsLike | number | string
    ratePct: Decimal | DecimalJsLike | number | string
    commissionAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
  }

  export type InvoiceLineUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
    service?: ServiceUpdateOneWithoutLinesNestedInput
    product?: InventoryProductUpdateOneWithoutLinesNestedInput
    commission?: ProviderCommissionUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission?: ProviderCommissionUncheckedUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProviderCommissionUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    invoiceLine?: InvoiceLineUpdateOneRequiredWithoutCommissionNestedInput
  }

  export type ProviderCommissionUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceLineId?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderCommissionUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceLineId?: StringFieldUpdateOperationsInput | string
    baseAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    id?: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    productId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    method: $Enums.PaymentMethod
    transferStatus?: $Enums.TransferStatus | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    posTerminalId?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type LabOrderCreateManyInvoiceInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    preclinicId?: string | null
    specimenTypeId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    service?: ServiceUpdateOneWithoutLinesNestedInput
    product?: InventoryProductUpdateOneWithoutLinesNestedInput
    provider?: ProviderUpdateOneWithoutLinesNestedInput
    commission?: ProviderCommissionUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: ProviderCommissionUncheckedUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posTerminal?: PosTerminalUpdateOneWithoutPaymentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transferStatus?: NullableEnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    posTerminalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    specimenType?: SpecimenTypeUpdateOneWithoutOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type CashMovementCreateManySessionInput = {
    id?: string
    type: $Enums.CashMovementType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdById: string
    requestContextId: string
    createdAt?: Date | string
  }

  export type CashMovementUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCashMovementsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutCashMovesNestedInput
  }

  export type CashMovementUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashMovementUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashMovementTypeFieldUpdateOperationsInput | $Enums.CashMovementType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    requestContextId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateManyProductInput = {
    id?: string
    locationId: string
    onHand: number
  }

  export type StockMovementCreateManyProductInput = {
    id?: string
    locationId: string
    qty: number
    reason: $Enums.StockReason
    reference?: string | null
    createdAt?: Date | string
  }

  export type InvoiceLineCreateManyProductInput = {
    id?: string
    invoiceId: string
    lineNo: number
    itemType: $Enums.ItemType
    serviceId?: string | null
    description: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPct: Decimal | DecimalJsLike | number | string
    taxRatePct: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    providerId?: string | null
  }

  export type ProductStockUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
    location?: LocationUpdateOneRequiredWithoutProductStockNestedInput
  }

  export type ProductStockUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type ProductStockUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: IntFieldUpdateOperationsInput | number
  }

  export type StockMovementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutStockMovesNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    reason?: EnumStockReasonFieldUpdateOperationsInput | $Enums.StockReason
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
    service?: ServiceUpdateOneWithoutLinesNestedInput
    provider?: ProviderUpdateOneWithoutLinesNestedInput
    commission?: ProviderCommissionUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    commission?: ProviderCommissionUncheckedUpdateOneWithoutInvoiceLineNestedInput
  }

  export type InvoiceLineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNo?: IntFieldUpdateOperationsInput | number
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRatePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestCatalogCreateManyDefaultInstrumentInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
  }

  export type LabOrderTestCreateManyInstrumentInput = {
    id?: string
    orderId: string
    testId: string
    status: $Enums.LabOrderTestStatus
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabDeviceMessageCreateManyInstrumentInput = {
    id?: string
    orderId?: string | null
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
  }

  export type TestCatalogUpdateWithoutDefaultInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    specimenType?: SpecimenTypeUpdateOneWithoutTestsNestedInput
    parentPanel?: TestCatalogUpdateOneWithoutPanelMembersNestedInput
    panelMembers?: TestCatalogUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateWithoutDefaultInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    panelMembers?: TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateManyWithoutDefaultInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
    test?: TestCatalogUpdateOneRequiredWithoutOrderTestsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrderTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestUncheckedUpdateManyWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabDeviceMessageUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
    order?: LabOrderUpdateOneWithoutMessagesNestedInput
  }

  export type LabDeviceMessageUncheckedUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabDeviceMessageUncheckedUpdateManyWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestCatalogCreateManySpecimenTypeInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
    parentPanelId?: string | null
  }

  export type LabOrderCreateManySpecimenTypeInput = {
    id?: string
    accessionNo: string
    patientId: string
    orderingProviderId?: string | null
    invoiceId?: string | null
    preclinicId?: string | null
    collectionTime?: Date | string | null
    collectedById?: string | null
    priority?: $Enums.Priority | null
    status: $Enums.LabOrderStatus
    notes?: string | null
    requestContextId: string
  }

  export type TestCatalogUpdateWithoutSpecimenTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    defaultInstrument?: LabInstrumentUpdateOneWithoutTestsDefaultNestedInput
    parentPanel?: TestCatalogUpdateOneWithoutPanelMembersNestedInput
    panelMembers?: TestCatalogUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateWithoutSpecimenTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
    panelMembers?: TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateManyWithoutSpecimenTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    parentPanelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderUpdateWithoutSpecimenTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    orderingProvider?: UserUpdateOneWithoutLabOrdersOrderedNestedInput
    invoice?: InvoiceUpdateOneWithoutLabOrdersNestedInput
    preclinic?: PreclinicUpdateOneWithoutLabOrdersNestedInput
    collectedBy?: UserUpdateOneWithoutLabOrdersCollectedNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutSpecimenTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
    messages?: LabDeviceMessageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutSpecimenTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNo?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderingProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    preclinicId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type TestCatalogCreateManyParentPanelInput = {
    id?: string
    code: string
    name: string
    loincCode?: string | null
    units?: string | null
    specimenTypeId?: string | null
    defaultInstrumentId?: string | null
    isPanel?: boolean
  }

  export type ReferenceRangeCreateManyTestInput = {
    id?: string
    sex?: $Enums.Sex | null
    ageMinYears?: Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: Decimal | DecimalJsLike | number | string | null
    lowValue?: Decimal | DecimalJsLike | number | string | null
    highValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type LabOrderTestCreateManyTestInput = {
    id?: string
    orderId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type TestCatalogUpdateWithoutParentPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    specimenType?: SpecimenTypeUpdateOneWithoutTestsNestedInput
    defaultInstrument?: LabInstrumentUpdateOneWithoutTestsDefaultNestedInput
    panelMembers?: TestCatalogUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateWithoutParentPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
    panelMembers?: TestCatalogUncheckedUpdateManyWithoutParentPanelNestedInput
    ranges?: ReferenceRangeUncheckedUpdateManyWithoutTestNestedInput
    orderTests?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCatalogUncheckedUpdateManyWithoutParentPanelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    loincCode?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    specimenTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultInstrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPanel?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferenceRangeUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceRangeUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceRangeUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    ageMinYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageMaxYears?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
    instrument?: LabInstrumentUpdateOneWithoutOrderTestsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrderTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestCreateManyOrderInput = {
    id?: string
    testId: string
    status: $Enums.LabOrderTestStatus
    instrumentId?: string | null
    analyteCodeInstrument?: string | null
    resultValue?: Decimal | DecimalJsLike | number | string | null
    resultText?: string | null
    units?: string | null
    flagAbnormal?: $Enums.AbnormalFlag | null
    outOfRange?: $Enums.OutOfRangeFlag | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    completedAt?: Date | string | null
    resultNotes?: string | null
    requestContextId: string
  }

  export type LabDeviceMessageCreateManyOrderInput = {
    id?: string
    instrumentId: string
    receivedAt?: Date | string
    protocol?: $Enums.ProtocolKind | null
    rawContent: string
    parsedOk?: boolean
  }

  export type LabOrderTestUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    test?: TestCatalogUpdateOneRequiredWithoutOrderTestsNestedInput
    instrument?: LabInstrumentUpdateOneWithoutOrderTestsNestedInput
    requestContext?: RequestContextUpdateOneRequiredWithoutLabOrderTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderTestStatusFieldUpdateOperationsInput | $Enums.LabOrderTestStatus
    instrumentId?: NullableStringFieldUpdateOperationsInput | string | null
    analyteCodeInstrument?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    resultText?: NullableStringFieldUpdateOperationsInput | string | null
    units?: NullableStringFieldUpdateOperationsInput | string | null
    flagAbnormal?: NullableEnumAbnormalFlagFieldUpdateOperationsInput | $Enums.AbnormalFlag | null
    outOfRange?: NullableEnumOutOfRangeFlagFieldUpdateOperationsInput | $Enums.OutOfRangeFlag | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultNotes?: NullableStringFieldUpdateOperationsInput | string | null
    requestContextId?: StringFieldUpdateOperationsInput | string
  }

  export type LabDeviceMessageUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
    instrument?: LabInstrumentUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type LabDeviceMessageUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabDeviceMessageUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: NullableEnumProtocolKindFieldUpdateOperationsInput | $Enums.ProtocolKind | null
    rawContent?: StringFieldUpdateOperationsInput | string
    parsedOk?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}